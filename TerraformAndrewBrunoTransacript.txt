Course Intro
0:00
hey this is Andrew Brown over here on free cocam bringing you another free Cloud certification and this time it's
the hashicorp terraform associate version three and the way we're going to achieve certification is through lecture
0:14
content Hands-On labs and as always I provide you a free practice exam and so
0:20
at the end of the day you're going to get that certification and you could put it on your resume on your LinkedIn to demonstrate that devops skills and try
0:27
to go get that cloud or devops role you've been looking for or trying to upgrade to so if you like the materials
0:35
here a great way to support more content like this is to look at the paid additional materials it will also help
0:42
you increase the odds on your exam and it also really does help out and support the production of more of this kind of
0:49
content and if you are not familiar with me I produce a lot of different kinds of cloud certification courses like AWS
0:57
Azure kubernetes you name it I've taught it and so you're in really good hands
1:03
and we'll see you in class soon ciao foreign [Music]
1:11
everybody it's Andrew Brown and welcome to the start of our journey and we're asking the most important question first
1:17
which is what is terraform and I just want to tell you that I'm on screen now but I'm going to vanish here shortly and
1:23
stay out of the way so that you can see the full content but I just wanted to know you to know that I'm here with you
1:29
the entire way okay so the terraform associate certification is a specialty
1:34
certification in terraform terraform is a technology produced by hashicorp and
1:40
it's specifically for infrastructures of code and it's a declarative infrastructure as a code and it's a
1:45
cloud agnostic infrastructure as a code we will dive into all of this in great detail in the introduction section and
1:52
just notice that I put an asterisk there on declarative because there is something special about terraform that
1:58
we will discover if you are considering the terraform associate then you most
2:03
likely are looking for a devops role you want to automate infrastructure or
2:08
writing scripts you want to work with multiple Cloud providers or you know you
2:14
enjoy designing iterating on end-to-end infrastructure life cycle so if this sounds like anything that you are
2:19
interested in then you would probably want to take this certification I want
2:24
to tell you that terraform is one of the most in-demand skills for devops rules today and it's becoming quickly the
2:32
industry standard just because it is so flexible and works with all providers and goes beyond a lot of these other
2:39
tools and the terraform associate exam itself isn't that difficult
2:44
uh but I would say that the concept of learning terraform is a bit tricky because uh you know it's not something
2:51
that you can just go do the lecture content uh and and do the lab content I
2:56
had to do a mix of it uh so in this course you'll see me do lecture lab lecture lab because I'm trying to
3:02
solidify the knowledge as soon as we do that this is not the format that I use for my other courses it's just because
3:08
with terraform it requires patience it is a silical learning process to
3:13
understand so just uh stick with it and by the end of it you will be really good with terraform uh you know and so that's
3:21
that there so let's talk about our multi-cloud roadmap I'm going to get out of the way so we have a little bit more
3:26
room um and so you know what I would recommend uh is that you start with an
3:32
Associate certification so just getting my pen tool out here uh if I can get it here here we have the Google's Ace
3:40
um the cloud engineer or maybe some level of AWS uh associate certification
3:46
I personally think the sysops is the best pairing for terraform or the Azure administrator if you're going for Azure
3:53
and quite possibly learning more than two would be very beneficial but of course whatever your primary provider
3:59
you're using is where you're going to benefit with uh terraform and you really should learn this stuff before you do
4:06
terraform it is super hard to learn both cloud and terraform at the same time you
4:12
should have that Foundation before you tackle onto terraform and so there's a lot of different paths for multi-cloud
4:18
and just to kind of give you an idea of all the different ways you can go you know you can go from associate to either
4:24
Vault and to the Vault professional if you're looking at a security background but it's very common for people to get
4:30
the terraform and then go for uh Vault afterwards but you know it's up to you to which path you want to take
4:37
how long do you have to study to pass this exam well uh it's a spectrum based
4:43
on where your background is so let's take a look at beginners first so a beginner to me would be someone that's never written IC uh they have not
4:50
previously focused on automating infrastructure they might may not hold an associate level certification so
4:55
you're adding those additional hours or trying to make up the difference you could be looking at 30 hours or more if
5:02
you're already experienced with writing IAC but maybe just not terraform maybe you know Azure bicep or cloud formation
5:09
you already work in devops you're already comfortable writing scripts and you hold associate level certification
5:16
knowledge of you know a major cloud provider then you're looking at something like 12 hours but you know if
5:22
you're looking for a general study guide somewhere in between I would recommend between one to two hours a day for 14
5:29
days and you'll be in a really good place by then you know what does it take to pass this exam well there is a
5:36
lecture content and I have a lot of it um you know the thing is that
5:41
the exam itself is very practical it's not like AWS aws's exams where it's very
5:49
um uh Theory based at a conceptual level this one is very much how do we use this
5:54
technology and so the lecture content is there to really support the lab content
5:59
and you really really need to do the lab content uh because that's the nature of this exam
6:06
um and to make this a lot easier I do recommend taking some practice exams we
6:11
have a free practice exam and we also have uh many more practice exams if you
6:17
take all these Pax exams and you've done the labs prior to that you're going to be in really good shape to pass in terms
6:23
of the content outline um I can't remember how many domains we'll see how many there are but we have one so understand infrastructure as code
6:30
so I see Concepts understand the purpose of terraform understand terraform Basics the use of
6:36
terraform outside core workflows interact with terraform modules use the core terraform workflow
6:42
Implement and maintain State regenerate and modify configuration and understand terraform Cloud
6:48
capabilities so yeah nine domains uh something that's different about uh the hashicorp certifications is they do not
6:55
provide distribution of domains what do I mean by that well they're not weighted right so it's not like uh we know that
7:03
uh like eight is I'm going to have a particular weighting that's higher but
7:08
we can look at the exam guide outline to see generally how many questions we probably would so we could kind of infer
7:14
our own waiting but they do not provide it so I would just say it's not known but we'll take our best guess when we
7:20
look at the full exam guide outline where do you take this exam well you can
7:25
take it in an in-person test center or online from the convenience of your own home I do believe that the test center
7:31
that hashicorp is using is PSI or PSI online and understand that this is a
7:37
proctored exam so someone is supervising you watching you monitoring you as you take the exam so that you uh that
7:43
there's no funny business happening there's no cheating and to ensure that uh you know that you gain gain that
7:50
knowledge in a reputable way so just understand that in terms of the grading you need to get about 70 percent to pass
7:57
or round that it uses scaled scoring uh is it possible for you to fail if you've
8:02
got exactly 70 percent it might be so always aim to get higher than 70 percent
8:10
um and so I always say aim for a target of you know 10 to 15 above what the score is if you're getting that on your
8:17
prax exams then you're going to be in good shape in terms of the response types they don't tell you exactly how
8:23
many questions there are but I've always observed there's 57 questions and so you
8:28
know based on that calculation I feel that you have 70 17 questions you can get wrong there are no penalties for
8:34
wrong questions so always answer your questions do not leave any blank the format of the questions is multiple
8:40
choice and multiple answer and then sometimes you get a fill in the blank so type a one word answer most likely it's
8:48
going to be a command right so or a flag for a command so you definitely have to know the technical components of
8:55
terraform okay the duration of the exam is one hour so that means you get about a minute to answer per questions the
9:01
questions are very short format so it's not like you have to read a ton of text to figure out what's going on the exam
9:08
time is 60 Minutes the seat time is actually 90 minutes so when we say C
9:13
time referring to the amount of time you should allocate for the exam so that means that would include things like
9:19
time to review the instructions show uh show the online proctored your workspace to make sure there's nothing going funny
9:26
on with your environment read and accept the NDA complete the exam provide
9:32
feedback at the end and I'm going to tell you you really do want to get for
9:38
your exam much sooner than you think because it is a very stressful process and things tend to always go wrong when
9:45
when you uh when you don't show up early enough okay so just make sure you do that if you do pass this exam it's going
9:51
to be valid for 24 months so that's two years before recertification and the last thing I just want to talk about is
9:58
um well maybe not the last thing I got two more slides here for you but this course is going to be designed around the
10:04
1.1.6.0 specification of terraform and even when I'm making this course as
10:10
of today 1.60 is an alpha this will be in the future so 1.60 will be out but I
10:17
like to try to give you more knowledge in the future even if it's not an exam just so that you are prepared and this
10:24
course does not go stale sooner terraform is always incrementing inversion so you know when you study you
10:31
always want to go back three minor versions since I'm showing 1.60 it doesn't make a whole lot of sense but if
10:36
you're let's say you're on 1.54 you'd want to do one you want to make sure you know terraform for a range of versions
10:44
going a few versions back and so so you know I will be showing you things that may be deprecated but are still uh but
10:52
might still be in use based on the version that people are using so just understand that
10:58
um and again you know these these certifications are or the terraform certification is heavily dependent on
11:03
your practical knowledge so if you are taking the time to apply the knowledge uh this version difference differencing
11:09
is not going to make a big difference okay um so just make sure you know you put the time in with the labs
11:16
um now this is the third version of the certification and so I just kind of want
11:21
to tell you that not a whole lot has changed between version zero zero two and zero zero three uh the one of the
11:29
big differences is they change the badge design why I don't know uh is it better
11:34
who cares um but uh it is a different looking badge
11:39
um one thing is that there were superficial name changes to the outlines of the domain so basically all the
11:45
domains are the same they just kind of did some tweaks there they did kind of cut some content out in the uh the like
11:52
first uh first first two domains because those ones were just more General concept of knowledge and so they slim
11:58
those down I'm leaving that content in this course because I think it's very valuable to know more rounded knowledge
12:06
there so you're going to be over prepared for those first two domains there used to be this thing called
12:12
provisioners it's still in terraform but the thing is that it's just no longer needed to know in the exam so this is
12:19
about doing remote execution annoying all the provisioners and so I mean local
12:25
execute and remote execute are things you need to learn and definitely something that you will use on the job but knowing how to provision and use a
12:32
lot of Provisions is no longer a focus there there's this thing called null resource
12:37
that we learn about and now they have a new thing called terraform data so that is a evolution of terraform data so
12:44
we'll still learn about null resource but we'll also learn terraform data where it makes more sense to use
12:51
uh you know terraform Tate had taint has been replaced with uh just a flag uh
12:56
called hyphen hyphen uh uh replace uh on the terraform plan and we have a few
13:01
more others like that so refresh has a flag um and uh the thing was is that when I
13:07
made this exam the first time they were already talking about doing this so This exam is already
13:12
um my previous one is up to date with the current version of zero zero three
13:18
if that if that's surprising here uh terraform workspace is no longer part of
13:23
the exam um I would still cover terraform workspace uh you know if we come across
13:28
it because I still think again it's practical knowledge that you should know um connecting to terraform Cloud now
13:35
uses its own cloud block instead of remote block um I believe that we can still use remote block here and I will definitely
13:41
test that in the in the um in the uh the labs in this course so
13:48
you know it's good to know both of them but the focus will be using uh Cloud block um we have the lock file so the lock.hcl
13:56
files are new um I mean they weren't new when I made the previous exam so they were already
14:01
in there so again I already had this content here um but I'm just pointing out that that's
14:07
something that they're focusing on uh within the certification here um you need to know how to Mark data as
14:12
being sensitive again that's something I had in the older exam but one major thing is terraform cloud has a new UI
14:19
and it looks like there's a lot more functionality so in terms of the old exam or a course that I produce and this
14:26
one I'm definitely going to have to reshoot all of terraform cloud and go deeper into it there's obviously a few
14:32
different functionalities that have been added like the terraform Cloud block the terraform data block um but you know for the most part
14:38
there's not a whole lot that has changed so the majority of this will be very similar to the last one but I'm just
14:43
touching up and improving lab content where we can and hopefully adding a lot
14:49
more additional content to expand the terraform knowledge that I wasn't able to do the first time around so hopefully
14:55
that gives you a good idea of what you're getting yourself into uh but yeah we will proceed forward to looking at
15:01
the exam guide foreign
Introduction
15:07
Brown and welcome back as we are taking a look at the exam guide uh for the
15:13
hashicorp terraform associate certification I want to tell you uh throughout this course I'm going to show
15:20
you where I get things so I will be going to Google I will be typing in
15:25
where things are it's not because I don't know where things are I'm doing that for your benefits so that you build
15:31
up the skill to know how to find things just the way that I would go find things and I'll be very transparent about that
15:37
so for this one all I did was go into Google and type in terraform exam guide
15:42
and so I found it here this is also the place where you can register for the exam so if you click this it should load
15:49
up certain metrics I'll make a pop-up you have to authenticate it I'm not showing that here right now but when you are ready to register for the exam you
15:56
can go ahead and do that you'll notice they also have this button here called prepare for the exam they have their own
16:02
study guide here it's very text based heavy I do believe that somewhere in here there is a way to launch tutorials
16:10
and this will launch sandbox environments I think through instruct at least the last time I checked those are
16:17
great if you don't have an environment set up what I want to do with you is I want I want you to set everything up in
16:24
your own environment because I want you to have those Real World skills so you can use this stuff adjacent to this
16:31
course I've gone through all this material here I'm trying to cover things that aren't in here and try to make sure
16:37
that we are doing things without guard rails without the bowling bumpers because I want you get that Real World
16:43
Experience okay but I do want to point out that this is here and you can use it um and it's okay so let's scroll down
16:50
and take a look at our exam guide here and so here they say we have some
16:56
prerequisites so they say basic terminal skills that makes sense we're going to be doing a lot of stuff uh in terminal
17:03
basic understanding of on-premise and Cloud architecture uh I think what they really mean is do you know how to use
17:09
AWS you know how to use Azure gcp what is your major uh cloud provider or or stuff like that um now I keep talking or
17:17
focusing on AWS Azure gcp but understand that terraform can be used for anything
17:22
as long as there is a provider for it it can provision on almost anything okay
17:27
and that's why they're being very generic in their description this says the product version tested is terraform
17:33
1.00 and higher so it shows you that this is still even though it's the zero
17:40
zero three it's still really the zero zero two exam with some minor tweaks but just understand in this course we're
17:46
going to go well beyond this because I'm just future proofing you and making sure you have Real World skills let's scroll
17:51
on down here and let's just it's about renewing your certification so if you hold an
17:57
unexpired terraform associate 002 certification uh you can take the new one starting 18
18:04
months after your previous exam if you hold an unexpired one you can take the new exam starting 18 months after your
18:10
previous exam uh if you hold an expired one you're eligible to recertify at any time I really like this because what
18:16
happens for me with certifications not a problem for you but problem for me is that I will sit a certification and then
18:23
nine months later the new one comes out and I can't sit the new one and tell you about it so it looks like we've gotten a
18:28
bit of flexibility there and again I'm on video here I will get out of the way um it's just that we're in the uh these
18:34
earlier videos and I want to just hang out here with you okay going down below we can confirm it's the one hour
18:40
duration this is seventy dollars it might vary based on your location and other stuff you I just don't want to
18:46
tell you that 70 I want you to go through the process and find out yourself but that's probably what it's going to cost you
18:53
um there is no free retake included um some certifications like CompTIA you
18:58
are basically or uh the kubernetes ones from looks Foundation you basically get a retake so you're basically paying a
19:06
love for two and they call it a free retake which it really isn't free but uh I think this is okay
19:12
um I think it's fine there's no retake it's in English expires in two years we covered that before let's take a look at
19:18
the exam objectives so the first one is understand infrastructure as a code and Concepts they used to have a bunch of
19:23
junk in here um and honestly I didn't even know what they were talking about when they said that I remember I had to comb through uh
19:31
the study guide and try to watch uh articles and stuff like that but I think they realized
19:36
that it was junk uh that they were trying to uh impart too much conceptual
19:41
stuff and they cut back this one here same thing with two it doesn't show us the comparison of the
19:47
old one at some point on this website they showed the comparative between zero zero two and zero zero three
19:53
but all I'm saying is that they cut back here I have a bit more content on this in the course it's not going to hurt you
19:58
to watch it it's just going to help you understand it but you're not going to be tested 100 on this stuff the other thing
20:04
I want to note is that for each point that is here each subdomain or or Point whatever you want to call it they're
20:10
going to ask you a question on this is very different uh way of Designing uh an
20:15
exam uh other exams like AWS they will they will list a bunch of stuff but they
20:20
say it might not be on the exam or it might have stuff that are that's outside of it so you just have to broadly study
20:26
and uh you'll over over study for the content because you just don't know what
20:32
you're going to get uh get on the exam for hashicorp exams they're very fair if
20:38
you know each of these points you can expect to see them generally on the exam and that's how you're going to know that
20:45
you are ready if you if you know all these things in this course we're going to go beyond that because again I want you to have those Real World skills but
20:51
just feel confidence in knowing every single point Point here going down here understand terraform Basics install and
20:58
version terraform providers so that is what we will be doing a lot of in this because we're going to at least touch
21:04
more than one provider in this course I'm not going to go in great detail on
21:09
uh the cloud infrastructure part of it because you're already supposed to know it
21:14
um and I'm going to leave that for other things doing future projects for specific uh for for specific Cloud
21:20
providers we're focused here on terraform in this course not the underlying providers but we do use
21:25
multiple ones here describe plug-in based architecture write terraform configuration using multiple providers
21:31
describe how terraform finds and fetches providers so you can see there is a a lot of stuff about providers not to be
21:39
confused with provisioners I said earlier that provisioners is no longer covered in this certification course but
21:44
again the materials here so you can learn it for real world practice use terraform outside of core of core
21:51
workflows I think this used to be like you use terraform CLI outside of core workflows so they made a small tweak
21:57
there so it says destroy describe when to use terraform import to import existing infrastructure into your
22:02
terraform State terraform import is super super powerful going over to other
22:07
providers uh you know for a long time AWS did not have an import option and so the idea is that by having this import
22:14
we can bring an infrastructure that was not necessarily there before we have
22:19
terraform state to view our terraform State something that you're going to find unique to terraform is State
22:25
Management it's something that's super important and it's probably the hardest Concept in terraform because when you
22:31
use something like cloud formation or Azure bicep the state is managed by
22:37
services on those providers there isn't a managed service
22:42
managed service on those providers and so you have to decide where you want to
22:48
put your State uh and one example would be terraform cloud and that's one that we do use in this in this course here
22:54
describe one to enable verbose logging and what the outcome is so you have to know how to debug things here which is
23:01
great interact with terraform module so contrast and use different module Source options including public terraform
23:07
module registry interact with modules inputs and outputs describe variable scope and module child modules set
23:14
module versions modules is a way of creating reusable code uh we are going to use uh public
23:22
libraries as well as uh make our own modules making modules is not as hard as
23:27
you would imagine but they can get very complex uh so you know we're not going to go super Advanced into modules but we
23:33
are going to make sure we can write our own and and use public ones use the
23:38
terraform uh use the terraform workflow so this is something we're going to have
23:43
to know a lot about which is just the general life cycle workflow of working with infrastructure as code so we have a
23:50
knit validate plan apply destroy format plan it apply are the ones we're going to be using a lot of there is a lot of
23:57
trickery with the init so that's something else that we'll do there as well Implement and maintain state so
24:03
maintaining State working with State super super important so we'll look at how it works with local state state
24:10
locking handling back-end Cloud Integrations authentication methods uh you know they're talking about managed
24:16
providers like terraform Cloud the different between remote State back-end options manage resource drift
24:22
and terraform State terraform is super good at drift and fixing drift it's so
24:29
good at remediation compared to other IEC tools and that's why it is such a
24:36
popular tool to use describe back-end block and Cloud integration configuration understand secret
24:41
management and state files then we have regenerate modify configuration so demonstrate the use of variable
24:47
variables and outputs describe secure secret injection best practices understand the use of collection and
24:52
structural types create and differentiate resource and data configuration use resource addressing
24:58
and resource parameters to connect resources together use HCL and terraform functions to write
25:03
configuration describe built-in dependency management and the last one here is understand
25:09
terraform Cloud capabilities so explain how terraform clouds helps to manage infrastructure describe how terraform
25:14
Cloud enables collaboration government governance I'm going to tell you right now we're going to probably do more
25:19
terraform Cloud than we we need to it's just because when I made this course the first time I I just lightly did
25:25
terraform Cloud just enough to pass the exam I have the time to do a little bit more there I would like to do that for
25:31
your own benefit and so we will expand on that a bit more but you can see this is mostly about terraform the technology
25:38
not necessarily terraform Cloud the uh the service if you're confused about terraform and terraform Cloud uh again
25:45
we'll explain that in this course and make sure it's very clear what the difference is one other thing I wanted to notice that you do have some sample
25:51
questions here so you can go through here and you can just see that the questions are very straightforward and
25:58
they're just like this they're very simple uh but you know you do have to know
26:04
you do have to know what you're looking at and see like here they're showing code so you can see you have to choose code and you might get a code block so
26:11
it is very focused on the Practical component of it it's less about the conceptual okay but yeah hopefully that
26:18
gives you an idea of what we're getting into and we'll see in the next one okay ciao foreign
26:27
hey this is Andrew Brown from exam Pro and what I want to do is walk you through a few of our practices and
26:32
questions just to give you an idea of what it will be like on the real exam and where we might have had to make some
26:37
adjustments to help your study so what you'd have to do to access this prax exam is you'd have to be signed up and
26:44
logged in to the exam Pro platform make a way over to the hashicorp terraform course except the free tier or pay for
26:51
full access but once you go there you'll scroll all the way down to the bottom and you should see three or four
26:57
products exams at the time of writing this we're still writing the questions so that's why they're not shown in the video here but what I want you to do is
27:02
to go to the first practice exam and notice that there are 57 questions you get an hour on on the exam here and we
27:10
have a breakdown based on domain now the percentage is not something that uh terraform or hashicorp provides so we
27:16
just had to break it down based on the coverage of questions that we saw in the exam guide outline and so that should be
27:22
accurate enough and that's kind of what it felt like on the exam so I don't think that's going to be a problem if we click into here we're just going to look
27:28
at some of the questions I'll talk around them so the first one here is we have how do you create a workspace and it's showing us a bunch of CLI commands
27:35
and so on the exam you do need to know um uh you know CLI commands and the difference of them and the questions can
27:41
be as simple as this where you're just choosing the option and some are obvious distractors like there isn't there is no
27:47
one called terraform workspace Branch okay so just understand that you not just need to know the conceptual ideas
27:53
behind terraform but also it in practice okay another one here would be the terraform
27:59
registry can search based on the following Search terms we have an option to choose multiple questions and so this
28:04
is something that you will see on the exam where you're choosing multiples of something I didn't get a lot on my exam
28:10
but I cannot say for certain like how many questions would show up like this um but you know they're not really that
28:15
hard to figure out okay and this question is about um a tool or sorry uh the public
28:22
terraform registry website and that is just a uh a public-facing website if we
28:28
go to registry.terraform.io here it's this website here so it's not just the tooling of terraform itself but it's the
28:35
ecosystem around it so terraform Cloud the terraform registry things like that another type of question you will see
28:40
and I think it's over here is what they will do is they'll ask you to fill in the blank now we don't have that support
28:46
in our platform just as of yet but the idea is they'll say like okay uh we'll ask you a question or we'll even give
28:52
you um maybe they'll have like underscores they'll say fill in this thing and you'll literally have to type type the
28:58
answer in but the answer is going to be like a one word answer so on the exam I literally had a question which was like
29:03
where is the API stored and it was actually terraformed at TF state but I did not know I could not recall the name
29:09
of it which is kind of embarrassing but uh you know that is the level of fill-ins that you'll have to do and
29:15
you're very likely to see some code on the on the exam two so if I just click through here really quickly you may see
29:22
a code block okay and you might have to decipher it so that's the difficulty exam I would not say this is a heart
29:28
exam but you just have to understand the scope of those kind of questions and make sure that you have well-rounded
29:34
study in both practical and conceptual concepts of terraform so hopefully that helps you out okay
29:40
[Music] everybody there it's Andrew Brown and I
29:46
just wanted to tell you about the content that you're going through because honestly between the zero zero
29:52
two and zero zero three there was not much to update um and so you know the key differences
29:57
is the versions of terraform and the versions of the providers that you are using
30:03
um and for the most part everything worked out perfectly fine I thought that I'd have to reshoot all of the lab
30:09
content but it turns out nope barely nothing has changed what has changed and
30:15
I want to point this out early on is that when you are specifying a version for the provider just go use at least
30:22
version five zero you can use an older version if you want to follow along but uh you know I think it's better to be
30:29
more um up to date if you can the version that we were using prior in the
30:34
follow alongs was version three again there are no major changes that will break anything
30:41
um so at least there shouldn't be but I ran through these Labs my cloud support engineer ran through these Labs so we're
30:47
pretty confident you're going to be in good shape otherwise if they weren't I would go re-record them but I just
30:52
wanted to point out those two things uh there so hopefully you know that makes
30:57
sense and you're going to be in good shape okay now I did say that we're scoping things around terraform 1.6.0
31:05
and again there's not much to call out for that the biggest thing that I think that 1.6.0 might bring would be testing
31:12
and even if I looked into it and it just wasn't where I thought it was going to be so I did not include it at least at
31:18
this time in uh this uh this this course and again this is me going uh above and
31:24
beyond because I'm trying to just future proof the contents of this course and future proof uh stuff that I believe
31:29
that is coming to terraform form but yeah you should be in good shape and you know if there are any changes on exam
31:36
Pro we're very proactive of having those differences there so if you do run into anything that's giving you any kind of
31:42
issue they're going to be on the the main learning platform there okay if if for whatever reason there's minor
31:47
updates or things that are found out but yeah you'll be in good shape and have fun on your journey learning terraform
31:54
ciao [Music]
IaC Concepts
31:59
hey this is Andrew Brown from exam Pro and we are looking at what is infrastructure as code and before we talk about that we need to talk about
32:05
the problem with manual configuration so manually configuring your Cloud infrastructure allows you to easily
32:11
start using new cloud service offerings to quickly prototype architectures however it comes with a few downsides so
32:17
it's easy to misconfigure a service through human error it's hard to manage the expected state of the configuration
32:23
for compliance it's hard to transfer configuration knowledge to other team members and so this is why
32:29
infrastructure code is going to really help us out so infrastructure is code commonly abbreviated to IAC and you'll
32:35
see that a lot in this course allows you to write a configuration script to automate creating updating or destroying
32:42
Cloud infrastructure notice I gave great emphasis on automate or automation because that is really key to
32:48
infrastructure as code IEC could also be thought of as a blueprint of your infrastructure IEC allows you to easily
32:55
share version or inventory your Cloud infrastructure and just to kind of get your visualization imagine you write a
33:01
script and that's going to provision and launch a bunch of cloud services that
33:06
are all interconnected okay [Music]
33:14
all right so we're taking a look at popular IAC tools and so of course this course is about terraform but by
33:20
understanding um all the options out there if you understand why we're using terraform uh and one thing that is very
33:26
important to understand is the difference between declarative and imperative IAC tools those are the broad categories that we see for IAC so let's
33:34
start with declarative so the idea here is what you see is what you get everything's explicit it's more verbose
33:40
but there's zero chance of misconfiguration and this all relies on the fact that they use a scripting language such as Json yaml XML in the
33:48
case of terraform they have their own language called HCL but the way these languages are structured is that they're
33:54
very verbose and there's not a lot of programming logic involved so for Azure
33:59
we have arm templates and Azure blueprints for AWS we have cloud formation for Google we have Cloud
34:05
deployment manager and there there is of course terraform which has many cloud service providers such as AWS Azure gcp
34:11
kubernetes and a lot more but these are all in the declarative category
34:16
on the right hand side we have imperative so you say what you want and the rest is filled in everything here is implicit it's less verbose but you could
34:24
end up with misconfiguration and when I say that it's that like if you were to find um let's say a virtual machine you might
34:30
not have to provide every single uh option that you would normally do and it would fill in the rest but if you
34:36
weren't aware of what it was doing that's where you could end up with misconfiguration uh though I would say that imperative tools generally try to
34:43
always uh have their defaults as best practices so you're not usually in a bad
34:48
position uh but you know you might end up with something you don't expect imperative can do more than declarative
34:54
so there's just some very hard limitations with declarative languages so there's just cases where you want to
35:01
do imperative and the idea here is imperative languages use programming language you know like python Ruby
35:08
JavaScript golang you know whatever it is uh there's likely an SDK for it and
35:14
so it's just a lot more programmer friendly a lot of developers like imperative tools so AWS has their own
35:21
called Cloud development kit cdk and it technically only supports AWS I say
35:27
technically because hashicorp has a very cool library that allows you to generate out terraform HCL files which allows you
35:33
to work with anything but when we're just talking about cdk on its own it's just for AWS then you have plumy it
35:39
supports AWS Azure gcp and kubernetes so it can do a lot so why would you choose
35:45
with your team to use declarative over imperative well it just really depends on your your team right so like if
35:52
they're all used to if they're all administrators and they're used to using Json yaml and they're not good with programming languages that is one reason
35:58
why you might want to use declarative over imperative the other thing is just you know you prefer to know exactly
36:05
every single thing that was defined right you don't want anything left up to a chance and so that is another reason
36:12
why you might want to use declarative but both are great options it's just really depends depends on your team's
36:17
knowledge and what your goals are okay [Music]
36:24
so we just looked at imperative and declarative but I just want to clarify that terraform even though it's a declarative language it has
36:30
imperative-like features so I've coined the phrase declarative plus and so terraform kind of gives you the best of
36:35
both worlds so you have declarative and imperative and then the three types so our yaml Json XML we have terraform
36:41
language which actually utilizes HCL underneath and then you have programming languages on the right hand side like
36:46
Ruby python JavaScript what it have you right so when we're looking at yaml or Json these are very limited languages or
36:55
scripting languages where uh you know you don't really have any kind of complex data types you probably don't
37:01
have a whole lot of robust functions but in some cases you can extend That Base
37:06
Behavior so in the case of cloud formation which uses yaml or Json files they have a concept called macros so you
37:13
can extend it a bit but again it's very inflexible and so a lot of people are led to go and use cdk so terraform is
37:21
great because it kind of has a lot of stuff you'd see in programming languages like for Loops Dynamic blocks locals it
37:28
also has complex data structures and a lot of functions around using those data structures and so it allows you to stay
37:34
in that declarative world but having the stuff that you generally need when you're in the parative world when you're in the imperative side the idea is that
37:42
the language is what you're utilizing so you can do anything that the program language allows you to do but I just
37:48
wanted to kind of show you that terraform sits in the middle okay [Music]
37:55
hey it's Andrew Brown from exam Pro and we are looking at infrastructure life cycle so what is infrastructure
38:01
lifecycle it's the idea of having clearly defined and distinct work phases which are used by devops Engineers to
38:07
plan design build test deliver maintain and retire Cloud infrastructure where
38:12
we're talking about like sdlc so software development life cycle there's usually a really great visual that I can
38:18
show for you but for infrastructure lifecycle especially Cloud infrastructure lifecycle there isn't
38:23
something that is well defined which is weird by the definition but I think that there's just nobody's agreed up on one
38:31
yet or nobody's made the graphic yet so I just don't have anything to show you for that but I just want you to get
38:36
familiar with the term infrastructure life cycle because you're likely to hear it again but one particular
38:41
infrastructure life cycle that is pretty common is ones that talk about day zero day one and day two so the idea here is
38:49
this is a simplified way to describe phases of infrastructure life cycle so when we say we are on day Zero we are
38:55
planning and designing our infrastructure on day one we are developing and iterating it so we might
39:01
be uh you know deploying or provisioning it and actually testing it uh in the cloud and then day two is actually when
39:08
we go live with real production users and maintain it and the idea of mentioning day zero one and two is to
39:14
say Well when does IAC start and the idea is it starts on Day Zero okay the
39:20
days do not literally mean a 24 hour day it's just a broad way of defining where in the infrastructure project we would
39:27
be okay [Music]
39:33
so after defining what infrastructure life cycle is what advantage or what an
39:39
advancement are we going to have when we add IAC to our infrastructure lifecycle well the first thing we're going to get
39:44
is reliability so IC makes changes impotent consistent repeatable and
39:50
predictable I'm going to give extra attention here to impotent because it is a very strange English word but no
39:56
matter how many times you run your IC you will always end up with the same state that is expected that is a very
40:02
important concept of IEC whereas if you use configuration management there's no guarantee of that that's why you use
40:08
terraform over something like ansible okay you have manageability so enable
40:13
mutation via code revise with minimal changes and then you have sensibility so avoid financial and reputational losses
40:21
to even loss of life when considering government and Military dependencies on infrastructure so there you go
40:27
[Music] okay so it impotent is a very important
40:35
concept to infrastructure as code and so we're going to give it a little bit more attention I wouldn't stress out about
40:41
the pronunciation uh there's more than one way to pronounce it in English and I've probably even said it wrong uh in
40:47
the previous slide so uh just be uh forgiving on that part okay but the idea
40:53
is that let's stage a scenario between a non-itipotent example and an independent
40:59
example so when I deploy my IAC config file it will provision and launch two
41:05
virtual machines that is what I'm expecting okay and that is what I get but what happens when I go and I update
41:12
this infrastructure code file saying maybe I want to increase the size of the VMS or some of the configuration I
41:18
deploy that again when it's non-edepotent what will end up happening is I will end up with two additional
41:25
virtual machines with the new configuration and the old ones will be there and so this is something you might
41:30
not want because you just want to have a file that says exactly the state that you expect okay
41:37
so when we have something that is Idi potent the idea is we will go and we
41:42
will Define our two virtual machines and we will get our two virtual machines but we go and we update that file and we
41:49
deploy again and what happens this time is it just ends up modifying the original virtual machines or if it
41:56
really can't and it has to it might delete them and recreate them but the idea is that we end up in a state of
42:01
exactly what we want so in the first case we expect it to but we ended up with four but with the independent uh
42:08
case we expected to and we always end up with two so hopefully that makes that
42:13
very clear okay [Music]
42:19
hey this is Andrew Brown from exam Pro and what I want to do here is concretely Define the difference between
42:24
provisioning deployment and orchestration now in practice sometimes these have overlapping responsibility so
42:31
you might say provisioning when you really mean deployment or vice versa it's not a big deal uh we all get kind
42:38
of mixed up about it but I did want to just take the time to make sure that we understand what these things are
42:43
supposed to mean okay so the First on our list here is provisioning so to prepare a server with systems data and
42:49
software and then make it ready for Network operation if you're using a configuration management tool you are
42:55
most likely provisioning because that's what these tools do so puppet ansible Chef bash scripts Powershell or cloudnit
43:01
so you can provision a server when you launch a cloud service and configure it you are provisioning it okay then you
43:08
have deployments the deployment is the act of delivering a version of your application to run a provision server
43:15
deployment could be performed via AWS code pipeline harness which is a third-party deployment tool Jenkins
43:22
GitHub action Circle CI there's a lot more other providers out there then you have orchestration so orchestration is
43:28
the active coordinating multiple systems or Services orchestration is a common term when working with microservices
43:34
containers and kubernetes so orchestration could be done with kubernetes salt or fabric so if you're
43:40
working with containers generally like you use the word orchestration especially with kubernetes because you're working with thousands of
43:47
microservices okay so you know hopefully that helps you know the difference between the three again it's not a big
43:53
deal if you don't perfectly know them but there you go [Music]
44:01
hey this is Andrew Brown from exam Pro and we are taking a look at configuration drift so this is when
44:06
provision infrastructure has an unexpected configuration change due to team members manually adjusting
44:13
configuration options malicious actors so maybe they're trying to cause downtime or breach data or side effects
44:20
from apis sdks or CLI so you've written some code that uses a CLI and a bash
44:26
script and it does something you did not expect to happen so here an example
44:31
could be imagine you have a server like a database and a junior developer turns
44:36
off delete on termination for your production database this could be a problem where let's say there's an
44:42
accidental deletion of the database this feature would protect the database from
44:47
deletion but if it's turned off you don't have that right so configuration drift going unnoticed could be a loss or
44:53
breach of cloud services and residing data will result in Interruption of services or unexpected downtime so
44:59
there's a lot of downsides to to neglecting or not noticing configuration drift so what can
45:05
we do about this so how to detect so there's three things detect um we can fix it and then prevent it
45:12
okay so to detect configuration drift if you have a compliance Tool uh it can detect misconfiguration so it was config
45:19
can do that as your policies can do that gcp security health analytics can do that some of these are constrained to
45:26
security things not just configuration in general but there are tools there for
45:32
all the cloud service providers there is built-in support for drift detection for it was cloud formation it's called cloud
45:38
formation drift detection other providers don't necessarily have that if
45:44
you're using terraform which is this which is all this course is about you have the terraform State files which
45:50
says what the state of things should be so that's how you could detect configuration drift how to correct
45:56
configuration drift well compliance tools can remediate so again it is config you can create a custom Lambda to
46:02
say hey when this happens then do this so set the configuration back into place with terraform you can use the refresh
46:09
and plan command which we'll look at in detail in this course or you can manually correct it so if the option was
46:16
changed you could do that not recommended to do that another thing would be tearing down and setting up the infrastructure again
46:22
because that would bring it back into its original state that could be a risky thing to do depending on how you have
46:29
things set up or could be it could be fine right then there's prevention so um this is a the important thing and
46:36
kind of why we're talking about configuration drift which is all about immutable infrastructure so always create and just destroy never reuse so
46:43
that might be blue green deployment strategies servers are never modified they are all they're just always
46:49
deployed with a new version the way you would do that would be baking Ami images or containers via AWS image Builder or
46:56
hashicor Packer or a build server like gcp Cloud run or code build like AWS but
47:03
the idea is that you're not modifying after they're deployed you'd have that image already ready to go another thing
47:09
you could use is git Ops so you would Version Control your IAC like within
47:14
GitHub or something like that and you would peer review every single uh change the a pull request to the infrastructure
47:21
so hopefully that gives you an idea of things we can do to tackle configuration drift okay
47:27
[Music] we were just talking about immutable
47:33
infrastructure but I just want to give it a bit more attention here so the idea
47:38
is um we are going to first develop our infrastructure as a code file terraform
47:44
cloudformation what have you and then we're going to go ahead and deploy that so we'll end up with our own virtual
47:50
machine and that virtual machine needs to be configured so you need to install packages and things like that that's
47:55
where Cloud init would come into play ansible puppet Chef salt whatever configuration management tool you want
48:01
to use the problem here is that there's no guarantee that that configuration is going to stay in place so that's where
48:08
immutable infrastructure comes into play so we develop our infrastructure as a code file terraform cloud formation and
48:16
then we're going to go ahead and do our configuration by building a virtual machine or building a container so we
48:22
can use something like Packer and then the idea is once we are happy with our configuration what we're going to do is
48:29
bake that image and put it in an image repository and then that image is going
48:34
to be referenced when we do our deploy and so that's going to make sure that our infrastructure is always immutable
48:39
okay [Music]
48:44
hey this is Andrew Brown from exam Pro and we are taking a look at the concept or methodology of git Ops so this is
48:51
when you take infrastructure as code and you use a git repository to introduce a
48:56
formal process to review and accept changes to infrastructure code and once that code is accepted it automatically
49:02
triggers a deploy and changes that infrastructure so here's my illustration through it so the idea is you would have
49:08
a terraform file and you would place that in something like GitHub you would apply your commits and when you're ready
49:15
you'd make a pull request you would merge that pull request into the main branch or whichever branch is set up for
49:21
production and that could trigger something like GitHub actions and GitHub actions would then trigger a terraform
49:28
plan and and accept it or maybe you have to manually intervene to say Okay I accept these changes but then it would
49:35
roll out those changes now terraform does have their own and it's pretty darn similar but I thought mine was a bit
49:40
easier to read but the idea is you have your git repository you have your pull request this is pulling from terraform
49:47
Cloud because you can have files and state managed there so that is another
49:53
means to do it but that's generally how it works okay foreign
49:59
[Music] so we were just looking at immutable infrastructure but what I want to do is just kind of cement in your head things
50:05
that you should be asking yourself as a devops engineer so that you kind of lean
50:10
towards that immutable uh kind of way of thinking and so this is mostly going to
50:16
be applicable for virtual machines but let's just ask some questions of things we should be thinking about so what's
50:22
going to happen if we deploy our virtual machine and there is a physical failure of the hardware by the provider so this
50:29
can sometimes happen on AWS where they have two status checks that have to complete before a virtual machine is
50:34
ready sometimes they fail and so you know your infrastructure is not ready to graded or damaged right then you have
50:41
application failure so you have this post installation script maybe to install your application and there's
50:48
either a bug so introduced by developer or maybe there's just a dependency and
50:54
it's changed and so it's breaking your app what happens when you need to deploy in a hurry what have happens in worst
51:01
case scenarios where you have accidental deletion compromised by malicious actor need to change regions maybe there's a
51:06
region outage and so the thing is is that when you look at these things what happens when multiples of these happen
51:13
at the same time because that's the problem where you know it's like okay I have something wrong with my application code but I also have uh you know now we
51:21
also have a region down and so you don't want to be dealing with more than one problem at the same time and so that's we're going to have an issue of agility
51:28
in terms of deployment another thing that is overlooked is there's no guarantee of one to one if you are
51:34
configuring your code after deployment because if you were to deploy a virtual
51:40
machine and installed all the dependencies and then you to were to deploy a virtual
51:46
machine literally a minute later one of those dependencies could have a minor revision and so that would be deployed
51:52
with that one minor revision so they would look very similar but they aren't one to one so by introducing golden
51:57
images which is an immutable infrastructure idea you get a guarantee of one one to one with your Fleet you
52:03
have increased Assurance of consistency security you have you can speed up your deployments the reason why you have an
52:08
improvement of security is because at that stage you could um you could perform kind of Security
52:14
checks and things like that there on that image before you roll it out so I don't know um I would just say that I
52:20
would recommend that you go with the immutable infrastructure or baking your images when you can if you're using VMS
52:25
okay [Music] hey this is Andrew Brown from exam Pro
Hashicorp Introduction
52:32
and we're going to take a look here at what is hashicorp so hashicorp is who creates terraform and they are a company
52:38
specializing in managed open source tools used to support the deployment and development of large-scale service
52:43
oriented software installations and they have their own cloud platform called the hashicorp cloud platform hcp and it's a
52:50
unified platform to access hashicorp various products so uh the main thing is that it's Cloud agnostic so hashicorp
52:57
makes it really easy to build across cloud and they have support for all the three main providers so AWS gcp Azure
53:03
I'm sure they have more support like kubernetes and things like that they're highly suited for multi-cloud workloads
53:09
or cross-cloud workloads and they have a lot of products that will help you out there so let's go through them quickly
53:15
so first we have boundary this is secure remote access to systems based on trusted identity this is console this is
53:21
a full featured service mesh for secure service segmentation across any cloud or runtime environment you have Nomad this
53:27
is scheduling and deployment of tasks across worker nodes in a cluster you have Packer which is a tool for building
53:33
virtual machine images that will be later deployed or they will place them in a image repository then you have
53:39
terraform which is infrastructure as code software which enables provisioning and adapting virtual infrastructure
53:45
across all major providers then you have terraform cloud and this is just a place to store and manage your IAC State files
53:53
and things like that with a team or just in the cloud by yourself we have vagrant so building and building and maintenance
53:59
of reproducible software development environments via virtualization technology we have Vault so secret
54:05
management identity based access encrypting application data auditing of Secrets for application systems and
54:11
users and lastly we have Waypoint a modern workflow to build deploy and release across multiple platforms so
54:19
there you go [Music]
54:24
hey this is Andrew Brown from exam Pro and we are looking at what is terraform so terraform is an open source and Cloud
54:30
agnostic infrastructure as a code tool and terraform uses declarative configuration files and the
54:36
configuration files are written in the hashicorp configuration language HCL and so that's what you can see on the right
54:43
hand side we'll generally call it the terraform language which we'll talk about later but notable features of
54:48
terraform are installable modules plan and predict changes dependency graphing State Management and provisioning
54:55
infrastructure in familiar languages that's something you could do via AWS cdk so I wouldn't say it's core to
55:02
terraform but that's what they listed on their websites that's why I put in there and terraform registry which has over 1
55:07
000 plus providers okay so there we go [Music]
55:15
so we were just looking at terraform but what is terraform Cloud well it's a software as a service offering for
55:21
remote State Storage Version Control Integrations flexible workflows and allows you to collaborate on
55:27
infrastructure changes within a single unified web portal and this is all accessible via terraform.io and the
55:35
first thing you'll have to do is create yourself an account on terraform i o but it's free to start with and they actually have a very generous free tier
55:41
that allows for team collaboration for the first five users of your organization that's not part of the team's plan that's part of the free plan
55:48
and in the majority of cases you really should be using terraform Cloud as your remote backend even if you are an
55:54
individual just because you know it makes experience so much better the only case that you might not want to use
56:00
terraform cloud is if you have a very large company that's trying to meet particular regulatory requirements and
56:07
it's not that terraform Cloud does not meet them but sometimes there's just a long procurement process so in the
56:13
meantime you would have to use something like standard remote back end or Atlantis or maybe you need to investigate terraform Enterprise I do
56:20
want to note that terraform cloud and terraform Enterprise is the underlying software known as terraform platform
56:26
it's not something you're going to ever have direct access to but just to clarify that terminology okay
56:32
[Music] so what I want to do is just set you up
Terraform Basics
56:39
with understanding the terraform life cycle this is not necessarily uh described in the documentation anywhere
56:45
but it's something that is inherently known when you're working with terraform uh and it's definitely not uh inclusive
56:53
with every single command that can be ran but the ones that you're going to counter most often so at the start
56:58
you're going to be writing or updating your terraform configuration file okay and from there the first thing you'll
57:04
want to do is initialize your projects and or if you need to pull the latest
57:10
providers and modules you're going to use terraform indit to do that as well from there you're going to use plan so
57:15
plan allows you to speculate what will change or generate a saved execution plan that you could use later on when
57:22
you run plan validate happens automatically but you could also run this separately and ensures types and
57:27
values are valid ensures the required attributes are present within your configuration file from there if
57:33
everything is good you're going to execute your execution plan by running terraform apply you can also from this
57:40
point use terraform apply to destroy infrastructure so if you have things set up there's actually a flag for it or you can use the Alias the terraform destroy
57:47
command and then you know as you work you're just going to keep updating your code and that is the terraform life
57:53
cycle so you know hopefully this gives you kind of a a snapshot of what the workflow will be and I mean we'll be
58:00
covering it tons and tons of times over in this course okay foreign [Music]
58:08
hey this is Andrew Brown from exam Pro and we are taking a look at change automation but to understand that we
58:14
need to first talk about change management so this is a standard approach to apply change and resolving conflicts brought about by change in the
58:21
context of IAC change management is the procedure that will be followed when resources are modified and applied via
58:27
configuration scripts so what is change automation then it is a way of automatically creating a consistent
58:33
systematic and predictable way of managing change requests via control and policies notice and I should have
58:39
probably emphasized this is change requests saying I'm going to change these resources terraform uses change
58:45
Automation in the form of execution plans and resource graphs which will look at detail those two things in
58:51
upcoming slides and apply review complex change sets so a change set is a collection of commits that represents
58:57
changes made to a versioning repository and for IEC uses change sets so you can
59:03
see what has changed by who over time so when I say versioning repository that
59:08
doesn't necessarily mean get and if you're using get Ops I suppose you could consider your chain sets being committed
59:14
to that but something like cloud formation when you apply a change you
59:19
actually have to accept a change Set uh and so the version repository is part of AWS and so um it will terraform you just
59:26
kind of accept it in place it's not necessarily on your local machine but I guess reflecting your state file okay so
59:33
change automation allows you to know exactly what terraform will change and in what order avoiding many possible
59:38
human errors a change automation is essential to any IAC tool they all have it okay so there we go
59:44
[Music]
59:49
this is Andrew Brown from exam Pro and we are taking a look at execution plans so this is a manual review of what will
59:55
add change or destroy before you apply changes and so let's say you type in terraform apply it's not just going to
1:00:01
go ahead and do that it's going to have you uh type in yes or accept the value but what you can do is see the resources
1:00:08
or configuration settings that will be added changed or destroyed and it will summarize them at the bottom and then
1:00:13
you'll have to type something like yes in order to accept the changes okay [Music]
1:00:21
something else I want to show you is that you can actually visualize your execution Plans by using the terraform
1:00:27
graph command and terraform will output a graph of his file you'll have to have graph Vis installed but Graphics is an
1:00:33
open source tool for drawing graphs specified in the dot language scripts having the file name extension of GV so
1:00:41
I believe this is cross-platform it's open source but once it's installed in your machine you can run terraform graph
1:00:47
and here this is Linux so we're using a pipe to say okay pass it over to graphis which is Dot and that is going to then
1:00:54
create an SVG file you can just open that in your browser and the idea is you're going to get this graph which
1:00:59
kind of shows you the relationship of the resources here but we'll talk about the these relationships in the next
1:01:05
slide here which is a resource graph okay [Music]
1:01:12
let's take a look here at the resource graph so terraform builds a dependency graph from the terraform configurations
1:01:17
and walks this graph to generate plans refresh rate and more when you use terraform graph this is a visual
1:01:24
representation or presentation of the dependency graph if you're wondering what a dependency graph is in
1:01:29
mathematics it's a directed graph representing dependencies of several objects towards each other so it's
1:01:34
pretty much like nodes with relationships between other nodes so that is one that I generate out from
1:01:41
terraform and so there's a few different types here we have a resource node that represents a single resource a resource
1:01:47
meta node represents a group of resources but does not represent any action on its own and provider
1:01:53
configuration nodes that represents the time to fully configure a provider will you need to know this for the exam
1:01:58
probably not do you need to know this in great detail probably not because there's a lot to the resource graph but
1:02:04
the idea here is just kind of like terraform saying just so you know we're using a graph database and graph
1:02:09
databases are very well suited for this kind of stuff and that's why terraform
1:02:14
is very good at figuring out conflicts and things like that okay foreign
1:02:22
[Music] from exam Pro and we are taking a look at terraform use cases and the idea here
1:02:28
is not necessarily because it's going to show up in the exam but the idea is to give you a business use case or to highlight the features as to why you'd
1:02:35
want to be using terraform and the first one here is that it has exotic providers so terraform supports a variety of
1:02:42
providers outside of gcp AWS and Azure and sometimes is the only provider terraform is open source and extendable
1:02:48
so any API could be used to create IC tooling of any kind of cloud platform or technology so you can make your own
1:02:54
provider there's some interesting ones that they have like Heroku or even Spotify playlists I have my own platform
1:02:59
called teacher seat and I want to have IAC for my platform and so this is what
1:03:04
I'm going to be using terraform for for multi-tier applications terraform by default makes it easy to divide large
1:03:10
and complex applications into isolate configuration script modules you'll notice in this course that when you have
1:03:16
a bunch of terraform files they're all treated as one so that makes it really easy to split up your uh your projects
1:03:22
or your your infrastructure so so it has a complexity advantage over Cloud native IC tools for its flexibility while
1:03:28
retaining Simplicity over imperative tools then we have disposable environments this is not unique to
1:03:34
terraform it's any kind of ISE tool but easily stand up an environment for a software demo or a temporary developer
1:03:39
environment resource schedulers so terraform is not just defined to infrastructure of cloud resources but
1:03:45
can be used to set Dynamic schedules for Docker containers Hadoop spark and other
1:03:51
software tools you can provision your own scheduling grid and the last one here is multi-cloud deployment terraform
1:03:57
is cloud agnostic and allows a single configuration to be used to manage multiple writers and to even handle
1:04:04
cross-cloud dependencies and that is a big deal and is a very unique offering to terraform okay
1:04:10
[Music] let's take a look here at terraform core
1:04:16
and terraform plugins so terraform is logically split into two main parts terraform core which uses remote
1:04:23
procedure calls RPC to communicate with terraform plugins and terraform plugins so expose an implementation for a
1:04:30
specific service or provisioner something that's interesting to know is just terraform core is written in go
1:04:37
um you know you probably will never encounter it but it's just a fact okay and so here's the graphic that terraform
1:04:43
uses to kind of like explain terraform core versus terraform plugins and how
1:04:49
they all relate so here's the terraform core and here are the plugins notice we
1:04:54
have providers here which will cover provisioners uh and there's just this is the group for plugins overall
1:05:01
um but yeah that's about it we'll show up an exam probably not but it's good to understand from a top level view the
1:05:08
split between these two things okay [Music]
1:05:14
if you are new to terraform I just wanted you to be aware of an additional resource that you can use Beyond this
1:05:20
course which is called terraform up and running so it's a a book and it has a
1:05:26
deep dive into the internal workings of terraform and this is really great if you want to go beyond this course Beyond
1:05:31
certification beyond the basics because what it will do is teach you about testing with terraform Cloud zero
1:05:37
downtime deployment common terraform gotchas and compositions of production
1:05:42
grade terraform code there's a lot more to it and this book in particular is written by Jim who's the co-founder of
1:05:48
grunt work and we do have a whole section just on grunt work and the thing is I just want you to know about this
1:05:54
resource you definitely don't need it to pass a certification or to have a good understanding or working of terraform
1:06:01
but you know at some point you if you want more I just want to point you to that resource okay [Music]
1:06:10
there's one other resource I want you to check out for terraform and this one is free and just online and it's the
1:06:16
terraform best practices so it's an open book it's a get book so it's essentially a Wiki and it basically covers the best
1:06:24
practices that are being used in the industry and so this is stuff that is separate from the terraform documentation it's just good practices
1:06:31
you know if you're going to be using terraform professionally within the industry so I just wanted to make you
1:06:37
aware of this resource and to go check it out okay foreign
1:06:43
[Music]
1:07:24
foreign [Music]
Terraform Provisioners
1:07:41
hey this is Andrew Brown from exam Pro and we are taking a look at terraform provisioners so provisioners install
1:07:46
software edit files and provision machines created with terraform and terraform allows you to work with two
1:07:51
different provisioners we have Cloud net and Packer so Cloud init is an industry standard for cross-platform cloud
1:07:57
instance initialization when you launch a VM on a cloud service provider you'll provide either a yaml or Bass script and
1:08:05
so for the case of AWS what you'll have is this box called user data and so you can either put your yaml or Bass script
1:08:11
in there it's the same if you're using Google or Azure they both have this box it might just not be called user data
1:08:17
but that is using Cloud init underneath then you have Packer this is an automated image Builder service you
1:08:23
provide a configuration file to create and provision the machine image and the image is then delivered to repository
1:08:28
for use if you've ever heard of ec2 image Builder it's a very similar service except that one's just for AWS I
1:08:34
suppose for Google you can use Google Cloud run and even on AWS you could use um
1:08:40
code build but uh Packer is great because it's Cloud agnostic so you're going to just build the image and then
1:08:45
you can deliver it to any provider provisioners should be used as a last resort for the for more
1:08:52
common situations there are better Alternatives this is a warning that hashnode puts out in their terraform provisioner section and so I wasn't
1:08:59
really sure why they were saying this so I reached out to Anton and Anton uh if you don't know him he's an as Community
1:09:05
hero just like myself and so he specializes in terraform like he wrote
1:09:11
so many modules for the terraform AWS so he knows it pretty well and he says here the main reason is that provisioners
1:09:17
will do something that won't be reflected in the terraform State and the better alternative for that one is to
1:09:23
use cloud provider features like Cloud init scripts I think this comes back to immutability when we're looking at the
1:09:30
fact that we want to lean towards doing an approach with Packer right we want to
1:09:36
um uh bake our Baker machines or virtual machines and then deploy because that's going to be probably the better
1:09:43
alternative so if we wanted to use cloud init the idea is we'd have to provide a
1:09:48
cloudinet yaml file which is a a very particular format you can find them on the cloudinet website and the idea here
1:09:54
is we have these run commands so this just like bash commands here to start and stop Apache we can install our packages here do an update do an upgrade
1:10:01
we'll have to pass along our SSH key here that's a very important component
1:10:06
to that once we have that file configured we can reference it as a template file over here call it user
1:10:13
data and then we're going to pass it on to this section here for user data so that when we launch up this VM and this
1:10:19
one in particular is for AWS that's going to pass it to that user data okay now you might be asking well where's all
1:10:25
these other provisioners because there's a lot of other tools out there so terraform used to directly support third-party provisioning tools in the
1:10:32
terraform language but they were deprecated because it was considered to be poor practice suggesting better
1:10:38
Alternatives as we were just talking about so you might be asking where is Chef where is puppet where is salt and
1:10:44
the thing is is that you can technically still use chef and puppet through Cloud init because cloudinit actually supports
1:10:50
some dsls in there I've never used this before myself but it doesn't look too complicated but the idea is that there's
1:10:56
just not direct support so you're not going to use it directly in the language you can use it through cloud in it if
1:11:01
you really need it one thing I didn't see mentioned anywhere was ansible and this one's a little bit confusing because there's a lot a lot of videos
1:11:08
online about terraform and ansible working very well together and they're complementary Technologies so ansible is
1:11:16
a little bit different than these other ones because it does more than just configuration management so maybe that's the reason there
1:11:22
um but anyway the point is is that there's no direct support for these anymore you got to use cloud in it and generally if you can use Packer instead
1:11:28
when you're working with virtual machines okay [Music]
1:11:35
hey this is Andrew Brown from exam Pro and we are taking a look at local exec which allows you to execute local
1:11:40
commands after a resource is provisioned so the machine that is executing terraform so what's doing the terraform
1:11:47
apply is where the command will execute and a local environment could be your local machine so your laptop or
1:11:54
workstation a build server like gcp Cloud build a business code Builder Jenkins or terraform Cloud run
1:12:00
environment so that is a single use Linux virtual machine so just an example
1:12:05
and there's a lot of cases where you might want to automate but the idea here is after your provision a VM you need to
1:12:11
supply the public IP to a third-party security service to add the VM IP address and you can accomplish this by
1:12:17
using locally installed third-party cli's on your build server and so there is a bit of an overlapping
1:12:23
responsibility between terraform outputs versus local exec because the idea is that by getting by getting data out
1:12:30
after something is provisioned or something like that you can do something pragmatic but the idea here is terraform
1:12:36
outputs allow you to Output results after running terraform apply local exec allows you to run any arbitrary commands
1:12:42
on your local machine commonly used to trigger configuration management like ansible Chef or puppet okay
1:12:48
[Music] let's take a look at some example code
1:12:54
for a local exec so here we have a bunch of examples on the right hand side and so I just kind of want to walk through
1:13:00
some of the commands that we can use but before we do that just let's take a quicker look here at the code so notice
1:13:05
we have a resource like Ava's instance in web and then we are specifying a provisioner being a local exec and then
1:13:12
we have a command that is being executed under there okay so hopefully that makes it pretty clear but let's just kind of
1:13:17
work through the options we have available to us so the first is we have a command and this is required and this is the command you want to execute so
1:13:24
notice that we are doing an echo there so it's whatever is possible uh there
1:13:30
and I think by default it's using bash okay so if you're using Linux that's what it would be using we could also set
1:13:36
a working directory we don't see an example there on the right hand side but if you wanted to say where the command
1:13:41
will be executed that's something you could do so maybe you want it over here another thing is The Interpreter so this
1:13:47
is the entry point for the command I think by default again it would probably use bash if you're on Linux machine but you could say use bash Ruby it was CLI
1:13:55
Powershell whatever you want okay if you needed to pass environment variables in maybe you need a key and
1:14:01
secret so the example here is you know we are printing out those keys and then putting them into a credentials XML file
1:14:09
so that could be an example there okay [Music]
1:14:16
hey this is Andrew Brown from exam Pro and we're taking a look at remote exec so this allows you to execute commands
1:14:22
on a Target resource after a resources provision so the idea is you have a local machine executing terraform and so
1:14:29
the idea is that when remote exact happens it has a script and it's sending that off to the Target so this case it
1:14:36
could be a provision virtual machine and this is where the command is going to run so a remote execute is useful for
1:14:41
provisioning a virtual machine with a simple set of commands for more complex tasks it's recommended to use cloud init
1:14:48
and strongly recommended in all cases to bake golden images via Packer or uc2 image Builder if you want to use
1:14:53
something more complex like ansible or something [Music]
1:15:00
let's take a look at an example of a remote exec script so here we have a couple and just to quickly go through it
1:15:07
the idea is you define your resource so here it's just a virtual machine on AWS
1:15:12
and we are provisioning our provisioner is going to be remote exact and so we're able to put these inline commands and
1:15:18
say okay let's run puppet apply and then we'll use console join which is the CLI for hashicorp console so there are three
1:15:26
different modes for a remote exec the first is inline list of command strings which is what we are seeing over here
1:15:33
and then the other option is we can provide a script or scripts so the idea
1:15:39
is that you would um well you just specify those locations and it would run it what's interesting
1:15:46
here is that it doesn't say um like because we saw with local exec that we could use an interpreter and so
1:15:53
it's my assumption that it's just going to use bash or it's going to use a script that is executable right where
1:16:00
you have a shebang in the top there and so that's something you know I might test out it's not something that's going
1:16:06
to be on the exam but maybe we'll just test out that theory because it's not in the documentation as of the time I'm
1:16:11
recording this [Music]
1:16:16
let's take a look at the file provisioner and this is used to copy files or directories from our local machine to the newly created resource so
1:16:24
here we have some on the right as an example so again we have a virtual machine that we're deploying to AWS
1:16:30
we've set the provisioner as file and we are specifying a source file and a destination so source is going to be the
1:16:37
file that's on your local machine or whoever is the considered the local you
1:16:43
might also want to provide content directly so in this example here you see that we're literally just giving it a
1:16:48
string and then there's the destination where you want that file to be I don't have it shown in the code example here
1:16:55
but there's a high chance that you would have to provide a connection block so that you could say okay I need to use
1:17:01
SSH or winrm to gain access to that machine
1:17:06
okay [Music]
1:17:11
so we just mentioned that there's a connection block so it tells the provisioner or resource how to establish
1:17:17
a connection so here is a big example on the right hand side so this is using the
1:17:22
example for a provisioner file and here we are specifying our connection block and this one in particular is for SSH as
1:17:30
you can see and there's a bunch of different parameters like the user the password the host you could also use a
1:17:36
Bastion host I don't I'm not showing it here but if you're using SSH you could specify a bunch of keys in order to do
1:17:42
that because maybe you need to go through a Bastion first for Windows Remote Management you also
1:17:48
have that option down below okay [Music]
1:17:55
hey this is Andrew Brown from exam Pro and we are taking a look at null resources so this is a placeholder for
1:18:00
resources that have no specific Association to a provider it's a bit confusing but it makes sense once you
1:18:07
run into some use cases for it so here is a big example where we have an AWS
1:18:13
instance and we're defining a cluster and so we need a null resource here because we want to run this trigger and
1:18:21
that's generally why you're going to be using null resources is to trigger a resource so triggers is a map of values
1:18:27
which should cause this set of Provisions to re-run so values are meant to be interpolated references to
1:18:33
variables or attributes of other resources and triggers are interesting because I think we also see them in
1:18:39
terraform Cloud I'm not sure if this is the same kind of functionality but yeah that's in all resources okay
1:18:45
[Music] all right let's take a look at terraform
1:18:51
data so this is very very similar to null resource but the key difference here is that it does not require or the
1:18:59
configuration of Provider because when you install null resource it actually installs a provider called null and so
1:19:07
now it's just with this dare terraform data you can do something very similar like this with null resource and
1:19:13
literally replace it with terraform data and for more or less it will do the same thing now it's not one to one because uh
1:19:20
some of those parameters are a little bit different so instead of triggers we have triggers replace but more or less
1:19:27
you know you can almost replace it and get the exact same result and you know I
1:19:34
would recommend it over using null I was trying to figure out if there was a case
1:19:39
where you'd want to use an all resource but I really could not determine that it
1:19:45
did not seem like there was anything additional so yeah there you go it's as simple as that [Music]
1:20:01
foreign [Music]
Terraform Providers
1:20:22
hey this is Andrew Brown from exam Pro and we are taking a look at terraform providers so providers are terraform
1:20:27
plugins that allow you to interact with cloud service providers like AWS Azure gcp software as a service provider so
1:20:34
GitHub and Golia stripe or other apis such as kubernetes or postgres servers
1:20:40
there's a lot there there's like over a thousand providers so providers are required for your terraform
1:20:45
configuration file to work so you have to have at least one provider and providers can come in three different tiers we have the official one so
1:20:51
published by the company that owns the provider technology or service verified so actively maintained up to date and
1:20:57
compatible with both terraform provider communities so published by Community member but no guarantee of Maintenance
1:21:02
up to date or compatibility providers are distributed separately from terraform and the plugin must be
1:21:07
downloaded before use so if we do terraforming knit this will download the necessary plugin provided plugins listed
1:21:13
in the terraform configuration file so there you go [Music]
1:21:20
hey this is Andrew Brown from exam Pro and we are taking a look at the terraform registry so this is a website
1:21:26
portal to browse download or publish available providers and modules and just remember providers and modules are
1:21:33
plugins within terraform both of them okay so to get to this website we go to
1:21:38
registry.terraform.io and everything published to the terraform registry is public facing so let's just distinguish
1:21:44
between providers and modules and I feel that I should have given providers a little bit more attention in the uh in
1:21:51
its own slide but I'll give it a clear distinction between providers and modules here so a provider is a plug-in
1:21:57
that is a mapping to a cloud service provider's API so if you wanted to call
1:22:03
individual API actions that is what the provider is providing to you when we're
1:22:08
talking about modules a module actually relies on a provider plugin but a module is a group of configuration files that
1:22:15
provide common configuration functionality this is going to help you enforce best practices reduce amount of
1:22:20
code code reduced time to develop scripts so the way to think about it is imagine that you have to do something in
1:22:27
your CSP like AWS and there's just common things that would go along with it so let's say you're launching a load
1:22:33
bouncer Auto scaling group with ec2 instances that's a bunch of services that you are just very common you'd have
1:22:38
to configure it together so there could be a module that allows you to do all that with writing very little amount of
1:22:44
code it will choose best practices when doing that okay [Music]
1:22:52
let's take a look here at providers and modules within terraform registry really quickly so um here is the AWS one here
1:22:58
and so I just want to point out that this official one is by hashicorp it's not by AWS but it does mean that it has
1:23:04
uh proper support so you know it's going to have pretty much one-to-one mapping to the AWS API
1:23:10
um and so it has really really good documentation now I complain about terraform not having great documentation
1:23:17
for learning like their language but for the actual documentation of doing things practically they're really really good
1:23:23
and here's just an example where we see app mesh and they just give you full examples for basically everything it's
1:23:28
really great and if you need a code sample to get going like to actually install it within your configuration
1:23:35
file it's right there over here so you can just go ahead and grab that for terraform modules it looks pretty
1:23:42
similar so the idea is you get your module code on the right hand side here you want to check out the examples it's
1:23:48
going to be dependent on who is developing these modules this one is made by Anton so he has lots and lots of
1:23:55
really great examples and then you can see a list of dependent modules here under sub modules so it's not too
1:24:00
complicated so there you go [Music]
1:24:06
so we're taking a look at terraform registry which is a public registry but let's talk about private registry how
1:24:12
would we do that well that's where we use terraform Cloud it allows you to publish private modules for your organization within the terraform Cloud
1:24:18
private registry when creating a module you need to connect to a Version Control System of VCS and choose a repository so
1:24:25
here you can see we can be using something like GitHub gitlab betbucket or azure devops
1:24:32
and of course we're going to cover terraform Cloud a lot more further on in the course and it does definitely does
1:24:38
more than just act as a private registry but I figured this is the best place to put it against the terraform registry
1:24:45
okay [Music] let's take a look at how we would get a
1:24:51
list of the current providers you are using so all you'd have to do is type in terraform providers and you'd get a full list this command is useful if you have
1:24:59
a very complex architecture where you're using a lot of files and modules within terraform I
1:25:07
wanted to just show this command just because I saw it on the exam and so it's just an easy point if you happen to get
1:25:13
that question okay [Music]
1:25:18
so we know we can set multiple providers of in our terraform configuration file
1:25:23
but there are some variations here that you should know so one thing is is that if you need to have an alternate
1:25:29
provider you can use this thing called Alias so if you just notice here there's the Alias this is useful if let's say
1:25:35
you want to have resources within different regions of AWS is a very common use case when you want to
1:25:42
reference uh what resource should use with provider you're going to have that little provider attribute and then
1:25:48
you're just going to do what the name is of the provider followed by the Alias
1:25:54
you can also set an alias provider for a parent module so notice here in the
1:26:00
required providers we have this attribute here and we're using this configuration Alias and then if you need
1:26:07
to set an alias provider for a child module but more or less you just need to remember these two up here okay for
1:26:12
setting an alias [Music]
1:26:18
hey this is Andrew Brown from exam Pro and we're giving closer attention to modules so a terraform module is a group
1:26:24
of configuration files that provide common configuration functionality to enforce best practices reduce the amount
1:26:30
of code and reduce the time to develop scripts I definitely had a lot of confusion understanding the difference between a provider and a module
1:26:37
initially but the clear thing is that a provider is just an API mappings to the
1:26:43
service okay so on the example here on the left we have AWS as a provider and the example is to show you if you had to
1:26:50
create a VPC you'd have to specify many networking resources and just notice
1:26:55
that I have the three ellipses there to suggest there is a lot more that you'd have to configure but by using a module
1:27:01
and there's one called the AWS VPC module it basically has this short domain specific language
1:27:07
that allows you to quickly provision a VPC so the easy way to remember modules
1:27:13
is Imagine clicking a wizard that creates many Cloud resources like it able to have the VPC wizard that's
1:27:19
basically the idea behind modules just to kind of give a better contrast to the value that modules have we'll look at
1:27:25
the Azure provider so imagine you had to provision an Azure virtual machine this is how much code you'd have to write so
1:27:31
it's going to vary based on providers so AWS does not require this much work it's very short gcp requires a little bit
1:27:38
more work and for some reason Azure requires a lot so this is a case where you'd want to use a module so there's a
1:27:43
module called compute and network module and it reduces the code to amount of this still a bit long but that's just
1:27:49
what it is okay thank you [Music]
1:27:55
all right let's talk about the fine line and this is understanding the gray areas of responsibility between terraform
1:28:00
infrastructure as code and third-party configuration management tools like ansible so there are cases where when
1:28:08
you get outside of AWS as your gcp you might see providers like for postgres
1:28:14
database and you might say okay well what part of terraform should be automating it and so that's a little bit
1:28:21
more complicated question because terraform does more than one thing so terraform has providers modules and
1:28:27
provisioners and then on outside of that if we're not even using terraform we have third-party configuration management tools that we can use like
1:28:33
ansible and the thing is is that you could have ansible do everything but that does not mean that you should have
1:28:39
it do everything and with terraform at more or less most of these levels you can have them do everything but that
1:28:45
doesn't mean that they should right so the idea is to try to figure out what should be where and how to define that
1:28:51
so let's talk about creating a database so if we created a database that is like setting up a new service so that is
1:28:58
going to be under the providers and so you'd use the postgres terraform provider to set up a database now you
1:29:04
have users and so users are an entity they're not just like loose data so
1:29:10
there's something that you can add remove add permissions to and we would treat them as entities and so it
1:29:15
wouldn't necessarily be under the providers but that's a great place to put it under modules okay then you have
1:29:21
your data so where would the data go well data is not necessarily an entity it's just a bunch of data so I would say
1:29:29
that that is for provisioners that can run random scripts and then when we want to do things like backup tables to data
1:29:36
warehouses or truncate data daily tables things that are repetitive tasks that is
1:29:42
what we're going to use ansible for or a third-party configuration management tool outside of terraform you wouldn't
1:29:47
have terraform to that stuff at all so when you have a task done one time to set up the database like seating data
1:29:53
it's going to go to provisioners what you have repeatable tasks for ongoing maintenance it's going to be out as a
1:29:59
third party provider and if you have something that is like identified as an identity like as a resource that you
1:30:05
want to manage like Asset Management which are these things these are going to be over here in providers and modules
1:30:11
I do want to point out that a provisioner can be using ansible but we would still want to use ansible or
1:30:17
third-party configuration management tool isolate or separate to do these kind of things you do not want terraform
1:30:23
running these okay foreign
1:30:28
[Music]
Terraform Language
1:30:37
hey this is Andrew Brown from exam Pro and we are looking at Hashi Corp configuration files also known as
1:30:43
terraform files that which contain the configuration information about providers and resources this is
1:30:48
basically core to terraform and that's what we're doing so terraform files and in the extension of dot TF or TF Json
1:30:56
and we'll talk about the Json case a little bit later but terraform files are written in the terraform language and so
1:31:03
here is kind of an abstract way of looking at the language I know it's confusing here but don't worry we're going to reiterate on it to make more
1:31:09
sense but terraform language consists of only a few basic elements you have blocks and so these are containers for
1:31:16
other content and they represent an object so I'll have a block type which can have zero or more labels and a body
1:31:22
you have a block label it's a name of a block you have arguments which is which
1:31:27
is what you assign a value to a name so notice like we have assignments so we have identifier to an expression okay
1:31:33
they will appear within block so here it is within a block as you can see um Expressions represent a value either
1:31:40
literally or by referencing and combining other values they appear as values for arguments or within other
1:31:46
Expressions you might come across hashicorp configuration language so HCL and this is the low level language for
1:31:52
both the terraform language and alternative Json syntax I don't know if we'll be getting into it in this course
1:31:59
um or if there's even an easy way to distinguish it because it's basically terraform language but just if you see HCL just think terraform language it's
1:32:05
the easiest way to think about it okay [Music]
1:32:12
let's take a look here at the alternate Json syntax so terraform supports alternate syntax that is Json compatible
1:32:18
terraform expects Json syntax files to be named dot tf.json so we mentioned that earlier and so this is generally
1:32:24
what it would look like okay the syntax is useful when generating portions of a
1:32:29
configuration pragmatically since existing Json libraries can be used to prepare the generate configuration files
1:32:35
and that's pretty much it would you want to work on this it's up to you um but uh yeah so that's the reason for
1:32:42
this alternate syntax [Music]
1:32:47
all right let's take a look at terraform settings so the terraform configuration block type terraform curly braces you'll
1:32:54
see this within your configuration file is used to configure some behaviors of terraform itself so here is what it
1:33:01
looks like and what's very common is you're going to see those required providers so there are different things that we can put in here so we can put
1:33:07
the required version so this expects us to match to a particular version of terraform required providers this is the
1:33:14
providers that will be pulled during the terraform init we can also do experiments here so these are
1:33:19
experimental language features that the community can try and provide feedback on and then we have provider metadata so
1:33:25
this is module specific information for providers okay [Music]
1:33:33
hey this is Andrew Brown from exam Pro and we are taking a look at the hashicorp configuration language also
1:33:39
known as HCL I'm going to tell you I was really confused at the start working with terraform because sometimes they
1:33:45
mention things like hashicorp configuration files hashicorp configuration language terraform
1:33:50
language and I could not discern you know what the difference was but so this is the idea here is to give you that
1:33:56
Clarity okay so HCL is an open source toolkit for creating structured configuration languages that are both
1:34:02
human and machine friendly for use of command line tools and it's an open source project so you can find it at
1:34:08
github.com HCL so the idea is that they have this Baseline language that you can extend
1:34:15
for your own use case so uh terraform is using it and so it uses a good like it
1:34:22
uses the language itself but then it goes ahead and extends it by adding additional functionality for its
1:34:27
specific use case and this HCL based language is not just for terraform it's
1:34:33
used for hacker templates Vault policies boundary controllers and workers console
1:34:39
configuration Waypoint application configuration Nomad job specification
1:34:44
and this one isn't a hash Accord product but this is an open source project called Shipyard and you can use it for
1:34:50
Shipyard blueprints surprisingly Sentinel which is a Hachi Corp policy as
1:34:55
code server service does not use HCL but it has its own HC ACL custom language
1:35:03
but the idea is that you know we're looking at mostly the use case is for
1:35:09
hashicorp services but if you wanted to extend this language for your own use case you totally could and so I think
1:35:16
that's really cool but hopefully that kind of distinguishes between HCL and terraform language okay
1:35:21
[Music] hey this is Andrew Brown from exam Pro
Variables and Data
1:35:28
and we are taking a look at input variables so also known as terraform variables or just variables are
1:35:34
parameters for terraform modules that is the way we get data in to our configuration scripts is via input
1:35:41
variables so you can declare variables in either the root module or child modules and the way you define them is
1:35:48
via this variables block there at the top and just to kind of go over the
1:35:53
possible fields for that block we have the default option so the default option which is here is going to be the default
1:36:00
variable if you do not set it for type this is an argument that specifies the value types that are
1:36:06
accepted for the variable so this case up here we can see string and this one is a list
1:36:12
for description this specifies the input variables documentation we don't see an example there I believe that is optional
1:36:18
but it's always great to put a description in when you can there is a validation block so a block to Define
1:36:23
validation rules usually in addition addition to type constraints so we don't see that here on the right hand side but
1:36:30
the idea is that you know let's just make sure that there's less of a human error entering the wrong information you
1:36:35
can also have sensitive this limits terraform UI output when the variable is used in the configuration and we will
1:36:42
cover sensitive a lot more in this course outside of just this one slide okay [Music]
1:36:50
let's take a look here at variable definition files and these allow you to set the values for multiple variables at
1:36:56
once so variable definition files are named with the dot TF vars extension or
1:37:01
if you want to use the alternative syntax it's the tfbars.json file by default if you have
1:37:07
a file called terraform.tfrs within your project directory this will be automatically loaded so it's pretty common to make
1:37:14
that file to create a definition file it just uses the terraform language so you
1:37:20
would just assign values here you wouldn't make variable blocks but you just Define these um
1:37:27
identifiers and give them values okay [Music]
1:37:35
another way of loading input variables is via environment variables and this is very common uh way of loading them if
1:37:43
you have your own CI CD process for terraform so if you're using terraform cloud or you're using some kind of build
1:37:49
server that's going to be the primary way you're going to get variables into those build servers probably won't be
1:37:57
doing this much locally but the way it works is that terraform will watch for any environment variable starting with
1:38:02
TF underscore VAR underscore followed by the name this is very important to remember because it definitely will show
1:38:09
up on the exam so let's say we want to do set a variable for an image ID so we
1:38:15
do TF underscore VAR and then image ID probably most cases when you follow the
1:38:21
name it's going to be a lowercase underscore I don't think you'd probably want to uppercase that stuff and you just set the value okay
1:38:27
[Music] so there's a lot of ways for us to load
1:38:34
input variables we just saw two so we saw terraform tfrs and environment variables but there's a lot more caveats
1:38:41
to this so let's just run through them so we already covered uh terraform.tfrs the idea here is that if you create this
1:38:47
file and it's in your project it will automatically be loaded when running terraform apply you can name other TFR
1:38:53
files uh so I just called them use additional TFR files but they won't be loaded by default you'll have to use a
1:38:59
command line to load them this is useful if you have like a Dev and prod environment and you want to swap those
1:39:04
out now if you want to have files that auto load then you can just put the dot
1:39:10
Auto here and give it any name you want this would be useful if let's say you had a very large terraform tfrs file and
1:39:16
you wanted to break it up to make it more human readable you could do that then you have the hyphen VAR file flag
1:39:23
when you're doing terraform apply or or plan and this is actually how you load up these additional variable files if
1:39:30
you need to override a single value you you can use hyphen VAR so here I'm overriding the ec2 type to be T2 medium
1:39:36
and then lastly here we have environment variables we covered this this is where it starts with TF underscore VAR
1:39:42
underscore followed by the name and this is going to be very common when you are using Code build servers or runtimes to
1:39:49
run this in a CI CD automated way now there's a precedence to which these get loaded meaning that that certain
1:39:57
configurations of or input of variables will override other ones so as we go down this list these ones will override
1:40:03
the previous one so at the top you have environment variables if you have a terraform tfrs file that will override
1:40:08
the environment variables if you have the Json one that will override that one if you have auto files that will
1:40:14
override the default tfrs file and then on the last list you have hyphen VAR and
1:40:19
hyphen VAR file will override the rest so there you go in terms of the exam they're not going to ask you the
1:40:25
president's here but you're going to need to know what VAR VAR file are environment variables are in this default line okay
1:40:32
thank you foreign [Music] let's take a look here at output values
1:40:38
which are computed values after a terraform apply is performed output values allow you to obtain information
1:40:43
after resource provisioning such as a public IP address I'll put a file of values for chromatic integration
1:40:49
cross-reference Stacks via outputs in a state file via terraform remote State and so here's an example of an outputs
1:40:56
block so notice that there's a block and you specify some stuff there you can optionally provide a description it's
1:41:03
not necessary but generally with outputs I would recommend putting that in there you can also Mark it as sensitive so it
1:41:09
does not show in your terminal this is important if you're doing like logging stuff you don't want to compromise those
1:41:15
values there but understand that output values even though they might not be
1:41:21
outputted to your terminal or SD out they will be visible within the state file so if somebody opens up the state
1:41:27
file they're going to be plainly visible there so just understand that sensitive does not protect the values there okay
1:41:34
now in terms of how we would use the CLI with the output values if we type terraform output it's just going to
1:41:40
print out all the values that are within the state file I don't show this in the example here but if you wanted to use a
1:41:47
um a like bash command to parse Json you could extract them out and see they're
1:41:53
just plainly in the Json okay if you need to get exactly a particular field you type in terraform output and Then
1:42:00
followed by the name if you wanted an adjacent format all the output then you could give that flag I don't know if it
1:42:07
would work with this one I actually didn't test I just thought about that here for this one here if you want the
1:42:12
raw output of it meaning like if you output a string and you want it to be escaped or what have you then you could
1:42:18
use it pragmatically by passing it to something like curl to do something but the idea with all these output values is
1:42:23
that it's one way of inspecting but you could also use this in a configuration script or or something to do kind of
1:42:29
like an after action okay [Music]
1:42:36
all right so we're taking a look at local values also known as locals that assigns a name to an expression so you
1:42:41
can use it multiple times within a module without repeating it so here what we're going to do is Define our local
1:42:47
block up here and then the idea is that we're assigning these names or IDs
1:42:52
expressions or values so that we can reuse them throughout our code notice that we can Define multiple local blocks
1:42:59
in the same file and I just say this because like when you use required providers you're only allowed to have a
1:43:04
single block but this case like with variables or locals you can have many and you could even Nest them within each
1:43:10
other so notice down here we're referencing local within a local so that's totally possible and I imagine
1:43:16
it's in the order to which it is specified we can do static values or computed values so we can actually
1:43:22
here's a function write an expression and then it will output a value once a local value is declared you can
1:43:29
reference it via the dot as local dot the name so here notice within our it
1:43:35
was resource we have local and common tags I have to point this out but when you're referencing you use the singular
1:43:42
local because you might get an exam question which shows you local dot or locals Dot and the trick here is you got
1:43:49
to remember which one it is locals help can help dry up your code it is best
1:43:54
practice to use local sparingly since it's uh in terraform it's intended to be declarative and overuse of locals can
1:44:01
make it difficult to determine what the code is doing this call comes back to describing terraform as declarative plus
1:44:08
where they give you functionality that's imperative like but the idea is that you know if you overuse these you can run
1:44:14
into trouble okay [Music]
1:44:20
hey it's Andrew Brown from exam Pro and we are taking a look at data sources for
1:44:25
terraform so the idea here is you want information to find outside of terraform and it's defined by another separator
1:44:32
from configuration or Modified by functions so the idea here is we are going to Define ourselves a data block
1:44:39
and we have an external resource we're looking for so we're saying hey I want to see if I have an AWS Ami we're going
1:44:46
to use these filters as a way of of kind of selecting it within our AWS account
1:44:51
so we'd have a provider set up and so it'd be looking within that account to find it and it's even saying look for
1:44:57
the most recent Ami okay and once we have found that data source we can just
1:45:03
reference it so notice we're using data to reference it there so data AWS ami.web ID so there you go
1:45:11
[Music] we're taking a look here at name values
1:45:18
and these are built-in Expressions that reference uh various values you'll find your configuration scripts we do cover
1:45:23
these in their respected sections but I wanted to consolidate them here in one place just so that you get a second
1:45:30
chance to reinforce this information because Crux of questions of the exam could be based on knowing how the name
1:45:37
values work so let's go through them the first is resources I'm going to get up my pen tool here and so the way
1:45:42
resources work is that you start with the resource type so AWS instance and then you're going to do the name of it
1:45:48
so there's nothing that uh starts before the left hand side of it so just remember it just starts with
1:45:54
that resource type then you have input variables and that starts with VAR period so that's the singular VAR then
1:46:00
we have local values and again that's singular so local period for child modules it starts with module period
1:46:05
again singular for data sources it's going to be data singular just remember singular because they can have a matchup
1:46:12
on the on the exam questions whether it'll be like data or datas for file system and workspace info we have
1:46:18
path.module this is the path of module where the expression is placed we have path.root this is the path of the root
1:46:24
module of the configuration we have path CWD this is the path of the current working directory and in practice the
1:46:31
default CWD is the same as the roots so those would be technically the same we have terraform.workspace this is the
1:46:37
name of the currently selected workspace then we have block local values these are things that appear within a body of
1:46:43
a blocks so this could be within a resource provisioners things like that so we have if we're using the count meta
1:46:50
argument we're going to get count and with that we'll have count dot index so we can say okay this is the fourth
1:46:56
iteration of you know uh this this account Loop then we have for each and
1:47:02
this allows us to have the key and the value so we can access that during our iterations we have self uh so selfless
1:47:08
uh references information within provisioners or connections so it's just like a self-referencing thing name
1:47:14
values resemble the attribute notation of map or object values but are not objects and do not act as objects you
1:47:21
cannot use square brackets to access attributes of name values like an object so there you go [Music]
1:47:33
foreign [Music]
Meta Arguments
1:47:54
hey this is Andrew Brown from exam Pro and we are taking a look at resource meta arguments so the terraform language
1:47:59
defines several meta-arguments which can be used with any resource type to change the behavior of resources and so we'll
1:48:06
quickly go through the list here and then we will Deep dive on each so the first is depends on so this is for specifying explicit dependencies we have
1:48:12
count which is for creating multiple resource instances according to account we have four each which is used to
1:48:18
create multiple instances according to a map or set of strings provider so this is for selecting a non-default provider
1:48:24
configuration life cycle this is for life cycle customizations provisioner
1:48:30
this is and also for connections for taking extra actions after resource creation so there's the Quick List now
1:48:36
let's jump into them [Music] all right the First Resource meta
1:48:43
argument we want to look at here is called depends on and this is the order of which resources are provisioned and is important when resources depend on
1:48:49
others before they are provisioned terraform implicitly can determine the order of provision of resources but
1:48:55
there may be some cases where it cannot be determined or like the correct order so this is where you can be a bit more
1:49:01
explicit so here we have some terraform configuration where we have an AWS instance and it relies on a policy and
1:49:09
so what we're doing is we're setting an explicit depends on here so that it knows that it requires that now in a
1:49:15
normal use case you would not have to do this but it's hard to find use cases where this happens but when it does
1:49:21
become a problem you'll know because your resources will not provision correctly you'll get an error so there you go
1:49:26
[Music] let's take a look here at the count
1:49:32
resource meta argument and this is when you're managing a pool of objects so an example here would be a fleet of virtual
1:49:38
machines where you want to use count so here on the right hand side we have an
1:49:43
example of us using that in terraform so we can specify the amount of instances we want so here it is four and then
1:49:49
we'll have access to this name value called count dot index so the tags will
1:49:55
start at zero so it'll be server zero one two and three then just down below
1:50:01
here I just want to show you that with count you can accept a numeric expression so you know if you had a
1:50:07
variable that you had set as the subnet IDs or even just an arbitrary number like you want to have X amount of servers this would allow you to do that
1:50:15
okay but just so you know those numbers must be whole and a number must be known
1:50:20
before the configuration which you'd put in your input variables okay [Music]
1:50:29
all right so let's take a look here at four each which is for iterating over resource meta arguments but it's
1:50:34
slightly different because it allows you to map over Dynamic values giving you a little bit more flexibility so here's an
1:50:41
example of us defining A4 each and notice that we have defined a map sometimes I call it an object because
1:50:47
they're so similar but this is a map and the idea is that once you have your map
1:50:52
defined with your 4-H you will now have access to these name values so you can do each dot key or each dot value to
1:50:57
extract that out you can also just use it like with an array so here we have an array and then
1:51:04
we use two set to turn it into a set which it will accept as well and then we
1:51:10
can just pull out the key because there will be no value so just an example of with a map and then with something that
1:51:15
looks like an array okay [Music]
1:51:21
to understand the resource meta argument life cycle we need to understand how
1:51:27
resource Behavior works and so when you execute your execution order via terraform apply it will perform one of
1:51:33
the following to a resource so the most common one you'll see is a create so
1:51:38
these are resources that exist in the configuration but are not associated with a real infrastructure object in the
1:51:44
state the way you can tell it's creating it will have this nice little green plus sign the next one is destroy so
1:51:51
resources that exist in the state but no longer exist in the configuration and so that's going to tear down your resources
1:51:57
out of your Cloud providers this is represented by a minus symbol then you have update in place so the resources
1:52:04
who arguments have changed so the idea here is that if you have a virtual machine and let's say you change the
1:52:09
size of it it's not going to destroy it it's just going to modify its settings this is represented with a tilde and the
1:52:17
last one here is destroy and recreate so resources who arguments have change but
1:52:22
which cannot be updated in place due to remote API limitations so there are just some Cloud resources that always require
1:52:28
destroy and recreate and this is something very easy to trigger if you are using the replace command or the
1:52:36
older terraform tank command in order to replace a degraded or damaged instance
1:52:41
so let's talk about life cycle so lifecycle blocks allow you to change what happens to resources on the create
1:52:47
update and Destroy lifecycle blocks are nested within resources so here is a resource which is just an Azure Resource
1:52:54
Group and within it we have a life cycle block and we're setting our first option here that's possible called the create
1:53:00
before destroy so this is a Boolean and when replacing a resource first create the new resource before deleting it so
1:53:06
the default is destroyed old first so this is more about just the order of How It's destroyed prevent destroy so
1:53:12
ensures a resource is not destroyed then we have ignore changes and this is based off a list of attributes that you feed
1:53:18
to it so don't change the resource on create update to store right if a change occurs for the listed attributes so
1:53:24
maybe um maybe you uh you're just changing a tag and you say don't don't change uh
1:53:30
like don't tear down create or do anything strange if we change a tag okay so there you go that's uh life cycles
1:53:37
[Music] so we're looking at our last meta
1:53:43
argument here which are resource providers and this goes along with the idea of an alias so here we are defining
1:53:48
ourselves a provider in Google Cloud but there's a case where we might need to override the provider uh at a at a per
1:53:56
resource level and the way we do that is by creating an additional provider and setting an alias and then here we could
1:54:02
change something like the region and then once we have that set we can then reference our provider explicitly under
1:54:08
a resource and so that's all there is to it definitely on your exam you will see a question about Alias or you'll see
1:54:14
that example so definitely want to know how to do that okay [Music]
1:54:22
thank you [Music]
Expressions
1:54:41
all right so we're starting our introduction here into terraform Expressions because there's a lot we can
1:54:46
talk about here so expressions are used to refer to or Com or compute values within a configuration so terraform
1:54:53
Expressions is a large topic and we'll be covering types and values strings and templates reference to values operators
1:54:59
function calls conditional Expressions four Expressions Splat Dynamic blocks
1:55:06
type constraints actually I don't think we covered type constraints just because there's nothing really to say about it but we definitely cover version
1:55:12
constraints so yeah let's start off the section and go to it [Music]
1:55:19
so we're taking a look here at types and values for expressions and so the result of an expression is a value and all
1:55:25
values have types and so we have primitive types no type and complex structural collection types that last
1:55:31
one is a bit more complicated than what we are presenting here we're going to simplify it and then cover it later okay
1:55:37
so for primitive types we have strings so you have your double quotations which represent your string then you have
1:55:43
numbers so it's going to be integers or floats then you have booleans so this is either true or false for no types we
1:55:50
have null and so null is different in all different types of languages so it's very important to understand how it
1:55:56
works and so null represents absence or Omission when you want to use the underlying default of a provider's
1:56:02
resource configuration option so when you're saying null doesn't mean it's nothing it's going to be whatever the default is and the default also could be
1:56:09
nothing it's just depending on what that is on the provider so for collection or for a collection types complex
1:56:15
structural types we have list or Tuple and this generally looks like an array the then you have map and object and
1:56:21
this looks like basically like a Json object or a ruby hash or I think they
1:56:26
call it in Python a dictionary so that gives you an idea of the basic types but for this last one here because this I
1:56:33
found really confusing list tuples map object we definitely explain this more in the course okay [Music]
1:56:42
okay so we're giving a little bit more attention to the string type because there's a little bit more going on here so when quoting strings you got to use
1:56:49
double quotes uh at one point terraform I believe supported single quotes I think it only Sports double quotes now
1:56:54
and honestly you generally want to just use double quotes because double quotes always support Escape sequences this is
1:57:00
pretty much standard across all programming languages but the idea here is you can do things like new line
1:57:05
carriage return tab literal quotes literal backslashes Unicode characters
1:57:10
both basic multilingual plane and supplementary planes there are some special Escape sequences this makes
1:57:17
sense when we look at the next slide for string templates but there's these things where you can do interpolation
1:57:22
and so you might not want to actually do them you might want to do it without and
1:57:28
so if you just use double of the symbol that will allow you to do it then there is also the ability to have multi-line
1:57:34
strings and we use hear DOC for that and so here Doc is a little bit different in all languages but here we're using Unix
1:57:40
style so that means that we're going to start with these two two angled brackets to the left our opening angle brackets
1:57:46
followed by some word that is all in uppercase it doesn't have to be eot it could be whatever you want I always like
1:57:53
to type here Doc and then it has to end at the same indentation level with the same word all uppercase and then
1:57:59
everything in between will be treated as um as multi-line the nice thing about this
1:58:05
is that when you have this you can actually just use double quotes wherever you want because you don't have to escape them okay let's take a look at
1:58:11
string templates because this is the real power of strings so the first is string interpolation and this allows you
1:58:17
to evaluate an expression between the markers so the idea is instead of having to do double quotations and do plus
1:58:23
signs to stitch together uh strings what you do is just do a dollar sign uh curly
1:58:29
braces and then put the the expression or variable that you want uh to be converted okay then you have string
1:58:36
directives and these are slightly different this allows you to evaluate an expression for a conditional logic
1:58:42
between the markers so let's say we want to have an if else statement so if the name is blank
1:58:48
then use VAR name or sorry if it's not blank then use the name provided
1:58:54
otherwise put it as unnamed okay you can also use interpolation directives with
1:59:00
hear docs so you know just to show that you can do it and then the last one
1:59:05
thing here is you can strip out white space that would normally be left by directors blocks by providing a trailing
1:59:12
tilde so just notice this little tilde here on the end because these do take up space so if you were to view it there'd
1:59:18
just be an empty space there if you want that space to vanish then you just put that tilde on the end so there you go
1:59:24
foreign let's take a look here at the possible
1:59:29
operators that we can use within terraform expressions and so just a refresher operators are mathematical
1:59:34
operations you can perform two numbers within Expressions I'm not going to show full examples here and the outputs of
1:59:41
them because this is pretty common for programming or scripting languages and also the exam is not really going to focus on the use cases for these so it's
1:59:49
just more so to tell you what is available too so you know what you can use the first is multiplication so you
1:59:55
take two numbers and times them to get a larger number division so it uses a forward slash modulus and if you've
2:00:02
never used modulus I really like this it allows you to see if something is divisible by a certain amount and then you get the remainder you have addition
2:00:09
subtraction if you need to flip to a negative number you can just put a minus sign in front of it if you need to do
2:00:16
equals its doubles if you want to do does not equal its exclamation equals
2:00:21
then we have a less than so that's a open angled bracket less than or equal
2:00:27
so that will be followed by an equal sign greater than is a closing angle bracket and Then followed by an equal
2:00:33
sign for greater than or equal you have or which uses the double pipes you have n which uses the double ampersands if
2:00:40
you need to flip a Boolean you can just put an exclamation in front of it so if it was true now it is false if it was
2:00:45
false now is true I'm not sure what it would do for an all I would think that it would turn it to true but uh yeah so
2:00:52
there you go foreign
2:00:58
we're taking a look here at conditional expressions and this is pretty much the only way that you can do if-el statements within terraform but it works
2:01:05
out fine and so it's actually using the ternary style of ill if else so what that looks like it's a single line so
2:01:11
the it starts with a question mark so that's the if and then it's the True Value and then the colon represents the
2:01:17
else and then you have your false value it's ternary because there's three things one two and three okay so that's
2:01:23
the way I remember this thing it's not a a preferred way of doing Ethel
2:01:28
statements in other languages because it is a little bit condensed but it makes sense when you're using scripting
2:01:34
language and you're really restricted on per line actions so this is what it would look like in action so we'd have a
2:01:40
variable that is a if a does not equal a blank then use the variable or set it to
2:01:47
default a as a string so that's kind of an example there I'll just wipe that away there the
2:01:52
return type of it of of the if and else must be the same type so if you have a
2:01:58
number okay and the one if statement and then you have a string they have to be
2:02:03
the same so uh obviously we want a string to be returned in both cases so what we'll do is use this built-in
2:02:10
function to string to turn this into a string so that we're not going to run into any problems so there you go
2:02:16
[Music] all right we're taking a look here at
2:02:22
four expressions and so these allow you to iterate over a complex type and apply Transformations a four expression can
2:02:28
accept as input list set Tuple map or an object I want to distinguish this between four each which is a resource
2:02:35
meta argument which allows you to iterate over a a resource or a collection of resources that are similar
2:02:42
but four expressions are for these primitive types or not these primitive types but these collection structural
2:02:48
types that we talked about in types and values okay so here's an example of something we might want to do imagine we
2:02:54
have a list of names and we want to iterate through our list and make them all uppercase so we could do that with
2:03:00
this four so we have the four with the n and then we're providing the value of each item in our list it's easy to think
2:03:06
of list or Tuple as an array so I'll just call it an array okay then you have a map and so this is where
2:03:13
it has a key and value this is going to be for maps or objects and the idea is that we can then go apply Transformations and notice that we are
2:03:20
returning only a single string so we're actually going to get back something like a tuple and so how does it decide
2:03:25
whether it returns a um a array or something that looks like an object we'll explain that here in a moment the
2:03:32
last one here is we have a list with an index so it's very similar to the first one but in this case we want to know the
2:03:38
index here so imagine this says zero is Andrew one is Cindy two is Peter and it
2:03:46
would come back as an array or list so let's talk about the return types the return types are defined by the um uh
2:03:52
the braces or brackets that are around the actual expression so if you have square braces we're going to go back to
2:03:57
Tuple so it's just think that array so for in this case where we had our list it was returning back a tuple okay
2:04:06
if we have curly braces it's going to return an object so here we have a list so it's like an array that's coming in
2:04:12
here and then we were specifying as the return uh this kind of object structure and so that's how we're going to get
2:04:18
that so that's that there's one other thing we want to mention which has to do with
2:04:23
um reducing or ordering so an if statement can be used to reduce the amount of elements returned so in this
2:04:30
case what we're doing is we're using an if statement and so we're saying unless this is true so if this is true then return if it's
2:04:37
not then return less of what is there so if there's any blank names that are in
2:04:43
our list they just won't show up it'll just only show names that are actually there um then we have implicit element
2:04:49
ordering so since terraform can convert an unordered type so map objects and sets to an order type list or tuples it
2:04:56
will need to choose an implied ordering so for maps and objects they're stored by key A to Z set of strings stored by a
2:05:04
strings A to Z everything else is going to be arbitrary ordering so there you go [Music]
2:05:12
all right we're taking a look here at spy expressions and these provide a shorter expression for the four expression which we just looked at so
2:05:19
what is the Splat operator a Splat operator is represented by an asterisk it originates from the Ruby language and
2:05:24
Splats in terraform are used to roll up or soak up a bunch of iterations in a for expression so here is an example
2:05:32
where it's for list sets or tuples so here we have a list and the idea is that we're iterating over this ID or in this
2:05:40
game we're iterating over um its objects or sorry a array and then
2:05:46
that array is containing a bunch of objects and so we're accessing the name within it and so instead of writing it
2:05:51
like that we don't even have to use it for at all what we can do is put this asterisk here and this is going to equate to the same thing so here this is
2:05:58
going to return all the IDS and in this case it's going to return a all the lists and allow us to access the
2:06:04
interfaces along to the name okay so let's take a look at spy Expressions
2:06:10
uh when we're applying them to lists so if the value is anything other than a null value then the Splat expression
2:06:16
will transform it into a single element list if the value is null then the expression uh the then the Splat
2:06:22
expression will return an empty Tuple and so this behavior is useful for modules that accept optional input
2:06:27
variables whose default value is null to represent the absence of any value to adapt the variable value to work with
2:06:33
other terraform language features that are designed to work with collections so I know that's a big mouthful it's just
2:06:39
kind of like an edge case to these Spa Expressions this is not going to show up in the exam but I just wanted to show it
2:06:44
to you in case you're interested here and just notice the spots being used over here okay
2:06:49
foreign [Music] so we're taking a look here at Dynamic
2:06:56
blocks and this allows you to dynamically construct repeatable nested blocks so I want to emphasize that this is a very powerful feature that can lead
2:07:03
to abuse where your code becomes uh difficult to read but it's also very flexible it will absolutely show up in
2:07:08
the exam so pay close attention on how this works so let's say you needed to create a bunch of Ingress rules for your
2:07:14
ec2 security group and so this would lead to a lot of repeatable elements for rules within your resource and so what
2:07:22
you can do with Dynamic blocks is you can Define objects locally so here I have my Ingress rules as an object so
2:07:28
here's one and here is two and then using Dynamic block what I can do is use
2:07:34
a 4-H to reference those Ingress rules and within this Dynamic Ingress block
2:07:39
we'll have our content and this will specify the things that we're swapping out so the idea is that it will iterate
2:07:45
over this and apply all those values there so it's something you can't do with a 4-H or account this is basically
2:07:51
the the most advanced iteration but just understand if you remember this use case and it's very easy to understand or
2:07:58
remember how to use it when you're doing an exam okay [Music]
2:08:05
we're looking at version constraints so terraform utilizes semantic version for specifying terraform providers and
2:08:12
module versions so semantic versioning is an open standard on how to define versioning for software management so
2:08:18
you have your major minor and your patch and so here are examples or variants on
2:08:23
this here so we have um you know where you see major minor then you can have this RC this rc1 or
2:08:30
you could not have it or you can have beta and this can all be read about on the samver.org but just to quickly go
2:08:36
through it major version is when you want to make incompatible API changes minor is when
2:08:42
you add functionality that is backwards compatible in matter patch is when you make backwards
2:08:48
compatible bug fixes there are additional labels for pre-release build metadata that are available as
2:08:53
extensions so that's where we see those little additions there at the top a
2:08:59
version straight is a string containing one or more conditions separated by commas so you have your equals or no
2:09:06
operators or sorry your equals or no operators so match exact version of the
2:09:12
number so it's either with the equals or not with the operator at all okay that's what I'm trying to write there excludes
2:09:18
an exact number uh version so if we just said does not or will not be uh 1.0.0
2:09:26
then you have a comparative ones so they have the version has to be greater or equal to 1.0.0
2:09:33
um and then we have one with the tilde so allows only the rightmost version of the last number to increment so what
2:09:39
this means is that the the last number here is only allowed to increment okay
2:09:45
so let's talk about Progressive versioning because this kind of ties into semantic uh versioning but Progressive version is the practice of
2:09:51
using the latest version to keep a proactive stance of security modernity and development agility and we like to
2:09:59
describe this as practicing good hygiene when we're uh working with our code okay so by being up to date you're always
2:10:05
pushing left on things that need to stay fixed or compatible you'll have to deal
2:10:11
with smaller problems instead of dealing with a big problem later on run nightly builds is a good example where you might
2:10:17
have golden images and the idea is to provide a warning signal just to kind of elaborate on that a nightly build is an
2:10:23
automated workflow that occurs at night when developers are asleep so if the build breaks because A change is
2:10:29
required for the code the developers will see this upon arrival in the morning and be able to budget accordingly so what I'm trying to get at
2:10:35
is that when you are like putting in your providers especially if
2:10:40
you copy from the terraform um the terraform website to get the providers and modules what they'll do is
2:10:47
they'll actually have it set as the I'm just going to roll back here for a second but they'll actually have it set as the equals what I'm saying to you is
2:10:53
you want to use something like a tilde or a greater than or equal sign so that you are staying Progressive okay so
2:11:00
that's just one thing I want you to watch out for and we will talk about that when we go through the follow alongs okay [Music]
2:11:09
hey it's Andrew Brown from exam Pro and we are moving on to our expression section starting with string templates
2:11:14
let's learn all about that and we are going to have to CD into a new folder here so I have one called expressions and we
2:11:21
will make ourselves a new file called main.tf we'll Define a local back end
2:11:28
and I'm going to just Define a new variable I'm going to call this variable hello
2:11:34
and I'm going to give it a type of string okay and that's all I'm going to do
2:11:41
there and then what we're going to do is create ourselves a TF VAR file so we'll say
2:11:46
terraform Dot tfvars and in there we'll just set hello
2:11:51
to world and so what I want to do is enter terraform console okay this is going to allow us to just
2:11:58
run arbitrary Expressions I want to show you how you quit it you just type exit and so we'll do is make a string so
2:12:03
we'll just first do a Hello World I want to show you that you can put a uh a new line there and we'll get back a
2:12:10
multi-line document this is a um this console doesn't allow for multiple lines so we can't write our own
2:12:15
here doc but I can show you what it looks like and then we can interpolate a uh a
2:12:20
variable there so we'll just say hello and notice we get hello world so that's
2:12:26
how interpolation works it's not super complicated directives is a little bit
2:12:31
different where we have string right so we can do instead this
2:12:37
but the control word is a bit different because you're using the uh this um
2:12:43
percentage sign the directives when you're doing something like an if else statement so what we could do
2:12:49
is say something like um barsoon here
2:12:56
okay and what I'm going to do is just exit out here clear because I don't know if
2:13:04
it um it reloads the uh the variables there if you just change them on the Fly but what we'll do is we'll just say
2:13:10
hello and we will write ourselves an if statement so we're going to say if VAR
2:13:16
dot hello equals bar soon
2:13:23
what it's going to do is then print out um it's going to instead print out Mars
2:13:30
okay otherwise
2:13:36
what we're going to get is um
2:13:41
world okay you know what's really interesting is we're using the if and else
2:13:47
here but I I could have swore that the only thing you had was ternary operators so
2:13:53
like if you look at the conditional expressions notice here that it's doing this and
2:13:59
it's not showing the documentation the FL so you know maybe maybe that's just
2:14:04
for a one-liner and if else does exist for expressions and I might have missed that in the course but you cannot blame
2:14:10
me if the documentation shows it like that okay so what I'm going to do here is just go
2:14:16
ahead and hit enter and here we get hello Mars so that pretty much uh shows you how string interpolation
2:14:24
works for both interpolation and directives we'll just type in exit and so that's all we want to do there okay
2:14:31
[Music] all right so let's learn about four
2:14:37
Expressions so four Expressions allow us to kind of iterate over something and do something fun with it and so what we're
2:14:43
going to do is create ourselves some more complex types here so how about
2:14:49
instead of like this was just hello a second ago but we'll change this over to Worlds and what I'm going to do is just
2:14:54
list out a bunch of Worlds here from the uh the book uh John Carter books so we
2:14:59
have bar soon we have jasum
2:15:05
we have things like sesum okay and then we have whoops
2:15:13
so assume and then we have something like cosume okay
2:15:18
and so the idea here is now that we've defined that there we've got to go back to our main TF I'm just going to update
2:15:24
this to the worlds this will just be a list all right and so what we'll do is make
2:15:32
our way over to terraform cloud or sorry terraform console and we will try to do a four Loop here
2:15:38
so I'm going to do Square braces four and we'll just say w in VAR dot worlds
2:15:46
and then what we can do here is make a colon whoops
2:15:54
okay and then type upper W and so that returns them all in
2:16:00
uppercase there and if we were to use the Splat operator and technically this is something we
2:16:06
want to move on to the next part but um yeah we'll leave it for the next
2:16:11
video I'll just keep that separate so that is for just if we had a list imagine if we had this as the as an
2:16:18
index here um or we'll say map
2:16:26
because what we can do is actually map these two names
2:16:31
so bring this down here and this would be Earth
2:16:38
now you can use the colon or the equals it's just whatever you want to use here they're both supported actually this is
2:16:44
an Earth this is Mars and then this one here is Earth and this one here would be
2:16:52
Jupiter and then this one here would be Venus
2:16:59
okay um and so I think we still need to Define it over here
2:17:05
so I'm just going to say world's map and then what we can do here instead of
2:17:10
having list we can say map and we'll try to iterate over this so
2:17:16
it's going to be very similar except the difference is now we have a key and we have a value
2:17:23
and so if we just want to return the names in capital we can just do K here
2:17:30
oh that's the index uh what if we do oh you know why it's because
2:17:36
um we have to do Worlds Map okay so reference to Undeclared variable map
2:17:43
so we do have to exit and restart
2:17:50
and oh sorry the input was complaining there so I'll just copy the one up here so I have to type it again
2:17:57
nope it did not work as we thought okay so I do have to type it by hand kind of a pain but I guess that's just
2:18:03
how it works so we'll say 4K V invar Dot worlds
2:18:08
map and then we say upper B here okay or we could just say take the K
2:18:15
here and get the other values now I didn't show you this a moment ago but if we do worlds here we can specify an
2:18:22
index and an index would come first so it would be the value like the world the
2:18:27
second and the index is first so notice that I is all a number the index of it
2:18:33
and then the that is the value there um we could probably also return this as a
2:18:39
map so notice that square braces are going to give you a list or and then curlers are going to give you map which
2:18:45
kind of correspond to their actual data structure so if we wanted to turn this into the opposite here what we could do
2:18:52
is just say uh we probably do string interpolation like this here and do I
2:18:58
and then do equals or even maybe a colon here and then do the world like that
2:19:05
and it didn't like the way I specified it so I'll try it like this instead
2:19:10
extra characters after the line four
2:19:15
so I don't see that wrong there just give me a moment I think um
2:19:23
oh you know what it's we need to use in this case I think we have to do it this way
2:19:28
okay so we use use the hash rocket so in that particular case you have to use the hash rocket that's what that symbol is
2:19:33
called the equal zero um and so that's how we can get that value there so that pretty much outlines
2:19:40
how to use um the for loops and next we're going to go probably look at the Splats okay so
2:19:46
I'll see you back here in a moment I'm just going to exit this actually before we move on to Splats I just want to add
2:19:52
one more thing to four Expressions which is filtering so we'll just go back here and get back into
2:19:58
our terraform console here and what I'm going to do is just write another four
2:20:04
and it probably would make sense to use the uh the the world's list we just did there so I'm going to do KV type in VAR
2:20:12
world's map and so the idea here is that I only want
2:20:17
the let's say we'll say the upper I only want the
2:20:22
key value here but I would just say at the end here I can say if the V the
2:20:29
value equals I can't remember what we set these as so this is key in value so if it is Mars
2:20:38
I think it's double equals so if it is Mars then only return it that way or we could
2:20:45
say the opposite say give me everything but Mars okay so I just wanted to show you you could use
2:20:51
that if to do that filtering so I'm going to exit there and we'll move on to spots okay
2:20:56
[Music] all right so we're moving on to Splats
2:21:02
and what we'll have to do is create ourselves a new variable here I'm going to call this one world's
2:21:09
Splat and this one is going to be a list and so if we go back up here to tfvars
2:21:15
we'll make ourselves a new variable down here and we'll just call this one splat and it's going to be a list but it's
2:21:22
going to contain inside of it a bunch of maps okay so we'll do pretty much this up
2:21:27
here okay but what's going to happen here it's going to be slightly different
2:21:33
where we are going to set what is the name
2:21:44
so we'll just say like um Earth name
2:21:49
that's actually Mars name so it's a Mars name here for all these
2:22:01
and then over here these are going to be
2:22:07
the Earth name
2:22:24
so I think that is valid and what we're going to do here is just type in terraform console
2:22:31
and if we wrote that correctly oh no we got an error so it says expected an equal sign to Mark the beginning of a
2:22:36
new attribute value so I mean this should be okay
2:22:45
uh oh you know what I think this Colon's just missing here put it up again
2:22:52
there we go we're fine so if we just want to look at that variable I think we just type it in here and it might print it out if we're lucky
2:22:58
yes so there it is um so what we're going to do here is use
2:23:04
a Splat to get maybe the Mars name or something so if we used a for Loop what we'd have to probably write we could try
2:23:09
this but we'd have to do four and then it would be for the actual map so say m for
2:23:16
map in world's splat and then we would have to do m
2:23:23
Dot Mars name and so a reference to the attribute
2:23:31
by one axis treatment specifying the resource name so I mean that looks oh you know it's
2:23:37
because we didn't write VAR okay I say we but it was really me so you
2:23:42
know that's that but we could write this in a more concise way
2:23:49
okay and so we use a splat Mars name okay so you know that's a lot more
2:23:56
convenient if we're just trying to access variables like that um I think that if you're trying to do things like
2:24:04
if you want to do upper here I think you still have to use A4
2:24:10
expression okay I don't think you can do this we can try it but I really don't think that
2:24:16
will work
2:24:24
no and if we look at the documentation they don't show an example like that so you know it's not that bad but you can
2:24:31
see that it's for a particular use case you can't use that for uh Maps or whatever the equivalent the other map is
2:24:37
object but it's useful for this one particular use case okay
2:24:43
[Music] hey it's Andrew Brown from exam Pro and
2:24:49
we are on to the dynamic blocks follow along so this one should be uh pretty fun because it's uh quite a powerful
2:24:54
feature so what I've done is I've created a new folder here called Dynamic blocks I'm going to make a new file here
2:25:00
as always it's going to be main.tf and a really good example for this would probably be a database Security Group
2:25:07
just because there's all those Ingress and out outgress or egress rules so what
2:25:13
we're going to do is just Define our terraform settings block and I'm just going to pull up over here and make our
2:25:19
way over to the registry for terraform and what we're going to do is go over to the AWS provider and go to the
2:25:26
documentation and actually I first want to grab the provider itself because that is something very easy that we can do
2:25:32
here we'll just move that on over so we can see what we're doing and paste that on in and we're going to have to Define
2:25:39
our provider of course so we'll name that as AWS the profile is going to be
2:25:45
defaults and our region will be us East one
2:25:50
okay and so now what we need is to co-create ourselves a security group
2:25:56
so we have of course done that previously here but let's pull up the uh documentation here
2:26:02
I believe it was actually under VPC so let's just go down to VPC here and we will expand that and then underneath
2:26:08
here there should be a AWS Security Group uh there it is and if we scroll on down
2:26:14
there's the thing okay so what I'm going to do is copy uh this code here and go
2:26:20
over and we'll just paste that on in and there is our security group so I
2:26:26
remember that we had to have the description if you remember it complained about that
2:26:31
so outgoing for everyone and we need to also have a few
2:26:39
additional things we will just scroll on down here because it wanted the prefix list IDs
2:26:47
okay remember we needed that I think there
2:26:53
was like self false and there was like security groups
2:26:59
I think it was actually AWS security groups in particular let's just double check to make sure that is the case
2:27:04
it is called uh oh it's just security groups okay
2:27:15
so we'll say self equals false
2:27:21
we do not need cider block four here or six
2:27:27
um we do not need this one here and it doesn't really matter what we set this to so it could be set to the main side
2:27:33
or block that's totally fine but we are going to need to add a data source just like last time for the VPC
2:27:42
so we'll say VPC we'll call that Main and I think it just needed the VPC ID it
2:27:47
was as simple as that and so we will go over to AWS over to
2:27:54
VPC
2:28:00
and from there we are going to go to rvbcs and I will go grab that VPC ID
2:28:12
Okay so we've grabbed our VPC ID and then we just need to name this as data
2:28:18
and then we're going to name this as data we don't really care what the cider block is it's just again for
2:28:23
um this demo purposes we don't need tags we'll take those out and
2:28:29
um yeah everything else is fine okay so this now comes to the fact that we want
2:28:36
to use Dynamic blocks before we do that let's just well I think I didn't leave the console there last but what we'll do
2:28:43
here is just to our terraform inits and as that is pulling that stuff we're
2:28:51
going to look up Dynamic blocks uh terraform
2:28:59
so we'll go here and so Dynamic blocks is like way more powerful than um the four each where what we can do I'm just
2:29:06
trying to find that example there but we have uh we have to set the dynamic part the
2:29:14
4-H you know what I'm pretty sure I have these in my slides so let's just use my slides as the reference here
2:29:22
dynamic ah here it is okay so the idea is that we'll just set up a locals with all of
2:29:27
our information here and then we will create this Dynamic block and then provide the content okay so I'm just
2:29:33
going to move that off screen so I can see what I am doing here as we type it in and we'll see if we run into any
2:29:39
problems um failed to query the available product for packages could not retrieve the list
2:29:44
of the available versions for the provider uh not have a provider registry
2:29:49
terraform name all models should specify the required providers so I'm not sure why it's complaining here but we'll
2:29:55
scroll all the way to the top and the required providers is correctly set here
2:30:01
so it shouldn't be a problem not sure what it doesn't like
2:30:12
um so let's just type in terraform providers here
2:30:18
the VPC um is VPC a module you know what it's probably because I
2:30:24
didn't do AWS VPC that's probably my problem here terraforming net
2:30:30
and as that's thinking there we'll just pull this on down and we'll start to make our locals block okay so we can go
2:30:37
here make some locals and we'll do our Ingress
2:30:42
and we'll just go like that and the idea is we can say Port whoops
2:30:50
we can set the port like that 443 we have to always have a description so
2:30:56
we'll just set that as well so port 443 we can set
2:31:03
as much as we want here so I'll just go ahead enter
2:31:08
okay and
2:31:13
I think that looks right yeah so we have
2:31:18
one Ingress here and then we'll just copy this and make a comma
2:31:25
vs code is not really formatting the way I wanted to and so we'll do port 80.
2:31:31
and then down below we will need to specify hour
2:31:38
um for each okay so that's going to be within our Dynamic block so what we're
2:31:43
going to do is tab in here I'm going to say dynamic and we'll type it Ingress because that's
2:31:51
a match for what we're doing um and then from there we can do our
2:31:57
four each equals local Ingress and then we need to specify our content
2:32:03
I don't really understand why it's called content and things like that but I just know that that's what we have to
2:32:08
do and it's not really that big of a deal so we'll go here and paste that in we can
2:32:15
take out our Ingress block there we know we're going to need self these all here but what's going to change
2:32:22
are these ports so we will go here it will say Ingress
2:32:28
Value Port and this will also be Ingress Value Port and then this will be Ingress value
2:32:35
description if we really wanted to we could also set the protocol
2:32:42
protocol Pro Tove call and this could be then TCP
2:32:57
and so we would just say Ingress value protocol
2:33:05
so it just saves us from repeating these over and over again if they're all the same there's a lot you can do with Dynamic
2:33:11
blocks but honestly you shouldn't do anything too crazy we'll do our terraform plan and see if
2:33:17
this works whoops
2:33:23
bring that up there um an argument VPC ID as not expected here okay so
2:33:30
that was me just guessing from memory and I guess I guessed wrong
2:33:35
uh so what we'll do is we'll just look that up
2:33:42
AWS VPC data source terraform
2:33:50
oh it's just ID okay so what we'll do is just set ID here
2:33:58
and then we'll just hit plan again and that should resolve our issue there
2:34:05
uh inappropriate value for a tribute egress security groups is required okay
2:34:11
that's fine
2:34:17
well this one says doesn't say uh Syria groups
2:34:22
and this one doesn't say Security Group so that's probably our problem here so we'll just hit terraform plan again
2:34:32
and here it says this VPC ID does not exist probably what happened is they might be in the wrong region
2:34:39
it's very common problem on AWS just because of the way their UI works
2:34:45
if I can get this window over here and so this is because we're in USC's we're
2:34:50
supposed to be in U.S east one here
2:35:00
and I'm going to go up to here we'll save that
2:35:06
let me hit terraform plan
2:35:17
and we could probably like use the filter and also just say choose the default but it's just so easy to put that in like that so
2:35:26
doesn't seem like we have any problems here so let's go ahead and execute let's just double check to make sure these values are correct
2:35:32
so for the Ingress um Port 443 Port 443 it's probably just
2:35:38
because I didn't update the description probably because of a copy paste job yep
2:35:44
okay and let's just make sure this works so we'll say terraform apply Auto approve
2:36:01
and we'll give it a moment and it's already created so it's that fast we can go here and take a look at
2:36:08
it if we like it's not that big of a deal
2:36:13
um so we should see it in here I just have so many uh junk security groups here this is a
2:36:20
bit hard to find oh allow TLS is what we called it so here it is
2:36:25
go to our inbound rules 80443 and that's pretty much it so
2:36:32
terraform apply destroy Auto approve
2:36:39
okay
2:36:46
there we go [Music]
2:36:53
all right so I want to talk about versioning very quickly here and so I have a new folder called versions I'm going to just make a new file called
2:36:59
main.tf and we're going to create a terraform block but what we're also going to do is set required
2:37:07
uh providers or sorry required uh we're not providers required version and so
2:37:13
what this is going to do is say explicitly what version of terraform we want to use and I'm sending it this as
2:37:18
1.0.0 and I'm using this tilde Arrow if you're wondering you know what is the logic behind all those things I think
2:37:24
it's all explained in the semantic or semver.org so if you want to learn more I strongly recommend you read through
2:37:30
this to understand all the stuff inside and out highly applicable across the devosphere not just to terraform
2:37:37
um but you know if we go over to terraform GitHub repository and we drop down the branches and go to tags here we
2:37:43
can see all the versioning we are using version 1.0.0 and it all goes up to
2:37:49
1.1.0 Alpha which is not out yet and if you wanted to really know what's going on here you go to releases and you can
2:37:55
read what they have done so here 1.0.7 remove check for computer attribute prevent object types with optional
2:38:02
attributes for ETC empty containers so when you're looking at the patch the
2:38:07
patch which is the third number the the rightmost number that's going to keep you up to date in terms of security for
2:38:13
the the major minor version that you have for the 1.0 and you absolutely always want to be using the latest and
2:38:19
so that's what this tilde does it says take the far Road uh the the farthest
2:38:25
number to the right and make sure that it's the latest version that has been published um and you know this comes back to my
2:38:31
Progressive versioning slide which is if you want to have really good hygiene in terms of your devops we should be doing
2:38:37
is at least setting the tilde for sure like this the tilde Arrow or I would even go as far as saying equals arrow
2:38:44
and if you're really concerned about um you know not using the next major version you could say you will less than
2:38:50
you know like less than um less than you know one point
2:38:57
2.0 even if it's not out that's a good indicator to say okay well I don't want to go too far ahead of time but if you
2:39:03
want to have Progressive versioning you should really be setting it like this okay and this is going to be applicable for
2:39:10
your image providers anything else so you know if we go over to
2:39:16
if we go over to the registry and we choose
2:39:23
whoops AWS and we drop this down here we have
2:39:28
that required version as well so as you copy it in you're going to notice that it's actually hard coded but I would strongly recommend again
2:39:35
if we go here and take this and at least at least do
2:39:41
this and if you're really really being clever you could do that okay and these are
2:39:48
also all in GitHub repositories as that's how everything works so you can go here and click and you can go over to
2:39:55
the tags and see the versioning and you can go over to the releases and it's the
2:40:00
same thing you can read about all the things that have changed okay and that's something that you should uh you know
2:40:05
consider doing all right so that's all there really is to this I might want to show you one more thing and this one is
2:40:11
with terraform Cloud so I'm going to go to terraform IO and we're going to open up our terraform cloud and I'm going to
2:40:17
sign in I probably haven't signed in a while so probably ask oh nope no username password that's great what we can do is in a workspace we go to
2:40:22
settings and is it Version Control no it is general and under here we can actually
2:40:29
set the terraform version so if you happen to be working with a particular version you can go and say okay only use
2:40:35
this version for terraform cloud and that will um that will not upgrade it'll just keep
2:40:41
you there if you need for legacy reasons but again you know what you really should be doing is using that
2:40:47
Progressive versioning doing nightly builds and discovering overnight that things are breaking so you can go fix
2:40:54
those in the morning okay and that's it [Music]
Terraform State
2:41:01
hey this is Andrew Brown from exam Pro and we are taking a look at terraform state so what is State well it's a
2:41:07
particular condition of cloud resources at a specific time so give an example imagine we expect to have a virtual
2:41:14
machine running Centos on AWS with a compute type of T2 micro that would be the state that we are expecting okay so
2:41:21
how does terraform preserve State well when you provision infrastructure via terraform it will create a state file
2:41:27
named terraform TF State it's very important to remember that name because it literally is an exam question the
2:41:33
exact naming of that okay this state file is a Json data structure with a one-to-one mapping from resource
2:41:39
instances to resource or to remote objects and if you're wondering what is a remote object versus a resource
2:41:46
instance I cannot tell you I would imagine one is the representation of things that are deployed in the cloud
2:41:52
and the other one are objects or or things represented in the state file but
2:41:57
they don't clarify it so I just have to take a guess so this is kind of what the Json structure looks like like you can see you see resources this is describing
2:42:04
like a type of instance and stuff like that there's not really any case for you to ever go through the terraform State
2:42:10
file and look at it but we might take a peek just so that we get familiar as to what it is doing
2:42:16
so just to kind of give it a diagram to help you visualize this imagine you have your configuration file so you have your
2:42:22
main TF maybe a variables TF a TF bars to load in your variables and then you
2:42:27
run a terraform apply command what it's doing is using the terraform API and it's going to create what we'll say
2:42:33
these we'll call these remote objects but maybe these are resource instances um but it will go ahead and create those
2:42:40
things and then those will get represented within a state file so the idea is that whatever is in the cloud is
2:42:47
going to match what's in that file okay now there is a CLI commands for
2:42:53
terraform State and it's good just to quickly go through them so we have terraform State list this will list resources in the state terraform State
2:43:00
move this will move an item in the state terraform State pull pull current remote State and outputs to St out terraform
2:43:06
State push so update remote States from a local state terraform State replace provider so replace a provider in the
2:43:13
state terraform State removed so remove instances from the state terraform State shows so show a resource in the state
2:43:20
some of these are a little bit interesting so we'll definitely look in Greater detail to move and some of these
2:43:26
people just explore through our follow alongs okay foreign
2:43:33
[Music] special attention to terraform State move because it's definitely on the exam
2:43:39
uh and it is a little bit interesting to what it can do so terraform State moves
2:43:44
allow you to rename existing resources move a resource into a module move a module into a module so if you were just
2:43:51
to rename a resource or move it to another module and run terraform apply terraform will destroy and create that
2:43:56
resource but State move allows you to just change the reference so you can avoid a create and Destroy action so an
2:44:02
example for renaming a resource we would have terraform State move and then we would have the we would identify the old
2:44:08
one so here we have packet device dot worker and we are renaming it to helper
2:44:14
so it's we that's just how we're doing it okay if we wanted to move a resource into a module what we do is say
2:44:21
something like packet device dot worker and then do
2:44:27
module.worker.packetdevice.worker okay so the idea here is that we're moving it into this module here
2:44:33
uh and I think we could probably even rename it at the same time but uh we're not doing that okay so move module into
2:44:39
a module so here we have module app and then we're moving it into the parent one
2:44:44
so we go module.parent module.app okay so what's important to remember for the exam is that terraform State move is
2:44:51
when you want to rename existing resources they're not going to get into these more complicated use cases but
2:44:57
that's how you rename a a resource okay [Music]
2:45:03
okay let's talk about how we back up our state file so all terraform state subcommands that modify state will write
2:45:10
a backup file so read-only commands will not modify it so imagine listen show will not cause a backup file to be
2:45:16
created terraform will take the current state and store it in a file called
2:45:22
terraform.tsstate.backup so this is what it would look like backups cannot be disabled this is by Design to enforce
2:45:28
best practices for Recovery to get rid of the backup file you would need to manually delete the files so there you
2:45:34
go [Music] foreign
Initialization
2:45:42
from exam Pro and we are taking a look at terraforming knit so it initializes your terraform project by downloading
2:45:48
plug-in dependencies so providers and modules creating a DOT terraform directory so that's a hidden directory
2:45:54
and creating a dependency lock file to enforce the expected versions for plugins in terraform itself so on the
2:45:59
right hand side here we can see we have that hidden directory but also notice here that we have a DOT terraform
2:46:05
lock.hcl that is our dependency lock file and so our dependencies are all
2:46:10
going to end up within this sewers as providers that's the provider version there okay so terraform in it is
2:46:16
generally the First Command you will run for a new terraform project if you modify or change dependencies run
2:46:22
terraform in it again to have it apply the changes you need to know that for the exam because they will absolutely
2:46:27
ask you that the First Command here is and these are ones with flags so you can just do terraform in it but we have some
2:46:33
extra options so terraforming it hyphen upgrade upgrade all plugins to the latest version that complies with the
2:46:39
configuration version constraint terraforma knit hyphen get plugins and I
2:46:44
think it's supposed to be equals false there but skip plugin installation terraform init plug-in hyphen dir equals
2:46:51
pass so Force plugin installation to read plugins from only target directory and then we have terraform init hyphen
2:46:57
lock file so you can change the lock file mode it actually doesn't say what the modes are so I don't even know what
2:47:02
you'd do in that case and I could not find any examples but it is an option I just want to make it very clear that
2:47:09
there is a dependency lock file but there's also a state lock file and the way you know that they're different is
2:47:14
that one has Dot Lock in it and the other one has dot TF State this one up here is for dependencies this one of
2:47:20
course is for State a terraform and it does not create a state lock file that is going to happen when you do a terraform apply okay
2:47:27
[Music] let's take a look at terraform get so
2:47:33
terraform get command is used to download and update modules in the root module so when you're a developer you own terraform modules and you may need
2:47:40
to frequently pull updated modules but you do not want to initialize your state or pull new provider binaries and so the
2:47:47
idea here is terraform get is a lightweight way it's because it's only updating the modules it's not pulling
2:47:53
providers in most cases you want to use terraform init with the exception of local module development this will not
2:47:59
show up on the exam but I saw terraform getting I was just so confused about it so I just wanted to make sure I included
2:48:04
it here okay [Music] okay so we're going to be looking at
Writing and Modifying
2:48:10
three CLI commands that are used to improve debugging configuration scripts the first is going to be terraform format this rewrites terraform
2:48:17
configuration files to a standard format and style terraform validate this validates the syntax and arguments of
2:48:22
terraform configuration files in a directory and then you have terraform console an interactive shell for evaluating terraform expressions and so
2:48:29
let's go jump into these three okay [Music]
2:48:34
all right let's take a look at terraform format so this command applies a subset of terraform language style conventions
2:48:41
along with other minor adjustments for readability so terraform format will be by default look in the current directory
2:48:48
and apply formatting to all your dot TF files so let's look at some examples of what it would format so the first is
2:48:54
adjusting spacing two spaces indent so here we have something and it's over indented and so by running terraform
2:49:01
format it fixes the indentation we can also get syntax errors so notice here
2:49:06
that we have a problem and so what it's saying is is that this bracket okay
2:49:13
is supposed to be up here okay but it's all it's down here uh and the last one here is we can do terraform format
2:49:20
hyphen hyphen diff that's going to show what it would change okay so there you go
2:49:25
[Music] let's take a look at terraform validate
2:49:31
so this runs checks that verify whether configuration is syntactically valid and
2:49:36
internally consistent regardless of the provided variables in existing state validate is useful for General
2:49:42
verification of reusable modules including correctness of attribute names and value types so here's an example
2:49:48
where I just had some code and there was a problem it's just saying you're missing your argument because for an AWS
2:49:53
instance you always have to specify an instance type so when you run terraform plan or terraform ply validate will
2:49:59
automatically be performed one thing I need to mention about terraform validate is that it does not go to external
2:50:06
resources to check things are valid so if you have a a value and it's expecting
2:50:12
a string that's all it's going to check for it's not going to check that the string is actually a proper uh like type
2:50:18
of size so if it's supposed to be like a t2.micro and you write you know gobblegoop in there it's not going to
2:50:24
know that that's not a valid type so but we do cover that in the follow along so I think we have like some practice exam
2:50:31
questions that cover that use case okay [Music]
2:50:36
we're taking a look here at terraform console and this is an interactive shell where you can evaluate expressions so
2:50:42
the idea is you type in terraform console and what I can do is I can you know use like built-in functions and
2:50:49
expressions so there I'm using Min and I've actually entered it in incorrectly so there it's throwing an error and here
2:50:55
I'm using the correct way of using it so I get the output so this is a great way just to kind of test very simple things
2:51:01
you can't do things like Define variables or or resources or Define providers but you if you need to figure
2:51:08
out how the Expressions work before you apply them in your code this is a great place to do that okay [Music]
Plan and Apply
2:51:17
all right let's talk about terraform plans so this command creates an execution plan also known as a terraform
2:51:23
plan and it consists of reading the current state of an already existing remote object to make sure that the
2:51:30
terraform state is up to date comparing the current configuration to the prior State and noting any differences
2:51:36
proposing a set of change actions that should if applied make the remote
2:51:41
objects match the configuration and so this is an example of one that's generated you're going to see it uh
2:51:47
throughout this course multiple times so it's not going to be unique that's why I don't have to make that too big for you there terraform plan does not carry out
2:51:55
the proposed changes that's going to be the responsibility of terraform apply and a terraform plan file if you happen
2:52:01
to generate one out is a binary file so if you open it up it's just machine code you cannot make sense of it okay so when
2:52:08
you run terraform apply you have speculative plans and save plans and so speculative plan plans is what's going
2:52:14
to happen when you run terraform apply so the tear so terraform will output the description of the effect of the plan
2:52:21
but without any intent to actually apply it when you have a save plan you're
2:52:26
going to have this hyphen out flag to save it and you can name that file whatever you like and it will generate
2:52:33
out that save plan file and again that's a binary file so you're not going to be able to see what it does and what you can do is then pass it along to
2:52:39
terraform apply so you do terraform apply whatever the file name is and when you are using terraform apply what you
2:52:46
have to understand is that it will not allow it will not ask to manually
2:52:51
approve it as you normally would it would just be Auto approved so that's one thing you have to watch out when
2:52:57
using those safe plans but you know I just wanted to make it concretely understood that terraform plan can
2:53:02
generate at a file uh and it's not actually the one that's doing the apply okay I don't have it written in here but
2:53:09
when you do terraform apply it also is running terraform validate as well okay
2:53:16
thank you [Music] let's talk about terraform apply here so
2:53:22
terraform apply command executes the actions proposed in an execution plan and it has two modes the automatic plan
2:53:29
mode and the saved plan mode so for automatic plan mode that's just when you run terraform apply what it's going to
2:53:35
do is execute the plan validate and then the apply uh you can or you have to
2:53:41
manually approve the plan by writing yes but if you want to skip that process you
2:53:47
can use the hyphen Auto approve flag to automatically approve the plan we just saw save plan mode like how it
2:53:54
worked in the previous slide but let's cover it again so when you provide a file name to terraform to the save plan
2:53:59
file it's going to be terraform apply file and it's going to perform exactly the steps specified by that plan file it
2:54:07
does not prompt for approval so if you want to inspect a plan file before applying it you can use terraform show
2:54:13
okay [Music]
2:54:22
all right let's talk about managing resource drift so drift or configuration or infrastructure drift is when you're
Drift
2:54:28
expected uh resources are in different state than your expected State and the way we can resolve drift are in three
2:54:34
different ways in terraform we can replace resources so when a resource has become damaged or degraded that cannot
2:54:40
be detected by terraform we can use the hyphen replace flag we can import resources so when an approved manual
2:54:47
edition of a resource needs to be added to our state file so we use the import command and refresh state so when an
2:54:54
approved manual configuration of a resource has been changed or removed we're going to use the refresh only flag
2:55:00
to reflect the changes in our state file it's very important to know these three different ways they will all show up an
2:55:05
exam and in practice you're going to need to know them okay foreign
2:55:12
let's first here take a look at replacing resources so we can use the terraform tank command it is used to
2:55:18
Mark a resource for replacement the next time you run apply and why would you want to Mark a resource for replacement
2:55:23
well the idea is that um you know and here's the command here but a cloud resource becomes damaged or degraded and
2:55:29
you just want to return the expected resource to a healthy state so that's the idea behind it and the unfortunate
2:55:34
thing is that terraform taint was deprecated in version 0.152 however there is a better way of
2:55:41
doing it now and so it is recommended to use the hyphen replace flag and providing it a resource address when
2:55:48
you're doing a terraform apply so it's basically the exact same thing the reason why they made this change was so
2:55:54
that um you actually have an opportunity to confirm your change beforehand because terraform tank would just run and this
2:56:00
one down below will actually prompt you to say are you sure you want to do this okay but it's not complicated you just
2:56:06
do a hyphen replace and then you use the resource address of the thing that you want to use that for and this can be used for
2:56:13
both plan and apply the replace flag appears to only work for a single resource so you can't use multiple
2:56:19
resources it's just one at a time and that's something that you should remember okay [Music]
2:56:27
so we just saw a resource address and resource addressing is very important to know for the upcoming commands let's
2:56:34
just give it a bit more attention here so resource address is a string that identifies zero or more resource instances in your configuration an
2:56:40
address is composed of two parts so the module path and the resource path and just expand out that module path it
2:56:46
would be module.module name module index and then on the resource spec this is resource type.resource name and then if
2:56:53
there's multiple instances you give it an index so module path addresses a module within a tree of modules a
2:56:59
resource spec address is a specific resource instance in the selected module so a module is the namespace of the
2:57:05
module module name is user defined name of the module module index when the
2:57:11
multiple so when there's multiple specifying index on the other side that's your resource type your resource
2:57:17
name an instance ID most of the times you're going to be just working with resources but once you start getting to
2:57:24
modules it becomes pretty simple it's always going to be module period because
2:57:30
that's just I think that's the name of the name value so it's always going to be module Dot and then the module name
2:57:35
but here we have a very simple example just for resource type so here if we had a resource called Abus instance and it
2:57:42
was web and there was four of them and we wanted to select the third one we do AWS instance dot web Square braces three
2:57:49
and that would get us the third virtual machine so there you go foreign
2:57:55
[Music] terraform import and this is a command that is used to import existing
2:58:01
resources into terraform so this is how you define it so you'd say what resource you want and you can just leave it blank
2:58:08
so do you define a placeholder for your imported resource and configuration file and you can leave the body blank and
2:58:13
fill it in after importing but it will not be autofilled so you do have to specify all the values okay so the idea
2:58:20
here is you're going to do terraform import AWS instance dot example and then the name of the ID so that Maps over to
2:58:26
the resource address and the ID okay the command can only import one resource at a time this sounds very similar to that
2:58:33
other command we saw for replace not all resources are importable you need to check the bottom of the resource
2:58:38
documentation for support okay [Music]
2:58:44
okay so we're going to look at refreshing and so we're going to break this between the old command refresh and the new command refresh only across two
2:58:51
slides so terraform refresh command reads the current settings from all managed remote objects and updates the
2:58:56
terraform state to match so here we have the terraform refresh and I just want to point out that the terraform refresh is
2:59:04
basically the Alias for terraform apply hyphen refresh only hyphen Auto auto approved so you technically have this
2:59:10
functionality in the latest version it's just that you can't use the old Alias terraform refresh terraform refresh will
2:59:17
not modify your real remote objects but will modify the terraform state so terraform refresh has been deprecated
2:59:23
and the refresh only uh and with the refresh only flag like it's been replaced with it because it's not safe
2:59:29
since it did not give you the opportunity to review proposed changes before updating the state file so that's why the reason they got rid of it let's
2:59:35
take a look here at the refresh only mode so hyphen refresh only flag for terraform planner apply allows you to
2:59:42
refresh and update your state file without making changes to your remote infrastructure just to really make this
2:59:48
clear I want to give you a scenario and I want you to pay close attention here to understand the difference because
2:59:54
this is so important on the exam and also extremely useful for your day-to-day operations so here's a
2:59:59
scenario imagine you create a terraform script that deploys a virtual machine to AWS you ask an engineer to terminate the
3:00:07
server and instead of updating the terraform script they mistakenly terminate the server via the AWS console
3:00:12
because they don't know any better so what happens if you were to run a terraform apply versus with a refresh
3:00:19
only flag so that's what we'll do with and without the flag so without the flag first terraform will notice that the VM
3:00:25
is missing terraform will propose to create a new VM so the state file is going to be what's considered as correct
3:00:33
and the changes and so changes to the infrastructure will be made to match the state file okay if we use terraform
3:00:40
apply hyphen refresh only terraform will notice that the vmu provision is missing
3:00:45
but with the refresh only flag it's going to know that the that the VM is
3:00:51
missing it's an intentional okay so I have a couple spelling mistakes there but the idea is that it knows that the
3:00:57
VM is supposed to not be there so terraform will propose to delete the VM from the state file so just the Json
3:01:03
code from the state file so the state file is considered wrong and changes to the state file will be made to match the
3:01:09
infrastructure so hopefully that makes it clear okay [Music]
3:01:15
foreign [Music]
Troubleshooting
3:01:24
how we would actually go about troubleshooting terraform so there are four types of Errors you can encounter
3:01:30
with terraform uh the first is language error so terraform encounters a syntax error in your configuration for the
3:01:37
terraform or HCL language you have state error so your resources States has
3:01:42
changed from the expected state in your configuration file core errors so a bug that has occurred with the chord Library
3:01:49
provider errors so the provider's API has changed or does not work as expected due to emerging edge cases and when we
3:01:56
talk about what's easy for us to solve and what's hard well the first two are very easy and the other two are harder
3:02:02
to solve so for language errors we can use format validate or version to
3:02:08
resolve our language errors version would just be say hey what version are we using maybe we need to update it
3:02:14
right validate with detect if something's wrong with um the uh the the syntax and format
3:02:19
would fix formatting syntax but you know that probably wouldn't fix that much there for State errors the idea here is
3:02:26
we might want to use refresh apply replace everything that we saw in the drift section for core errors we might
3:02:34
want to go check out the log so TF underscore log is basically just the way of saying like hey these are where the
3:02:40
log files are or is logs turned on we have a whole slide on that but really like all you're going to do is use the
3:02:47
logs to find information and then report a GitHub issue since all terraform is on
3:02:53
GitHub you just go there and then somebody would try to resolve it and the
3:02:58
same thing with providers providers are all hosted on GitHub and so you would just use TF logs to try to find some
3:03:04
information there but we'll take a look a greater look at TF log and how to you
3:03:10
know get that information for the harder to solve cases okay [Music]
3:03:17
okay so let's talk about how we would go about debugging terraform via the log file so terraform has detailed logs
3:03:23
which can be enabled by setting the TF underscore log followed by the type environment you want to run so the
3:03:30
variables that we have or the environments we can specify is Trace debug info warn error or Json Json will
3:03:39
output logs at the trace level or higher and use parsable Json encoding as the
3:03:44
formatting okay so logging can be enabled separately so you can do this
3:03:49
via TF log core or you can get it at the TF log provider so if you just want core
3:03:56
stuff or if you just want provider stuff you just set those environment variables and as we saw in the previous thing that
3:04:02
there you know there was core errors and provider variables so that could be a good way to do that and so TF uh TF core
3:04:10
TF log core and TF log provider take the same environment variables we see on the right hand side there Trace debug info
3:04:16
Etc okay if you want to choose where you want to log things you just can set the TF log path I don't think I actually say
3:04:23
where the default path is I think it's actually in the the project directory but if you want to override that you can
3:04:28
I imagine it either takes an absolute path or a relative path and here's an
3:04:33
example of a terraform log so this is for everything and so there you can see
3:04:39
information I'm going to get my pen tool out here for a moment but you can see we have information about the provider this
3:04:45
is using um there then there's some back-end local stuff so you know there's some
3:04:50
information you're not expected to understand this information generally but you could go bring it to the
3:04:56
provider but you could probably solve something you know if you were to read the core code or the provider is okay
3:05:02
[Music] okay so we looked at TF log which is the
3:05:09
terraform log but there's also a crash log and so if terraform ever crashes and basically this means it goes into panic
3:05:15
because it uses the go runtime it saves a log file with the debug logs from the session as well as the Panic message and
3:05:21
back Trace to the crash.log and so I imagine this is golang information so I
3:05:28
don't use golang that often but you can see we have dot gopanic.go so I think
3:05:33
that there's not much you can do with it so this is where you would just create a GitHub issue and pass it along to the
3:05:39
terraform team because they're going to be able to make sense of it okay [Music]
3:05:46
foreign [Music]
3:05:54
so we're on to our module section uh so let's first talk about how we would go find a module I know we already saw this
Terraform Modules
3:06:00
earlier when we were looking at the terraform registry but let's just cover it again and talk about some of the uh uh details of search okay so terraform
3:06:09
modules can be publicly found in the terraform registry and so on the left hand side when you're under the modules
3:06:15
within terraform registry you can filter your providers okay but another thing
3:06:20
you can do is you can type in Search terms and you can do partial Search terms like Azure compute but what I
3:06:27
really want you to know is that only verified modules will be displayed in Search terms and so I assume that means
3:06:33
verified and also official ones and the reason I'm giving this extra emphasis is because it was an exam question so I
3:06:40
just want you to know that only verified and official ones are going to show up when you search okay
3:06:48
foreign let's talk about using modules and there's our public modules and private
3:06:55
modules so public modules are going to be on the terraform registry and private modules are going to be in terraform
3:07:00
cloud or I suppose terraform Enterprise so terraform registry is integrated directly into terraform so it makes it
3:07:06
really easy to start using them so all you're going to do is use the module block so I'm just going to highlight
3:07:13
that there then we have the name of our module we're providing the source of our module and then there's the version of
3:07:19
our module terraform init command will download and cache any module referenced by a configuration now looking at
3:07:27
private modules it looks very similar um it's just that the name is different so we're specifying the host name in
3:07:34
front here and a namespace as well so to configure private module axis you need
3:07:39
to authenticate against terraform Cloud via terraform login so that's something
3:07:44
there we definitely cover that a lot in the Brax exam so just in case you know
3:07:50
you know all the education is there alternate alternatively you can create a user API token and manually configure
3:07:56
credentials into CLI to configure the file so there you go foreign
3:08:04
let's talk about how we would go about publishing modules and this in particular is for the terraform registry
3:08:09
so these are public modules so if we want to publish modules it supports versioning automatically generating
3:08:15
documentation allowing uh users to browse the version histories showing
3:08:21
examples and read Maze and all of these modules are actually going to be hosted on GitHub so the idea is you're going to
3:08:28
put your module there first and once a module is registered to push updates you simply push new versions to properly
3:08:35
form get tags you have to name the your your modules in a very particular way on
3:08:42
GitHub so the thing is it has to start with terraform hyphen then the provider so AWS and then the name so hyphen VPC
3:08:49
and the way you publish it on terraform registry is you have to connect and publish via your GitHub account so you
3:08:57
just hit sign in with GitHub and it's just going to give you a drop down and you're just going to choose the repo and that's as simple as it is okay
3:09:04
foreign all right let's talk about verified
3:09:09
modules so these are reviewed by hashicorp and actively maintained by official contributors to stay up to date
3:09:15
and compatible with both terraform and their respective providers so here's an example of a module from our friend
3:09:20
Anton down below and as you can see it has a little badge that's how you know that it's verified so verified modules
3:09:27
are expected to be actively maintained by hashicorp Partners verified badges aren't an indication of the flexibility
3:09:34
or feature support but just to kind of go through some things here very simple modules can be verified just because
3:09:41
they're great examples of modules unverified modules could be extremely high quality and actively maintained
3:09:47
unverified modules shouldn't be assumed to be poor quality unverified means it hasn't been created by a hashicorp
3:09:54
partner so you know that again it's not indicative of quality but it just means that it's gone through a bit of vetting
3:10:00
okay [Music] all right let's take a look here at the
3:10:07
standard module structure and this is a file and directory recommended for module development and this is the idea if you were to go and publish your own
3:10:14
module this is what people would expect to see so if you had root modules that's what it'd be and you have nested module
3:10:19
I want to point out that when you are running terraform you technically are creating modules even if you aren't
3:10:25
intending them to publish them into the terraform registry but you know when you make a main.tf you've basically made
3:10:31
your own root module okay so the primary entry point is the root module and these are required files in the root directory
3:10:37
so your main.tf is the entry point file for your module variables TF is the variables that can be passed in
3:10:44
outputs.tf are outputted values readme describes how the modules work license
3:10:49
the license under which the module is available for NASA modules which are optional but must be contained in the
3:10:55
modules directory a sub module that contains a readme is considered usable by external users a sub module that does
3:11:02
not contain a readme is considered inter for only internal use and the idea is to avoid using relative paths when sourcing
3:11:09
module blocks so hopefully that gives you an idea okay [Music]
3:11:20
foreign [Music] let's talk about core terraform
Terraform Workflows
3:11:26
workflows and these have three steps write plan and apply so write plan and apply we saw this kind of in the
3:11:33
terraform life cycle and the idea here is that you know it's just to try to
3:11:40
describe what it's going to be for your team and requirements as you grow and you're utilizing this workflow so if
3:11:46
you're talking about individual practitioners so a single person a team using OSS so they're not using they're
3:11:53
using open source software using terraform but they're not using the terraform Cloud platform and then what it would be like if they're using the
3:11:59
terraform Cloud platform in terms of this right plan apply you're going to see these examples don't perfectly fit
3:12:05
here I am just presenting a summarized versions of the documentation and the
3:12:11
reason why is because on the exam this is one of the sub domains that you need
3:12:17
to know so I'm not saying that I think these are perfectly presented but I think that I have to cover them because
3:12:24
they are in the exam and I you do learn something here so we will go through them okay [Music]
3:12:33
so let's take a look at a terraform or team workflow for a single person an
3:12:38
individual practitioner looking at the right step first so you're going to be writing your terraform configuration in
3:12:44
your editor of choice on your computer um but the thing is you'll be storing your terraform code in something like
3:12:51
GitHub even if you are an individual user you're going to be putting in git or GitHub or some kind of Version Control System you're going to be
3:12:57
repeatedly running terraform plan or even possibly terraform validate to find syntax errors and the great thing about
3:13:04
this is that you get this tight feedback loop between editing the code and running your test commands because it's all on your local machine we're not
3:13:10
sending things off to build servers or other services so it's very fast and
3:13:16
easy talking about the plan stage so when the developer is confident with their workflow in the right step that
3:13:22
commits their code to their local repository this is the stage where it's a local limit it's not a remote commit
3:13:28
they may be only using a single Branch so just probably working in Maine or if you're still using the old syntax Master
3:13:35
Branch once their commit is written they'll proceed to apply that'll bring us to the apply stage so they will run
3:13:42
terraform apply this is on your local machine it's not part of any other process you're just running terraform
3:13:47
apply and it'll be prompted to review their plan after the review the final review they will approve the changes and
3:13:54
await provisioning after a successful provision they will push their local commits to their remote repository so
3:14:01
this is where you will then finally commit your code so there you go [Music]
3:14:10
so we looked at what it would be like if we had a single person working with terraform let's talk about if it's a
3:14:15
team and they're not using terraform Cloud they're just doing it uh the old-fashioned way okay so each team
3:14:20
member writes code locally on their machine in their editor of choice as per usual a team member will store their
3:14:26
code in a branch in their code repository whether it's a uh per feature per user per whatever is up to you
3:14:34
branches help avoid conflicts while a member is working on their code but branches will allow an opportunity to
3:14:41
resolve conflicts during a merge into main it's no different than working with you know code because that's what it is
3:14:47
terraform plan can be used as a quick feedback loop for small teams so we still have that option but as your team
3:14:54
grows larger a concerned over sensitive credentials becomes a concern and so this is where you may need to introduce
3:15:00
a CI CD process so that it's it's going to be in control of the credential so
3:15:06
the idea is that you don't run plan you just push to your branch and it can run it or it only happens on pull requests
3:15:12
that's up to you know your team and how they decide to set it up when a branch is ready to be incorporated on pull
3:15:18
requests an execution plan can be generated I guess when we say execution plan this could be a speculative plan
3:15:24
okay so it's not something we're going to run it's just something we're going to review and displayed within the pull requests for review to apply the changes
3:15:31
the merges need to be approved and merged which will kick off a code build server that will run terraform apply
3:15:37
that's the apply stage there so this is all good but what we need to kind of
3:15:42
highlight is all the work and labor that goes into setting up your own team if you're going to do it all from scratch
3:15:48
without terraform Cloud so the devops team has to set up and maintain their own CI CD pipeline they have to figure
3:15:53
out how to store the state files whether they're going to be in a standard back in a remote state or they're going to
3:16:00
encrypt it and put them into the code repository which is not recommended they
3:16:05
are limited in their access controls so they can't do granular actions to say okay I only want to allow this person to
3:16:11
destroy and this person to apply it's not like that with get repos they have
3:16:16
to figure out a way to safely store and inject secrets into their build server's runtime and that's not argue argue it's
3:16:23
not very hard depending on the solution that you choose but it is a thing that they have to figure out they might need
3:16:28
to manage multiple environments and this can create additional overhead because for each environment you'll have to
3:16:34
create another ciccd pipeline okay so hopefully that gives you the idea of the
3:16:39
effort here and this is going to set us up to say what terraform cloud is going to solve okay
3:16:44
[Music] let's take a look at what our team
3:16:50
workflow or our terraform workflow will be if we were using terraform clouds so 18 we'll use terraform Cloud as a remote
3:16:57
back-end of course they were using uh their favorite editor as per usual working on their local machines to write
3:17:03
that code the input variables will be stored on terraform Cloud instead of their local machine terraform cloud
3:17:08
integrates with your version control system such as git to quickly set up a cicd pipeline a team member writes code
3:17:15
to a branch it commits per usual so that doesn't change a pull request is created
3:17:20
by a team member in terraform Cloud will generate the speculative or execution plan however you want to call it for
3:17:25
review in your version control system the member can also review and comment on the plan in terraform Cloud after the
3:17:32
pull request is merged terraform cloud in the terraform Cloud runtime sorry the
3:17:37
terraform Cloud runtime will perform a terraform apply and a team member can confirm and apply the changes within the
3:17:43
terraform Cloud UI okay so terraform Cloud streamlines a lot of the CI CD
3:17:48
efforts storing it storing and securing sensitive credentials and makes it easier to go back and audit the history
3:17:54
of multiple runs so in terms of the exam if and I didn't see any questions on
3:18:00
this but I know they exist they're just going to be asking you you know which like they might describe
3:18:06
something and say which kind of workflow does this fit and so if you generally know the difference between terraform Cloud working with the team open source
3:18:13
software without terraform cloud and individual workflow it's not too hard you'll be okay all right [Music]
3:18:22
foreign [Music] we're taking a look here at back ends
Terraform Backends
3:18:29
and each terraform configuration can specify a back end which defines where and how operations are performed and
3:18:35
where State snapshots are stored so terraform divides their backends into two types we have standard and enhanced
3:18:42
first looking at standard this is where you can only store the state and it does
3:18:47
not perform terraform operations such as terraform apply so to perform operations you have to use a CLI on your local
3:18:54
machine and the reason why is that standard back ends are basically third-party backends so a standard back
3:19:00
end could be AWS S3 and so you know this is a storage service it doesn't have the
3:19:06
capabilities of pragmatically triggering things okay uh when we have when we're talking about
3:19:11
enhanced back ends we can store both the state and perform terraform operations
3:19:17
so enhanced backends are subdivided further so we have local so files and data are stored in a local machine
3:19:24
executing terraform commands and remote so files and data are stored in the cloud so terraform Cloud the reason why
3:19:31
they can perform terraform operations and when you look at local and remote local is your machine so of course it
3:19:37
can execute terraform and then remote is terraform Cloud which has its own runtime environment it's basically a
3:19:43
build server so it of course can do both those operations and that's how you're going to remember the difference between
3:19:49
those two okay [Music]
3:19:55
all right so we were just talking about standard and enhanced back ends and I was saying that standard back ends are
3:20:01
basically third-party providers that is something other than terraform Cloud so let's take a look at what options we
3:20:07
have available to us starting with the major cloud service providers so AWS has
3:20:12
simple storage S3 Azure has block storage account notice it says Azure RM
3:20:18
because that's just the name of what they call it I don't know what the RM stands for resource manager I imagine Google Cloud Storage is an option then
3:20:26
we have Alibaba we have openstack we have 10 cent and then we have Manta
3:20:33
which is part of joynet's cloud storage so I don't think a lot of people are going to remember joinet joynet was very
3:20:39
popular provider like post or pre-2010 so I remember them 10 cent is a Asia
3:20:47
provider I think they were a texting service they're very popular but they're not the largest provider over in Asia
3:20:52
Alibaba is and of course we have the the three major ones here and then openstack
3:20:58
is for uh private Cloud okay then on the other side of it when we're looking at more exotic or things that aren't Cloud
3:21:05
server providers we have um artifactory we have hashicorp console
3:21:10
etcd postgres database kubernetes secrets and you can also use the ACP
3:21:15
protocol now notice I have these little locks here that's indicating which have state
3:21:21
locking which do not if you don't know what state locking is don't worry we'll talk about it here in a moment
3:21:26
um would there be a question on the exam saying oh which service you know doesn't have state locking and the answer is no
3:21:32
they would never ask that it's too minute but just notice that the only thing that doesn't have state locking is
3:21:38
uh artifactory which I'm kind of surprised because it's a universal repository manager and there's the one
3:21:44
case like with HP protocol where it's optional so it's not that you can't have it it's just that it's not it doesn't
3:21:50
necessarily have to be there and in particular some the the state is or the Locking State locking is
3:21:57
buy another service so for AWS it's dynamodb that is doing the state locking and then with Alibaba uh alibaba's cloud
3:22:04
storage it's table store okay so uh you know there's not much to know here but
3:22:09
uh you know it's just kind of interesting if you want to have a different kind of backend maybe you want to use postgres because you're really familiar with it you can actually store
3:22:15
it there okay so let's take a look at what it would look like if we were to use a standard back end so here's an
3:22:20
example for AWS since I think S3 is very popular so if you were to set up your
3:22:26
back end so here I have a bucket here and I've have to name the state file so
3:22:32
I call it State file and then I give it the region and there it is so the backup of a state file will reside on your
3:22:38
local machine so the backup's not going to be an S3 configuring a standard back end does not require terraform cloud
3:22:43
account or workspace because you know it's it's totally separate from
3:22:49
it so that's something I wasn't sure when I was first using it was okay can I use a standard back end but I still have to have a terraform account or workspace
3:22:54
and the answer is no all right [Music]
3:23:01
all right so we're taking a look at enhanced back end so we're going to start with local and then move on to remote so for the local back end we
3:23:07
store the state on the local file system and it locks the state using the systems API it also performs operations locally
3:23:14
and when we say local we just mean a local machine we don't necessarily mean it has to be our workstation a code
3:23:19
build server could also be considered a local machine okay it just means anything but terraform Cloud that is
3:23:25
running the terraform code so by default you are using the backend State when you have not specified any kind of back end
3:23:33
so normally you'd see a background defined in here we don't so it's going to just default to the local you can
3:23:39
specify the back end with an argument local most people don't you just leave it blank and you can change the path to
3:23:45
the local file a working directory so I think that if you were to specify you'd want to put
3:23:50
the path in but generally again we keep that blank you can set a back end to
3:23:56
reference another state files so you can read it outputted values this is a way of cross-referencing stacks so just
3:24:02
notice that we have this thing that says terraform remote State we're going to repeat this later on in the course because this is a very important concept
3:24:10
and I feel that it gets overlooked in the documentation but it has to do with local backends so the idea is that you
3:24:16
could say hey I have this other file that has a back end and I'm just going to use data sources specify its backend
3:24:23
and then point to its actual terraform State file okay foreign
3:24:30
[Music] we're taking a look here at remote back ends for the enhanced back-end type and
3:24:35
a remote back end uses the terraform platform which is either terraform cloud or terraform Enterprise
3:24:40
by default I usually just say terraform Cloud when I'm referring to the terraform platform but just to
3:24:46
understand there is a distinction between terraform cloud and terraform enterprise Enterprise being the on-premise
3:24:51
offering okay so with a remote back end when terraform apply is performed via the CLI the terraform Cloud run
3:24:57
environment is responsible for executing the operation so that's what you get when you get terraform cloud is you get
3:25:03
this run environment so it's basically just a built-in code build server to run terraform commands for you one thing I
3:25:10
really want you to know about remote back-ends because this really tripped me up uh when I was actually trying to make
3:25:16
the follow along which is the fact that because the terraform Cloud run environment is the one exiting the
3:25:22
command your provider credentials need to be configured in the environment variables in terraform Cloud so you know
3:25:28
if you had a project and you configured it with um TF bars locally and then you
3:25:34
were to swap out your remote backend it's not going to work the way you expect it to because
3:25:40
um again the terraform Cloud run environment is not going to take your credentials and then move them to the cloud okay you have to do that yourself
3:25:47
when using a remote backing you need to set a terraform Cloud workspace
3:25:53
so you would go ahead and go to terraform cloud and just go create one you create one or multiple ones for a
3:25:59
single project if you use a single workspace for a project you're just going to use the workspaces uh name and
3:26:06
if you set multiple workspaces via prefet you can use a prefix okay and the way this prefix works is that you're
3:26:12
going to say like my app or something and when you go to run terraform apply what it's going to do is prompt you to
3:26:18
say which environment do you want to use so and this is what you've created in your terraform Cloud workspace you've
3:26:24
created one called Dev you've created one called Product saying which workspace do you want to deploy to I
3:26:30
want to know that you can only set either name or prefix you can't set both okay so just understand that
3:26:37
[Music] all right so we're taking a look at the
3:26:43
cloud backend um uh code block here and so this is very similar to terraform backend remote
3:26:51
if we're specifying terraform as our back end but now instead of having to do
3:26:57
backend remote we can just give it a cloud block and the reason for this is
3:27:03
well I don't know you can still
3:27:11
foreign
3:27:57
all right let's take a look at the cloud backend block so when using terraform Cloud as a remote back-end State you
3:28:04
should instead use the cloud block to configure its usage so uh previously in
3:28:09
previous uh terraform versions it would look like this so you'd have terraform back and remote and the way you know
3:28:15
it'd be using terraform cloud is that the hostname would be set as app.t terraform.io and so this has been
3:28:20
changed so now that all you have to do is use this Cloud block and so you just don't specify that hostname and for the
3:28:27
most part um uh you know the configurations between them are very similar so the
3:28:33
only thing that we're seeing different is this prefix maybe that prefix is still there we'd have to double check the documentation on that but what's
3:28:38
important to understand is that there's this Cloud block and it is the record amended way to do it now I do want to
3:28:44
point out that I tested both and the remote the remote version still works so you can still do it this way if you're
3:28:50
doing it the old school way and this is just an alternate way uh would they ever make it so you could not use the remote
3:28:56
state in the future for uh terraform Cloud you have to use the block I don't know but I can tell you right now that
3:29:02
they do have that cloud block so both are valid options and the latter of course being the recommended uh use
3:29:09
one so yeah there you go thank you
3:29:16
[Music] so since we're talking about back ends let's talk about back-end initialization in particular the back end hyphen config
3:29:23
flag this is more of an exotic option but I figured we should go over it because it could appear on your exam so
3:29:29
the flag for the back end config flag for terraform init can be used for partial back-end configuration so in
3:29:36
situations where the back-end settings are dynamic or sensitive so they cannot be statically specified in your
3:29:43
configuration file this is what you would do so here would be your main.tf and notice
3:29:49
it says back in remote and it has no details in it so then what you do is you create a
3:29:55
separate file called backend.hcl and now you're specifying the workspace the host name the organization and then uh with
3:30:03
terraform and net you're going to then say Okay use this file as the backend
3:30:08
information that we're going to inject into our backend remote so there you go [Music]
3:30:17
okay we're taking a look here at terraform remote State and I give this a lot more attention in the course because I feel that it gets overlooked within
3:30:24
the terraform documentation it's such a powerful feature and something that I'm used to having in cloudformation which
3:30:29
is cross-referencing Stacks so I want to make sure that you know it too so terraform remote State data source
3:30:34
retrieves the root module output values from another terraform configuration file using the latest State Snapshot
3:30:41
from the remote back end so the idea is that you can reference a state file from somewhere else you can do it uh via a
3:30:48
remote backend and a local backend so just take a look here we see data and
3:30:53
the data sources terraform remote State and we're setting the back end as a remote on the right hand side here it is
3:30:59
local and if it's a local back end we give the path to the TF State file if it's remote that means it's another
3:31:05
workspace and terraform Cloud so we set the workspace that we want to access and
3:31:10
then when we want to access those resources we're using data sources so we do data Dot and it's terraform remote
3:31:16
State and then we specify it knows that it's no difference whether it's remote or local but you're going to be getting
3:31:21
datas from outputs okay so only the root level output values from the remote
3:31:26
State snapshots are exposed resource data and output values from nested modules are not accessible to make
3:31:33
module outputs values accessible as a root module output values you must
3:31:39
explicitly configure a pass-through in the root module so here's an example of
3:31:44
us doing a pass-through so we have a module called app and it has a source and then we're just setting an output
3:31:51
notice that we are just grabbing the value and passing it along I want to tell you about the alternative to terraform remote State because if you
3:31:58
can you should use these as opposed to using terraform Road States so terraform remote state only exposes output values
3:32:04
its users must have access to the entire State snapshot which often includes some sensitive information it's recommended
3:32:11
explicitly uh it it's recommended to explicitly publishing data for external consumption to a separate location
3:32:18
instead of accessing it via a remote state so what would be Alternatives well
3:32:23
you've seen this because when we looked at data sources we were technically we're using Alternatives but the idea is that you are going to say AWS S3 bucket
3:32:31
AWS rep 53 zones and these are kind of already set up to work with AWS or
3:32:37
whichever provider okay so that's that there
3:32:42
but uh yeah hopefully that's pretty clear so the idea is that when you can use these data sources because you know
3:32:49
they're actually working off of live data right like it's hitting a resource it's not just looking at a state file that contains data okay
3:32:56
[Music] so we had mentioned State locking just
3:33:03
briefly when we were looking at standard back ends but let's go take a look in detail what these are because they're
3:33:08
very important for your workflows so terraform will lock your state for all operations that could write State this
3:33:15
prevents others from acquiring the lock and potentially corrupting your state so State locking happens automatically on
3:33:21
all operations that could write State you won't see any message that it's happening if the state locking fails all
3:33:28
right so terraform does not output when a lock is complete however if acquiring
3:33:33
the lock is taking longer than expected terraform will output a status message so neither on failure and neither when
3:33:40
it is complete just if it takes too long so there's a transient issue something with like a networking issue you can
3:33:46
disable lock so what you do is use the hyphen lock flag but it's generally not
3:33:52
recommended you can force and unlock there's cases where uh you know just does not unlock or add so what you'll
3:33:59
have to do is use the force unlock camera and if you unlock the state when someone else is holding the lock it
3:34:05
could cause multiple writers Force unlock should only be used to unlock your own lock in the situation where
3:34:12
automatic unlocked failed to protect you the force unlock command requires a unique lock ID so terraform will output
3:34:19
this lock ID if unlocking fails so this is what it would look like so we have terraform Force unlock and then whatever
3:34:25
the ID is hyphen Force so yeah there's a lot going on here but yeah that's what
3:34:31
it is [Music]
3:34:36
all right so let's talk about protecting sensitive data so terraform State file can contain sensitive data so long-lived
3:34:42
database credentials and is possible attack Vector for malicious actors and so when you're dealing with the local
3:34:48
state when you're using local backend the state is stored in plain text Json files you need to be careful you do not
3:34:55
share the state file with anyone you need to be careful you do not commit this file to your git repository when
3:35:00
you're using a remote state with terraform Cloud the idea here is the save file is held in memory and is not
3:35:06
persisted to disk the state file is encrypted at rest the state file is encrypted in transit with terraform
3:35:11
Enterprise you have detailed audit logging for tampering evidence to take it one step further so you can just see
3:35:17
that there's a lot of work that has to be done when you are using it locally but with terraform Cloud this is kind of
3:35:23
the cell for terraform cloud is that it's just going to do everything possible to make that secure would it be
3:35:28
secure to use a remote say with a third-party storage let's talk about that so you can store state with a various third-party back-ends but you
3:35:35
need to be careful to review your backend's capabilities determine if you meet your security and compliance requirements some back-ends are not by
3:35:43
default as secure as they could be so for example AWS S3 you could have you have to ensure encryption and versioning
3:35:49
is turned on and you need to create a custom Trail for data events so you can get tamper evidence logging if you turn on
3:35:56
data events for custom cloud trail events but one thing that if it's
3:36:01
important to you is that you know if you use S3 it's not held in memory you know that'd be using a cloud HSM or KMS so
3:36:09
you know you have to understand there are some trade-offs okay [Music]
3:36:17
let's take a quick look here at terraform ignore files and if you know what git ignore files it's pretty much the same thing so when executing a
3:36:23
remote plan or apply in a CLI driven run an archive of your configuration directory is uploaded to terraform cloud
3:36:29
and so you could Define paths to ignore from upload via the dot terraform ignore file at the root of your configuration
3:36:36
directory if this file is not present the archive will exclude the following by default so dot get dot terraform and
3:36:43
Dot terraforming Nora works just like a DOT get ignore with the only difference is that you cannot have multiple dot
3:36:49
terraform ignore files in subdirectories only the file in the root directory will be read so there you go and yes I know
3:36:56
there's a double the okay so don't worry about that [Music]
3:37:03
foreign foreign
3:37:10
[Music]
3:37:19
let's talk about resources so resources in configuration files represent infrastructure objects such as virtual
Resources and Complex Types
3:37:25
machines databases virtual Network components and storage and so it pretty much looks like this a resource type is
3:37:30
determines the kind of infrastructure object it is so here it says AWS instance and this would represent an AC
3:37:37
AWS ec2 instance this is all defined within the providers documentation so you have to kind of look at what name
3:37:43
they use to figure out what it is and even though you don't see provider explicitly set here a resource does
3:37:49
belong to a provider and you can explicitly set it and you would do this when you'd want to set a resource
3:37:55
outside the default provider that you have in your configuration file and so one little thing that I hadn't mentioned
3:38:02
anywhere else and that's why I made this slide was to mention about special timeout nested blocks within resources so some resource types provide a special
3:38:08
time on asset block argument that allows you to customize how long certain operations are allowed to take before
3:38:13
being considered to have failed okay so there you go foreign
3:38:20
[Music] let's talk about complex types so a complex type is a type that groups
3:38:26
multiple values into a single value and complex types are represented by type Constructors but several of them are
3:38:33
have shorthand keyword versions okay so there are two categories of complex types we have collection types for
3:38:39
grouping similar values so list map set and structural types for grouping potentially to similar values so Tuple
3:38:46
an object and it's now that we have an overview let's go jump into collection types and structural types
3:38:51
[Music] a collection type allows multiple values
3:38:58
of one other type to be grouped together as a single value and the type of value within a collection is called its
3:39:03
element type the three kinds of collection types are list map and set and so looking at our first one here
3:39:10
what we're doing is we are setting ourselves something that looks kind of like an array and it's these list type
3:39:15
here and what we can do is use our index so the indices 0 to reference the first
3:39:20
element which is Mars so that's going to make our username Mars for a map it's very similar to a ruby hash or
3:39:26
singleness to Json object and the idea here is that it's very similar to the first except now we're doing a key and
3:39:33
value and then we access it by based on the key name so plan B is going to
3:39:38
return 50 USD okay we have set it is similar to a list but has no secondary index or preserved
3:39:45
ordering all values must be of the same type and will be cast to match the first element
3:39:51
okay so it's a great way to kind of have um well I guess no secondary index but
3:39:56
yeah so you do two set and then it would turn into this okay [Music]
3:40:04
all right let's take a look here at structural type so a structural type allows multiple values of several distinct types to be grouped together
3:40:10
with a single value structural types require a schema as an argument to specify which types are allowed for
3:40:15
which elements so this is what they're talking about when they say this schema so when you actually Define the variable
3:40:21
notice where it says object and you are actually setting a is going to be a string and B is going to be a string
3:40:27
there's this optional option which I think is right now in beta but hopefully by the time this course is out or it's
3:40:32
the future you have that option there but just assume that they're all required so that's what they're talking about is that you are specifying exactly
3:40:38
what you expect the schema to be okay so there are two kinds of structural types
3:40:44
we have objects and tuples and they're going to look very familiar to maps and lists because they're pretty much the same but with explicit typing so object
3:40:51
is a map with more explicit keying so this example we'd have name for string age for number and so that's what it
3:40:57
would expect the data structure to be for Tuple multiple return types with a parameter so we can have string number
3:41:02
or Boolean so so this is where we'd have a as a string 15 or true as a Boolean so
3:41:10
you know there you go [Music]
3:41:16
hey this is Andrew Brown from exam Pro and we're going to look at the collection and structural type so I have
3:41:22
a new folder down below just in case we need to Define some things so I'm going to go here and just call this main.tf
3:41:31
and we are just going to configure this for a local terraforms we'll just give the brackets there and so the idea is
3:41:37
that we might have different kinds of variables and we had done this previously where we
3:41:43
created a list and a map but we can do that again so we'll have like planet
3:41:48
right so that's list and then we just default that to a value Mars
3:41:56
Earth Moon and then we could also have you know
3:42:02
plans here and that would be our map type
3:42:08
okay and so here we'll just set it
3:42:14
the curlies plan A
3:42:25
Plan B plan C
3:42:43
um so we'll do terraform console and so that should load these variables for us
3:42:49
to use and so if I do var.plans I get that and if I do VAR dot planets
3:42:58
uh didn't like what I did there input variable has not been declared I suppose just plan it there so I should
3:43:05
have named that planets up here and so what we're going to do here is just go ahead and exit
3:43:12
type clear I'm just going to expand this a bit bigger so we're taking over more of the
3:43:17
screen and let's take a look at structural types so these require you to actually Define
3:43:22
um parameters so what I'm going to do is go down below and we're going to do the object
3:43:29
and object is very similar to the map so let's go down here plans object
3:43:38
and so here what we do is we'd say type object
3:43:45
and we would just have to Define some settings here
3:43:51
um so we could say
3:43:59
a is a string all right we'll see if that works
3:44:09
the default value is now compatible with the variable type constraint attribute a is required
3:44:15
so that's fine what we could do is just Define this as like plan A
3:44:23
Plan B plan C
3:44:31
and now if we just do VAR plans object when you are using this you know you
3:44:38
might want to specify some different kinds here so you could just say like you say like plan here
3:44:45
as soon as they plan name plan amount
3:44:52
maybe it's like number and so then we'd say plan name
3:44:58
plan amount basic maybe this will be 10.
3:45:09
okay and we'll just uh type exit here and go back into terraform Cloud hopefully we don't get
3:45:15
an error here so the plan amount is required so you know we can't have a spelling mistake here
3:45:23
just do VAR plan here
3:45:28
um well we named it correctly there and when we went up here and specified it I
3:45:34
think we got it right plan object so
3:45:41
tripler doesn't like here oh you know what we're not in terraform Cloud okay that's fair
3:45:47
and we're still spelling this wrong
3:45:52
oops
3:45:58
okay so there we go we get our basic plan um and then we could do a tuple here so
3:46:07
I don't know if I've ever defined a tuple before so let's just try it here and so we'll just say uh
3:46:13
groceries or value or random
3:46:22
type equals Tuple
3:46:32
I'm just looking up if there's any kind of definition I can find here
3:46:44
I'm not really finding anything but I'm just going to go Define this here because I thought maybe it needed like a schema or something but maybe it doesn't
3:46:50
so we'll just say hello 22 false okay
3:46:57
terraform console dribble Constructor requires one argument specifying the element types as
3:47:04
a list okay so if that's the case then what we could do is say string
3:47:10
number Boolean
3:47:18
the type Constructor requires one argument specifying the number of elements so clearly I'm doing this wrong
3:47:24
so just give me a second I'll be back in a moment okay all right so I think the problem here was just that I need to make brackets here like this
3:47:31
we'll give that a go boolean's not a valid option what if we
3:47:37
try Bool okay we say VAR dot random
3:47:43
good and so I'll just go ahead and exit that out I'm just going to see what happens if I change the order here so let's say I do instead of 22 here
3:47:51
we go here okay so notice that you know we can have
3:47:56
all sorts of Kinds but they have to match exactly the order that is there so yeah that's pretty much it so there you
3:48:02
go [Music]
3:48:07
the terraform language includes a number of built-in functions that you can call from within Expressions to transform
Built in Functions
3:48:13
your combined values so we have numeric string collection encoding file system
3:48:18
date and time hash encrypto ipnetwork type conversions so we are going to go
3:48:25
through all of these we might not go through every single function but we'll go through every single major category
3:48:30
in terms of the exam the only thing that's going to show up might be string functions why they do this I don't know
3:48:37
it's not a very good exam question but those might appear but I think that this is one of the strongest features of
3:48:42
terraform over something like cloud formation and I really want to just show you the Gambit of them okay
3:48:48
foreign [Music] let's take a look here at numeric
3:48:54
functions starting with absolute so Returns the absolute value of the given number so 23 is 23 0 is 0 and if you get
3:49:00
a negative number it's going to flip to the positive for 4. what it does is it rounds down to the nearest whole number
3:49:06
so see where it says 4.9 becomes a 4. you have logs so it Returns the
3:49:11
logarithmetic I can't say that word logarithm logarithm of a given number in
3:49:16
a given base so log 50 comma 10 is going to give you that 16 comma 2 is going to
3:49:22
give you 4 okay seal it it's where it will always round up so see where it says 5.1 and it goes all the way to 6.
3:49:29
we have Min so take one or more numbers and return the smallest number from the set and Max take one or more numbers and
3:49:36
return the greatest number of the set I don't have examples because that's pretty straightforward you know if there's a two and a four it's going to return the two in Min if it's a two and
3:49:42
a four it's going to return the four for Max we have parse n so parse is the given string as a representation of an
3:49:49
integer in the specified base and Returns the resulting number so if we have a hundred here in strings it's
3:49:56
going to and we say comma 10 we're going to get 100 because that's the base system it's base system 10 base system
3:50:02
16 we can see letters in there right so it's able to translate that this is two so that's basically binary so zeros and
3:50:10
ones so you get the idea there uh pow so calculates an exponent by
3:50:16
raising its first argument to the power of the second argument so that's just the way of doing powers and then we have
3:50:22
Signum so determine the sign of a number returning a number between negative one and one to represent the sign so there
3:50:30
you go [Music]
3:50:36
all right let's take a look here at string functions the first being chop so removes new line characters at the end
3:50:41
of a string so you know if there's a hyphen n or sorry backslash n you don't want to see that there that's the way
3:50:47
you get rid of it then you have formats it produces a string by formatting a number of other values according to the
3:50:52
specification so here there are percentage Delights so this is
3:50:58
representing a a digit so it's taking that number this says it's going to be formatted as a string okay
3:51:04
format list so produce a list of strings by formatting a number of other values according to a specification string so
3:51:12
here we have an array and then we have our specification so you can see it's substituting the name there
3:51:19
um we'll look at indents so adds a given number of spaces to the beginnings of all but the first line in a given
3:51:25
multi-string so here we have a string and what it's going to do is see where
3:51:32
we have the interpolation here and then we have indent I know the the highlighting is not great because it's a
3:51:37
single string but we have interpolation we have parentheses two so give it a a
3:51:42
layer of two indentation and then it's going to break that up and give it indentation so we have join so produce a
3:51:50
string by concatenating together all elements of a given list of strings with a given deliminator so use delimiters is
3:51:57
double click or sorry it's a comma and so it's going to glue that together to make this okay
3:52:02
if there's only a single one there just won't be any comma in there we can lower all the text it's pretty straightforward
3:52:09
we have regular Expressions so that is an extremely powerful feature so here we
3:52:14
have the regex I don't know what the regex format is uh maybe it's Pearl I'm not sure there's like a bunch of
3:52:21
different types of regex Standards so you know do you have to figure that out so you know how to use it and then
3:52:26
there's a regex all so applies to a regular expression to a string and returns a list of notches where this just is returning uh one okay
3:52:33
We have replaced so search is a given string for another given substring and replaces each occurrence within a given
3:52:40
replacement string this is just like the JavaScript replace we have split this is the opposite of join so if we want to
3:52:47
split on the comma we specify comma here we have Str rev so string reverse so
3:52:52
reverse is a string so hello becomes Ole we have sub ol
3:52:59
sure I don't know um so substring so extracts a substring
3:53:04
from a given string by offset and and length so we have a substring and we're saying we want one to four so we only
3:53:11
want one two three four here okay because it starts at zero we have title
3:53:17
so make a title okay so capitalize the H and the w we have trim removes the specified character from the start and
3:53:24
end of the string so we don't want these and we tell it to remove those there's a lot of string functions uh so
3:53:29
we have trim prefix so it removes the specified prefix from the start of the given string if the string does not
3:53:35
start with the prefix the string is is returned and unchanged so here we say we
3:53:40
want to get rid of hello in the front so we do that suffix is the opposite so we want to get a rid of world out of the
3:53:46
suffix so we do that we have trim space so removes all types of white space from both the start and end of the line so it
3:53:53
gets rid of the new lines and the spaces upper is going to put everything to Upper and there you go on the exam they
3:53:59
probably will ask you uh like what string function does or which one does not do something so this is the only
3:54:06
part of the built-in functions you have to know for the exam I don't think it's a very good exam question but it does appear there so you need to know it okay
3:54:13
foreign [Music]
3:54:18
functions and these are the most powerful built-in functions and there's a lot of them and I made sure to give
3:54:24
you an example for each one because I really do want you to know these because this is the power of terraform the First
3:54:29
on our list here is altru's returns true if all elements in a given collection are true are true or it also returns
3:54:36
true if the collection is empty so it's either true true right or we have true false so because there's a false it's
3:54:42
not going to be true so any true is very similar but there only has to be one that is true so if this is true and
3:54:50
there's a false that's going to be true if it's blank it's going to be false okay we have chunkless splits a string list
3:54:58
into fixed size chunks returning a list of lists so here we're telling it to
3:55:04
chunk it every two so grab every two and make them into their own little array or list I suppose we have coalesce takes
3:55:10
any number of arguments Returns the first one that isn't null or empty string if you're used to postgres you use this all the time but the idea is
3:55:17
it's going to grab the a in this case it'll grab the B because that's blank in this case we'll grab the one because
3:55:22
that's the first value we have coalesce list takes any number of list arguments and Returns the first one that isn't
3:55:28
empty so very similar it's just using lists or if we want to call them array so the first one is available so it
3:55:33
takes that one we have compact so it takes a list of strings and returns a a new list with an empty string elements
3:55:40
removed so it's just going to get rid of that space there and we'll get ABC
3:55:46
we have concat so it takes two or more lists and combines them into a single list so that's very convenient we have
3:55:52
contain so determines whether a given list or set contains a given single
3:55:57
value as one of its elements so does it have an A yes it does does it have a d
3:56:03
no it does not we have distinct so takes a list and returns a new list with any
3:56:09
duplicate elements removed so we just want to make sure we only have one of
3:56:14
each so do we have any duplicates here we have two a's and two B's so we're
3:56:19
going to end up with just a single list so only exactly one of each letter
3:56:25
we have elements retrieves a single element from a list so get me the element at uh at three here so
3:56:33
um wait retrieves a single element from a list okay well that's what it does you give
3:56:39
it a three and it gives you an a I don't know why it's not clicking for me but I I'm not following through here index
3:56:45
finds the element index for a given value in a list so we say where is B and
3:56:51
the index of B is is one because it'd be zero and this would be one still really confused about this one
3:56:57
flatten takes a list and replaces any elements that are are lists with a
3:57:03
flattened sequence of list content so basically it says give me a bunch of eraser let's turn into one flat list
3:57:10
uh Keys take a map and return a list containing the keys from the map so we
3:57:15
just want the keys a c and d we want length this is pretty straightforward so what's the length of
3:57:22
this zero this is two this is one because it's a one uh mapper one thing
3:57:27
key value in there and if it's a string it's going to count the characters so there's five characters
3:57:33
we have lookup so retrieves the value of a single element from a map given its key if the given key does not
3:57:40
exist the given default value is returned instead so we say look up a and what we get is a
3:57:49
y right look up C and it could not find C so by default give us what instead
3:57:57
key a match Keys construct a new list by taking a subset of elements from one list whose indexes match the
3:58:03
corresponding indexes of values in another list that sounds complicated let's read that
3:58:08
one more time so constructs a new list by taking a subset of elements from one
3:58:14
list who indexes match the corresponding index of values in another list that is confusing so we have one less than
3:58:21
another one so we have this one here and we have us West Us East USD so we
3:58:27
say okay we have uses so the elements here is two and three so give us two and
3:58:32
three so that's what it does that was a that was a tricky I can't think of what you use that for but that's a interesting function merge
3:58:39
takes an arbitrary number of maps or objects and returns a single map or
3:58:45
object that contains a merged set of elements from all arguments so it just merges them together so it's
3:58:50
just like concat or I suppose like flatten uh one takes a list set or Tuple values from with
3:58:58
either zero or one element if the collection is empty one returns null otherwise one Returns the first element
3:59:04
if there are two or more elements then one will uh one will return an error so
3:59:10
it returns null on an empty List It Returns the first one and then here it says invalid function so it's just saying is there one right is it one or
3:59:17
zero ranges generates a list of numbers using a start value a limit value and a
3:59:23
step value so we say three and we get 0 1 and 2. during its a list of numbers using a
3:59:30
start value limit value and a step value okay uh reverse so takes a sequence and
3:59:37
produces res oh not reverse Reserve sorry Reserve
3:59:42
takes a sequence and produces a number induced sequence of the same length with
3:59:47
all the same elements as the given sequence but in reverse order oh it is reverse r e reverse I guess I spelled it
3:59:54
wrong here sorry reverse one two three three two one just notice this is a spelling mistake okay
4:00:00
uh set intersection so function takes multiple sets and produces a single set
4:00:05
containing only the elements that all of the given sets have in common in other words it computes the intersection of
4:00:12
the sets well it's tiring so from what I can tell it's like they all have B so
4:00:17
give us B right set product functions find all the possible combinations of elements from
4:00:23
all of the given sets by Computing the cardistarian product we're really getting into math here so we got app one
4:00:31
and app2 and so we got uh development develop okay so this continues on so it's going
4:00:37
to say give me app one with development give me uh app two with development then Apple Mustang and then app2 with staging
4:00:43
and etc etc because that's why I put the three dots there set subtract function returns a new set containing the
4:00:50
elements from the a from the first set that are not present in the second set in other words it computes the relative
4:00:57
complement of the first set in the second set uh it lost me there but it says set
4:01:03
subtract so here I see a B and C A and C minus it you get B okay
4:01:09
set Union function takes multiple sets and produces a single set containing the elements from all the given sets in
4:01:16
other words it computes the union of the sets so it says set Union so we have
4:01:21
a b b c and d and in the results we get d b c a so I guess
4:01:29
um single set containing the elements from all the given so yeah yeah I guess it's just we get unique ones across the
4:01:35
sets uh we have slice and notice like we're going through all these things it's like you probably won't use these more exotic ones so it's not a big deal
4:01:42
if we don't nail them here but it's important that we go through these so that you know you just know all the options are here so slice extract some
4:01:48
constructive consecutive elements from within a list so here we are saying one
4:01:54
and three so we have B and C that's where they start index one
4:01:59
um and then extract some consecutive elements from within a list one comma
4:02:05
three okay sort takes a list of strings and returns
4:02:11
a new list with those strings sorted lexicographically so we have e d a and x
4:02:17
and so now they're alphabetical so a d e and X well I think this is the last one uh
4:02:24
some takes a list of set numbers and Returns the sum of those values that's pretty straightforward add them all up transpose take a map of list of strings
4:02:31
and swap the key and values to produce a new map a list of strings so kind of
4:02:36
like inverts it values takes a map and returns a list containing the values of the map so we saw this earlier we got
4:02:43
the keys this is where we just want to get the values zip map so construct a map from a list of keys and a
4:02:48
corresponding list of values so we have a b one two and this turns it into a equal one b equals two I think I saw
4:02:55
this on the exam so that one you might want to remember but yeah that's collection functions as you can imagine they're extremely powerful but they can
4:03:02
also be really confusing so maybe just use them a little bit when you need to okay [Music]
4:03:10
we're taking a look here at encoding and decoding functions so functions that will encode and decode for various
4:03:16
formats so imagine we need to encode into base64 so we do hello world or
4:03:22
imagine we give that encoded string and we want to decode it back to hello world that's what we can do so there's a lot
4:03:29
of different encoding decoding functions most of them are the same they're just kind of variants so we're not going to go through every single one but I'll
4:03:35
list them out so you know what they are so we have base64 encode Json encode text and code base64 yaml encode base64
4:03:42
gzip URL encode base64 decode CSV decode Json decode text decode base64 yaml
4:03:51
decode and just notice that you know these aren't one to one so there is one for this we have one for here uh we have
4:03:59
one for yaml uh this is unique this is unique this is
4:04:04
unique okay just so you can tell for your own code I think this one's a very common one that you'll use but the idea
4:04:10
is that let's say you have hello world you want to replace that string with a uh whatever friendly for a URL right so
4:04:15
it just encodes it okay it's very useful when you're making URL links so there you go
4:04:21
[Music] we're taking a look here at file system
4:04:27
functions so this has everything to do with the file system so the first is absolute path so the idea is you give it
4:04:32
something that's relative and it's going to give you something absolute directory name so this is a string containing a
4:04:38
file system path and removes the last portion from it so we don't need the file name so we just remove that off of
4:04:44
there we have path expand so takes a fossils and path that might begin with a tilde and expands it into its absolute
4:04:53
path so this would be like for home okay um base name so it takes a string
4:04:59
containing a file system path and it's basically the opposite of directory name we just want the file here okay
4:05:04
onto the next page here this file will read the contents of the file pretty
4:05:10
straightforward we can check if a file exists so we just do file exists here we
4:05:15
have file set so it enumerates a set of regular file names given a path and pattern file base64 so it reads the
4:05:23
contents of a file at a given path and Returns the basics before encoding that might be good for images template file
4:05:29
so reads the file at a given path and returns its content as a template using
4:05:34
a supplied set of template variables so that's really useful if you want to do some kind of templating
4:05:40
uh and just notice it's a two-step process so this is the template file the actual file itself and then we load it
4:05:46
here it's called a DOT TPL so there you go [Music]
4:05:54
we're taking a look at date and time functions the first is format date so the idea is that we provide a format
4:06:01
that we want and then we give it a timestamp that is in the RFC 3339 format and we get a variety of different
4:06:08
um formats out there we can add time so again it's going to be that RFC 3339
4:06:13
format and we say add 10 minutes add one hour then we have timestamp so you it
4:06:19
returns a UTC timestamp string in the RFC 3239 format so you just say timestamp it's I guess it would get
4:06:24
right now and then you get it in that format okay [Music]
4:06:31
let's take a look at hash and crypto functions so generates hashes and cryptographic strings so the most
4:06:37
popular one out there would probably be B so here we just say hello world and we're going to get this thing here
4:06:42
understand that a hash cannot be reversed so once it is turned uh into uh
4:06:48
you know this format the only way you're going to be able to confirm the contents of it is to Hash something that is
4:06:54
similar and then compare it against it okay so we have base64 Shaw 256 we have
4:07:00
512 we got B Crypt we have file Bay 64 Shaw 256 file based 64 Shaw 512 file md5
4:07:07
file Shaha one file Shaw 56 file Shaw 512 md5 RSA decrypt sha-1 Shaw to V6
4:07:17
Shaw 512 uuid uid V5 so I only showed the one because you know it gets kind of
4:07:24
boring to go through all these and really it's just going to be based on your use case what you're going to be using on a day-to-day basis is probably
4:07:30
bcrypt md5 and you uids so there you go [Music]
4:07:38
let's take a look at IP network functions these are the coolest functions I think that are built into terraform so we have cider host so what
4:07:45
we can do is give ourselves a a address and then we can give it a
4:07:50
subnet Mass size and we'll get back an IP address and so you can see we have this both in the ipv4 and the IPv6 we
4:07:58
have cider net mask so here we are doing cidernet math so we just say forward
4:08:05
slash 12 and it's going to translate it into the full ipv4 then we have cider subnet so this is just where we say Okay
4:08:12
I want a subnet of a particular size so we say 172 1600 comma 4 2 and look it's
4:08:20
going to give us 18 0 back doesn't make sense that's okay I mean networking is really hard but I just want you to know
4:08:26
that these functions are here for you okay cider subnet calculates a sequence of consecutive IP addresses within a
4:08:32
particular cider prefix so 4484 and then you get those sizes there okay
4:08:39
[Music] all right we're on to type conversion
4:08:45
function so the first we're looking at is can so can evaluates the given expression and returns a billion value indicating whether the expression
4:08:51
produced a result without any error so can we use this right so we say local.food.bar and so you know if if
4:08:58
this Foo wasn't defined then it would say false but apparently we've made it all the way to borrow okay
4:09:04
we have defaults a specialized function intended for use with input variables whose type constraints are object types
4:09:10
or collection of object types that include optional attributes and I don't show that one here because it's not that
4:09:16
exciting but non-sensitive takes a sensitive value and returns a copy of that value with the sensitive markings
4:09:22
removed therefore exposing the sensitive values so if we have an output here and we want to make it non-sensitive that's
4:09:29
what we could do then sensitive as you imagine is just the opposite okay
4:09:35
we have two Bool so converts its arguments to a Boolean value so if we have a string that's true we can turn it
4:09:42
into a real Boolean value we have to map converts an argument to a map value to set converts it to a set to list
4:09:48
converts it to a list to number converts it to a number string to string and then
4:09:54
we last we have is try so evaluates all of its arguments expressions in turn and Returns the result of the first one that
4:10:01
does not produce any errors the thing that's the hardest to figure out is set I cannot find really good examples or
4:10:07
documentation on the use case of set there are some cases where you need to use sets which is an actual type but
4:10:12
even talking to DA's and technical writers they weren't even sure themselves so this is not something
4:10:18
you're going to come across very often but there's like one case where I saw it so I'll probably point that out when we do
4:10:24
hit it okay [Music]
4:10:29
hey this is Andrew Brown from exam Pro and we are going to go take a look at um built-in functions as soon as my
4:10:36
terminal decides to be responsive I don't know why as soon as I start recording it decides to lock up so we'll just give it a moment there there we go
4:10:42
and so I have a new folder there I figured we could just find some variables so that we don't have to uh
4:10:48
you know constantly write stuff in so we'll just say main.tf
4:10:53
we're going to go terraform here and so might be fun to you know kind of
4:11:01
some kind of variable here and so I have off screen here all the functions so we're just going to kind of pick some at
4:11:06
random here to play around with so we get some experience okay so just going through strings
4:11:14
I think what we can do is Define like our strings so we just say Str here and we'll just say type equals string
4:11:22
and we'll just say default here able to say hello world
4:11:27
forward slash n something like that okay
4:11:33
and then we'll do terraform console here
4:11:39
I gotta remember to do it this way
4:11:45
so we do var.str okay and so that accesses our string there
4:11:50
maybe we might want to take out the new line for now
4:11:59
so I'm just going to kind of pull this up over here look at some kind of things we can do
4:12:11
okay maybe collapse that get that out of the way all right so there's a lot of string functions and on the exam they
4:12:18
might actually ask you some which is in my opinion I don't I don't really like that but that's what they do
4:12:23
and so you know we might want to look at something like split or something so here we could do
4:12:30
hello world okay
4:12:36
start that up again so we'll do split comma
4:12:42
VAR Str okay and that would split that into a list we might want to do something
4:12:50
like upper so I think we did that earlier where we did upper
4:12:59
okay you might want to do trim remove specify characters from the start and end of the
4:13:05
string so maybe we have this here
4:13:12
and so we'll say trim VAR Str
4:13:19
and whoops it's not what I wanted to do
4:13:24
trim far Str UCT like that okay
4:13:31
and there's again there's not a lot that's exciting here maybe we'll try a replace so we can do replace
4:13:40
and we'll we want to replace we won't provide our string and then the substring that we're
4:13:45
looking for so world replace that with bar soon which is Mars
4:13:50
there we go so nothing super exciting over there
4:13:57
what's more interesting are some things like these hash encryptos so something we might want to generate
4:14:02
out is a uuid I think that we might be able to do this here so let's just see what happens if we try to call it like
4:14:08
that clear to our form cloud
4:14:15
oops terraform console that's what I meant to type and so functions can't be called in here
4:14:22
which is totally fine so go back and just set that like that
4:14:28
I just wanted to show you that so if we did uuid we would get that
4:14:33
if we used bcrypt so I might say bcrypt
4:14:42
hello world
4:14:49
okay might be something interesting the IP network here
4:14:56
so we might want to generate out a cider subnet right
4:15:02
the typing conversions is something that you might come across a bit so we already saw that when we converted a set
4:15:07
to a list and things like that so maybe we might want to convert something to a Boolean so we might say
4:15:13
two Bool true okay
4:15:21
these are pretty complicated the collections but we might have something that we want to do here so coalesce might be
4:15:27
something that's interesting where we have an array so or a list I suppose
4:15:33
so we might say like items
4:15:39
and make that a list null null empty
4:15:47
last okay
4:15:53
bar items so we might say coal
4:15:58
Plus okay and that didn't look like it pulled
4:16:05
anything out of there to reform coalesce operation with this list of strings use this symbol so we could use that
4:16:12
um to do that so that just kind of expands the arguments and so that what happened
4:16:18
here is null didn't exist Alden exists this didn't exists so it pulled out last okay
4:16:24
maybe we might want to just use keys maybe we might just want to use Keys here
4:16:46
okay so it might sound like hello
4:16:52
world goodbye
4:16:58
Moon and remember we can do uh hash Rocket Arrow equals or colon it's just
4:17:03
up to your preference I just wrote that in for whatever reason I'm used to using Ruby and that's what we use as hash Rockets that's the name of the symbol
4:17:10
the equals Arrow um okay it didn't like that so I guess
4:17:15
we do have to do it this way that's totally fine I'm not upset by that I thought it supported all three
4:17:21
maybe it's like minus equals or something I don't know but what we'll do say is save our stuff
4:17:28
and then what we can do here is do keys okay
4:17:34
and it didn't look like it grabbed oh yeah I grabbed the keys that's fine okay and then we might say values
4:17:42
all right um you know maybe we might want to try
4:17:48
reverse that one's pretty clear
4:17:56
one two three
4:18:01
okay so nothing super complicated I wonder if absolute would work in here like the file system so we have absolute
4:18:07
path I don't know if I don't know if this would produce anything here oh it does okay so we could ABS path
4:18:14
say path dot root there you go okay so that pretty much gives you a
4:18:20
general idea of built-in functions so there you go [Music]
4:18:27
all right let's take a look here at terraform Cloud again but in Greater detail so terraform cloud is an application that helps teams use
Terraform Cloud
4:18:34
terraform together and so there is the UI there and terraform cloud is available as a hosted service on
4:18:39
terraform terraform.io it's actually at the app.t terraform.io once you're logged in and it has a lot of different
4:18:46
features so it can manage State files uh have a history of your previous runs a history of your previous States easy and
4:18:53
secure variable injection tagging run trigger so chaining workspaces together specify any version terraform per
4:19:00
workspace Global State sharing commenting on runs notifications via webhooks email and slack organization
4:19:06
and workspace level permissions policy is code via Sentinel policy sets MFA
4:19:12
single sign-on cost estimation Integrations with service now Splunk
4:19:17
kubernetes and custom run tasks and that is not the limit to what it does but this is what I could fit on the slide
4:19:24
okay [Music]
4:19:29
let's take a quick look here at the terminology or anatomy of terraform clouds so we have an organization and
4:19:36
with an organization we have our workspaces and a workspace represents a unique environment or stack then you
4:19:43
have your teams these are composed of multiple members and a team can be assigned to multiple workspaces then you
4:19:49
have runs a run represents a single run of the terraform-run environment that is operating on an execution plan runs can
4:19:55
be triggered by like you your the UI itself or maybe like a git repo it could
4:20:00
be API driven or CLI driven so there you go foreign
4:20:06
[Music] so there are three types of cloud run workflows so when you create a workspace you have to choose a workflow and you
4:20:13
have either Version Control workflow we have CLI driven workflow or API driven
4:20:19
workflow okay so just going over them in Greater detail for the first one which
4:20:24
is that version controlled workflow terraform cloud is integrated with a specific branch in your VCS so githubs
4:20:31
via web hooks whenever pull requests are submitted for branch speculative plans are generated whatever a merge occurs to
4:20:38
that Branch then a run is triggered on terraform Cloud then you have API driven so workspaces are not directly
4:20:43
associated with the Version Control System repository and runs are not
4:20:49
driven by web hooks on your VCS provider a third-party tool or system will
4:20:54
trigger runs via uploading a configuration file via the terraform Cloud API so this configuration file is
4:21:02
a bash script that is packaged in an archive and you're pushing it as a configuration version so you're
4:21:07
basically creating configuration versions every time you do that then there's CLI driven and this is the way
4:21:12
we're going to be using mostly in the course so runs are triggered by the user running terraform CLI commands so you'll
4:21:20
run terraform apply and or plan locally on your machine it's going to just work
4:21:25
as per usual okay [Music]
4:21:31
let's take a look at organization level permissions which manage certain resources or settings across an
4:21:36
organization so the first things that you can set would be something like manage policy so create edit delete the
4:21:42
organization Central policies manage policy override so override soft mandatory policy checks manage
4:21:48
workspaces so create administer all workspaces within an organization manage VCS settings so set of VCS providers and
4:21:55
SSH Keys available within the organization and for an organization we have this concept of organization owners
4:22:01
so every organization has at least one organization owner and you can have multiple this is a special role that has
4:22:07
every available permission and some actions only available to owners so this could be publishing private modules
4:22:14
invite users to organizations manage team memberships view all secret teams manage organization permissions manage
4:22:21
all organization settings manage organization Billings delete organizations and manage agents so just
4:22:27
understand that there are these special ones just for this organizational owner and then these are these other ones here
4:22:33
that you can set for other types of organizational level permissions okay [Music]
4:22:41
let's take a look here at workspace level permissions that allows you to manage resources and settings for a
4:22:47
specific resource and we have granular ones and then we have pre-made permissions so let's go through the granular permissions first so these
4:22:53
granular permissions you can apply to a user via a custom workspace permissions and so we have read runs queue plans
4:23:00
apply runs lock and unlock workspaces download signal locks read variables read and write read State outputs read
4:23:08
State versions read and write State versions and so the idea is that what you can do is just go and cherry pick
4:23:14
out what you want to assemble your permissions for your user now if you want something a little bit easier to do
4:23:22
you can use fixed permission sets and these are pre-made permissions for quick assignment and they're based on the read
4:23:27
plan and write so we have read runs read variables read State versions for plans
4:23:33
we have q plans read variables read State versions We have write so apply runs lock and unlock workspaces download
4:23:39
setting unlocks read write variable read write State versions and then there are
4:23:45
workspace admins and this is kind of like the organizational owner so a workspace admin is a special role that
4:23:51
grants all level of permissions in some workspace admin only permissions those admin only permissions would be read and
4:23:57
write workspace settings set or remove workspace permissions of any team and delete workspaces so there you go
4:24:04
[Music] let's take a look here at API tokens so
4:24:10
terraform Cloud supports three types of API tokens users teams and organization tokens so for organization API tokens
4:24:17
they have permissions across the entire organization each organization can have one ballot API token at a time only
4:24:23
organization owners can generate or revoke an organization token organization API tokens are designed for
4:24:28
creating and configuring workspaces and teams they're not recommended as all-purpose interfaces to terraform Cloud so basically you just use them
4:24:35
when you are setting up your organization for the first time and you want to do it pragmatically okay then
4:24:40
you have Team API tokens so this allows access to workspaces that the team has access to without being tied to any
4:24:46
specific user each team can have one valid API token at a time any member of a team could generate or revoke that
4:24:53
team's token when a token is regenerated the previous token is immediately
4:24:58
becomes invalid designed for performing API operations on the workspaces same access level to the workspace the team
4:25:05
has to access to I would imagine this is when you're sending out your own custom CI CD pipelines or something like that
4:25:11
I'm not really sure exactly the use case for team API tokens we have user API
4:25:16
tokens the most flexible token type because they inherit permissions from the user they are associate could be for
4:25:22
a real user or a machine user when you do terraform login this is what you're getting a a um a user API token okay
4:25:31
foreign [Music] so I just wanted to quickly show you
4:25:37
this axis levels chart that helps you understand uh what kind of permissions you were giving at the access level and
4:25:44
notice there's implicit and then required or explicit permissions I'm assuming that this means that you need to assign those permissions to the user
4:25:50
first before they'd have it so just because you have a user token doesn't mean you get all of these orange diamonds it's just the ones that you've
4:25:57
assigned to that user or team where I believe that the organization you're going to run into a chance where you're
4:26:03
going to have all these permissions by default whether you want them or not so just understand uh that you have to
4:26:10
double check this before you use your tokens and that this chart exists okay [Music]
4:26:19
all right so we covered private registry earlier in the course when we were looking at the terraform registry the public one but let's cover it again with
4:26:25
a little bit different information so terraform Cloud allows you to publish private modules for your organization within terraform Cloud private registry
4:26:32
and tour from Cloud's private module registry helps you share terraform modules across your organization include
4:26:38
support for module versioning a searchable filterable list of available modules a configuration designer which I
4:26:44
didn't find this thing but it sounds really cool all users in your organization can view your private
4:26:50
module registry authentic for authentication you can either use a user token or a team token so I guess this
4:26:56
would be the case where you might want to use a team token for authentication but the type of token you choose May Grant different permissions as we saw
4:27:02
with the access levels just the slide prior using terraform login will obtain a user token just a reminder and to use
4:27:10
a team token you'll need to manually set it in your terraform configuration CLI file okay
4:27:15
[Music] so there's a feature within terraform
4:27:21
Cloud that can do cost estimation and it is a feature that will give you a monthly cost of resources displayed
4:27:27
alongside your runs this feature is only available starting at the teams and governance plan and above but the idea
4:27:33
is that it will tell you for specific resources and give you a summary so notice here that we have some pricing
4:27:39
I'm going to get my pen tool out but we have the overall cost and then it's broken down per resource and so you can
4:27:45
see we have an hourly monthly and monthly Delta I don't know what the monthly Delta is
4:27:50
but um you know it gives you kind of idea of cost you can use sentinel policies to assert the expectation that
4:27:56
the resources are under a particular cost so that's just kind of a bonus there where you're like okay I want to assure my spend is this the only
4:28:02
downside at least at the time right now for cost estimation is the amount of support it has so we have AWS Azure and
4:28:09
gcp so these are the resources that it will support and so you have to look through here and say okay you know is
4:28:15
there any resources I'm using outside of this that I really care about um and that so I think that if you're
4:28:20
using like core services so like ec2 instances load balancers things like
4:28:26
that that should help you out so like we see AWS instance the load balancer the volume some cloudwatch logs ALB for
4:28:34
Google it's just disk instance and database so yeah it's just really dependent on you know what's here so you
4:28:40
know it may meet your needs or you might say okay this is not enough okay [Music]
4:28:49
here's just a few options that I think are worth noting within the terraform Cloud workflows we have a whole section
4:28:55
of workflows but I decided to put it over here just because let's talk about it one thing you can do within terraform cloud is set whatever version you want
4:29:02
so you can go as far back as you want uh and this is great if you need to mix and match different workspaces because you
4:29:09
have different stacks and they were built on different terraform versions and you're just not ready to upgrade them yet you can choose to share State
4:29:15
globally across your organization for a particular workspace this could be really useful if you need to reference
4:29:20
things wherever you can choose to Auto approve run so if you don't want to always do that manual approve you can do
4:29:27
that this is great if you are looking for that kind of agile kind of workflow where if something is merged then it
4:29:33
should be rolled out okay please
4:29:39
let's talk about if we had to migrate our local state and we're using just the default one two terraform Cloud how
4:29:44
would we do it so to migrate terraform projects it only uses the default workspace here from cloud it's pretty easy you're going to create a workspace
4:29:50
and terraform Cloud you're going to replace your terraform configuration with the remote backend so if you have nothing it's using local and you just
4:29:57
put in your remote State and then once you have that in there you do a terraform and knit and it's going to say
4:30:03
hey do you want to copy the existing state you're going to type yes and once you've done that I believe you have to delete your old State file if you are
4:30:09
migrating multiple um multiple environments or you're moving
4:30:15
from a standard remote back end it's a little bit more complicated they definitely have guides in the docs but this is the pretty much standard one
4:30:22
that you're going to come across when you're working very early and we'll definitely see this as we are using
4:30:27
terraform in our follow alongs okay foreign
4:30:33
I want to talk about what kind of Integrations we have for terraform for Version Control Systems so we have
4:30:39
GitHub GitHub auth GitHub Enterprise get lab gitlab EEG and CE I assume that's
4:30:44
Enterprise Edition and Community Edition bucket Cloud bitbucket Server and data center Azure devops service Azure devops
4:30:52
server so it's very simple you're just going to choose from the one of the four right and then you're gonna just drop
4:30:57
down and choose what variant it is there and connect your repo every single
4:31:02
provider has different configuration settings so you might have to meet those depending on what they are you can get
4:31:07
from private repos you might have to add your SSH key or something like that okay [Music]
4:31:16
let's talk about terraform Cloud run environment so when terraform Cloud executes your terraform plan it runs
4:31:22
them in its own run environment so what is a run environment a run environment is a virtual machine or container
4:31:27
intended for the execution of code for a specific runtime environment a run environment is essentially a code build
4:31:32
server so the terraform Cloud run environment is a single-use Linux machine running on the x86 or x64
4:31:39
architecture and the details of its internal simple petition is not known it is possible to install software on it
4:31:45
but the only issue is that we don't know what it is is a Debian is it Ubuntu you just can't tell terraform Cloud will
4:31:50
inject the following environment variables automatically on each runtime so we have TFC run ID this is a unique
4:31:56
identifier for the current run the workspace name the workspace slug so
4:32:02
this is the organization followed by the workspace just going to get my pen tool to just kind of point out over here on
4:32:07
the right hand side we have the configuration version and git Branch so you know if it is going to be on Main
4:32:13
it's going to tell us that if it's going to be a particular version we'll know that as well we can get the shaw of the
4:32:19
current commit there's that version and if you want to access these variables you just Define variable and the name
4:32:24
and then you can access it throughout the code okay [Music]
4:32:32
let's take a look here at terraform Cloud agents this is a paid feature of the business plan to allow terraform Cloud to communicate with isolated
4:32:38
private or on-premise infrastructure it's kind of like an in-between uh between a terraform cloud and terraform
4:32:44
Enterprise where you want to use terraform Cloud but you have uh on-premise infrastructure but you're not ready to move to terraform Enterprise so
4:32:51
this is useful for on-premise infrastructure types such as vsphere nutanix and openstack the agent
4:32:57
architecture is pole based so there are no inbound connectivities required any agent you provision will pull terraform
4:33:03
Cloud for work and Carry Out execution of that work locally agents currently only support the x86 architecture or the
4:33:10
x64-bit Linux operating system okay so you can also run the agent within Docker
4:33:16
using the official terraform agent Docker container if you just prefer that over a VM agent supports terraform
4:33:22
version 0.12 and above the system requires request the system requires I'm going to
4:33:30
change that in the slide later on but the system requires at least four gigabytes of free to space for temporary
4:33:37
temporary local copies and two gigabytes of memory needs access to make outbound
4:33:43
requests so you need to have open port 443 for app terraform i o registry
4:33:49
terraform i o releases hashicorp.com and um
4:33:54
archivist.terra for my IO so there you go [Music]
4:34:01
this is Andrew Brown from exam Pro and we are on to our terraform Cloud uh follow alongs now we already did terraform Cloud uh Version Control
4:34:07
System earlier than I thought we were going to do so I'm going to remove from the list and what we'll do is focus on permissions and maybe the API tokens and
4:34:14
things like that so what I want you to do and I've got some old tabs open here but I'm going to make my way over to uh
4:34:20
terraform.io and I'm going to go log into terraform Cloud here and I don't think I've ever done this
4:34:27
but I can upgrade to the trial count because the thing is is that when we are in our account here and we're trying to
4:34:32
look at permissions and we're not using Force unlocking anymore I might just keep that around for a little bit but if
4:34:38
we were to go to our user settings here we go to organizations
4:34:45
um that might not be a very good example like I said I wanted like the organization settings here
4:34:52
which would be maybe here yep up here and so you know
4:34:58
when we go to our teams and our users our users everyone's being added as an owner we don't have like granular
4:35:03
permissions and that's because we'd have to upgrade and so I figured this would be a good opportunity for me to just
4:35:09
kind of upgrade to show you those uh more detailed uh role-based Access Control permissions just so you know
4:35:15
where they are so I'm gonna go the upgrade now and notice that we're on the free plan and also take note because
4:35:20
later on the course I talk about pricing or we've already already acrossed it but notice that we have a team plan and a
4:35:26
team and governance plan this one's at twenty dollars and this one's at seventy dollars so you know this is not
4:35:32
something that's reflected at least not right now on the terraform website and so it just looks like there's a team in
4:35:37
governance plans for twenty dollars in this middle one's missing the key difference here is this one has Sentinel policies code but you can see on the
4:35:44
free plan we are able to do team-based stuff let's go switch over to the trial plan
4:35:49
I'm going to see if I can do this without entering a credit card in so here it says you're currently on trial
4:35:54
planned I didn't have to enter anything in that's really great and so that means now I have all these Team Management options so if I go over to team
4:36:01
management I can actually go ahead and create some teams uh so I'll just say like Developers
4:36:10
okay and so now I have all these options so we can say this person if someone's in
4:36:16
this team they're allowed to manage policies they're able to do that a visible team can be seen by every
4:36:22
member or you can keep them secret we can generate team API tokens which I
4:36:27
guess we could just like cover this as we do it but notice we can go here and that generates out that token that we can use I'm going to go ahead and delete
4:36:33
that token um so nothing super exciting there you know it's not like that complicated
4:36:40
if we want to set things on the workplace now if we go back to workplace
4:36:46
or workspaces here and now we have Team access and notice I can go to add team uh
4:36:52
permissions here and we can say select this team for their permissions and so these are these uh pre-built ones
4:36:59
in um so we have read plan rights so these are those three predefined ones that we
4:37:06
talked about previously and then we have down here like assign permissions for the admin of a workspace
4:37:11
we are able to set customized permissions so if we toggle this um we should be able to do it I mean
4:37:17
this looks like it's the same thing no I guess it's more granular so here I guess we have our granular permissions that we
4:37:23
can set so for runs we can do read plan or reply Locker unlock a workspace
4:37:30
send a locks things like that it's not super complicated
4:37:35
if we want drain out API tokens for uh well there's the organizational one
4:37:41
there's the teams one and then there's the user one so if we go to the organization
4:37:49
we can see that we can generate out one here so I can say create an API token so there it is let's go ahead and delete that
4:37:55
and if we go back to our teams
4:38:01
we did this earlier but we can generate one here and then if you want to generate one for
4:38:07
your users probably under user settings yeah so we generate tokens there as well okay
4:38:15
so I mean again there's not a lot to talk about here but um yeah so I guess that really covers permissions and API
4:38:22
tokens okay okay so that finished deploying there and so we can see our resources have been created but one
4:38:27
thing that we didn't set was the prefix I'm actually interested to see that that worked properly but what I could do is
4:38:35
say prefix and then do an underscore here and I
4:38:40
don't know how that would affect it
4:38:47
and this actually happened over in this repository here I'm actually using a hyphen so I'm going to just change that
4:38:52
to that
4:39:03
might have to do a terraform edit there migrate the state
4:39:13
so that was a complete mistake on my part but I guess my thought was that I thought I had to have
4:39:19
um this is still on Main and I guess we'd never really set up a production Branch but yeah so now when we have the prefix in it's actually going to prompt
4:39:25
us for the other one so the currently selected workspaces are default does not exist and so Dev is showing up and
4:39:31
notice that we can't deploy to main so I think the thing is is that if we wanted a production one we would just create
4:39:36
that workspace and then it would reflect here so the way you make uh multiple workspaces here would actually have to
4:39:43
make them all so we'd have to make a VCS terraform prod and I'm very certain that it would just show up here and then you
4:39:48
would select the number that you'd want though what's interesting is the fact that we are in the dev branch and we
4:39:54
have to say oh I want to deploy the dev one so that's kind of a little bit of a caveat there but I guess there's not
4:40:00
really any way around it but I mean this pretty much you know explores what we need for
4:40:05
multiple workspaces with terraform cloud and we did the remote ones and we're all good so there we go I guess the last
4:40:12
thing here we should probably do is just clean up so if we go to terraform Dev here we're going to go down to
4:40:18
destruction and we'll run a destroy plan here
4:40:25
okay and once this is all done you know you can go ahead and just delete these
4:40:32
repositories and notice this one is it has a private lock on it so oh because it's actually
4:40:38
running right now so it's being locked so yep there we go so that's it [Music]
4:40:47
all right now let's take a look at the terraform registry the private registry so just go over here and click on registry at the top and we can bring in
4:40:54
public um public things here so I can just go here and type this in and we can hit add
4:41:00
and so now um we just hit add to terraform cloud
4:41:05
add to my organization and that's public facing but we could also add private facing modules
4:41:11
so if we go back to our registry here just going to go ahead and uh
4:41:19
down to publish here and we go to GitHub and I guess custom
4:41:25
and so then I suppose we just have to enter all the stuff in here so as an optional display name for your V Version
4:41:31
Control provider client IDs client secrets
4:41:38
so it seems like there's a lot of work to do we'd have to set up the SSH key pair but I mean that's generally the
4:41:43
details that you need to know for that okay just seems like a lot of work for us to set that up
4:41:49
you know and the course is going to be like hey can you add a private module and be like yes okay
4:41:54
so we'll go ahead and just remove this so you can add both public and private modules
4:42:00
um you know so there you go [Music]
4:42:05
I have mentioned terraform Enterprise so many times in this course but we've never really talked about in detail and
Terraform Enterprise
4:42:11
now is our opportunity to do so so terraform Enterprise is the self-hosted distribution of terraform platform and I
4:42:17
just want to point out sometimes I call the terraform platform terraform Cloud just because that's the more prominent
4:42:23
uh version of it but terraform cloud is a separate product from terraform Enterprise it's just one is uh assassin
4:42:31
the other one is self-hosted so terraform Enterprise offers a private instance of the terraform platform
4:42:36
application with the benefits such as no resource limits with additional enterprise-grade architectural features
4:42:42
such as audit logging so you do you'd have tamper evidence saml single sign-on and I'm sure there's a lot more other
4:42:48
options there so let's just kind of look at the architecture really quickly on how this works so the first thing is you have the terraform platform which is
4:42:55
going to be installed on a machine and in particular this is installed on Linux and it's specifically installed on
4:43:02
Debian okay so I believe that is the Debian logo as far as as I remember if it's not we'll find it on the next slide
4:43:08
if I'm wrong okay you're going to have to have some kind of storage and there's a few different options probably the
4:43:14
most common is going to be on something like S3 but you can store it on the storage or on the disk itself you have
4:43:22
to have a postgres database so that's part of the infrastructure because that is what the platform uses and you'll
4:43:29
also have to have your own TLS certificate to access the machine but there are also cases where you know
4:43:36
these are going through air gapped environments but the idea is that you have SSL or TLS it's like end-to-end
4:43:41
encryption it goes all the way to the machine that's where it terminates okay you'll also need your terraform license
4:43:46
so you'll have to plug that in once you start up the terraform platform say hey tell us the code so you can unlock this
4:43:53
um this software for you to use on this dedicated machine okay
4:43:58
foreign [Music] so the requirements for terraform
4:44:03
Enterprises is going to highly vary based on your operational mode that you choose to run it in and that is really dependent on how data should be stored
4:44:10
and when we're looking at the uh the architectural diagram that was uh the operational mode of external Services
4:44:17
there's three types of operational nodes the first being external Services that's when you use postgres and then use cloud
4:44:24
storage so in that example we're using S3 but you can use gcp Azure blob storage or Mino object storage but the
4:44:31
idea is that postgres and the cloud storage are external they're not part of that Linux server okay then you have a
4:44:37
mounted disk so this would just be having a a persisted disk attached to
4:44:42
the VM so you know in the best case it's called EBS so this stores data in a
4:44:48
separate directory on the host intended for external disk so that would be both the postgres database and the storage
4:44:53
volume itself you know postgres is still a requirement and no matter what mode you use then you have demo so stores all
4:45:00
data on the instance data can be backed up with snapshots not recommended for production use so this is where you have
4:45:07
ethereal data so you know the data you know can vanish if you restart the machine unless you make physical
4:45:12
snapshots another component is credentials ensure you have credentials to use Enterprise
4:45:18
and have a secure connection so the first is we need the terraform Enterprise license so you obtain that
4:45:23
from hashicorp and the other part is having a TLS certificate and private key so you need to prove uh you're the uh
4:45:30
you own uh your own TLS certificate okay then we have the Linux instance so
4:45:35
terraform Enterprises designed to run on Linux and it supports more than one version so you know I said it was only
4:45:42
Debian but I guess there's a bunch I just forgot so we have Debian Ubuntu Red Hat Centos Amazon Linux there's a
4:45:50
variety for those Oracle Linux so yeah I guess I just a big fan of Debian so
4:45:55
that's I guess that was my my thinking there for Hardware requirements we have at least 10 gigabytes of disk space on
4:46:01
the root volume at least 40 gigabytes of disk space for the docker data directory so that would be the VAR lib Docker at
4:46:09
least eight gigabytes of the system memory and at least four CPU cores so
4:46:15
there you go foreign
4:46:21
let's talk about error gapped environments so what is an air gap an air gap or disconnected network is a
4:46:26
network security measure employed on one or more computers to ensure that a secure computer network is physically
4:46:32
isolated from unsecure networks so the public internet so it's no internet no
4:46:37
outside connectivity Industries in the public sector so government military or large Enterprises finance and energy
4:46:43
often employ air gap networks and so I want you to know that hashicorp terraform Enterprise supports an
4:46:48
installation type of air gap environments okay so to install or update terraform Enterprise you will
4:46:54
supply an air gap bundle which is an archive of a terraform Enterprise release version so that's how you would
4:47:00
um you know provided okay [Music]
4:47:06
so let's take a look at terraform Cloud features and pricing so I just want to quickly go through it here so we have
4:47:12
three models we have the open source software so OSS we have the cloud offerings and the self-hosted offerings
4:47:18
I know these tiers we have free teams and governance technically it's teams
4:47:24
and then teams and governance so they're two separate plans but this is the way they display it in their marketing
4:47:30
content but it really is a separate two separate tiers in there you have business and then Enterprise which is
4:47:35
considered self-hosted so in terms of feature set across the board you have IAC
4:47:41
workspaces variables runs resource graphs providers modules the public
4:47:47
module registry which is terraform registry workspace is a bit odd because there are terraform Cloud workspaces
4:47:53
right and then you have local workspaces so technically those should be broken up
4:47:58
into two separate things or named differently but that's just how it is with terraform so you know just asterisk
4:48:05
on that workspaces there for the free tier you get remote state or sorry for everything outside of the open source
4:48:12
you get remote State vs VSC connection so that's Version Control State connection so connecting to GitHub or or
4:48:19
git lab or whatever workspace management secure variable storage remote runs private module registry once we get into
4:48:27
Cloud we get Team Management Sentinel policy as code management cost estimation the reason why I have that in
4:48:32
Red is because on the exam it could ask you when is Sentinel policy available is it available at what level and the thing
4:48:39
is it goes from teams and governments all the way to the Enterprise level now technically there is again one called
4:48:47
teams and there's teams and governance so it's part of teams and governance not part of teams okay
4:48:53
uh once we get into business this is where we start to get single sign-on and audit logging so you know if you need it
4:48:59
in the cloud or if you need it self-hosted both options are available in the business we have the you can have
4:49:06
the self-hosted agents for configuration designer servicenow integration you have it for those uh as well in terms of how
4:49:15
many runs you can have this is very important because this is how many this is going to put a bottleneck in terms of
4:49:20
your infrastructure rights on the free Terry you can have one current run of a workspace and teams you could have two
4:49:28
and then at the business level and Beyond its unlimited current runs for uh
4:49:33
how you would actually interact with um terraform you know this is going to be through the local CLI for the open
4:49:39
source software for these it's Cloud meaning that um it's Cloud that is triggering the
4:49:46
execution commands and then self-hosted it's not in the cloud it's on that private machine okay
4:49:51
uh then we have support So for support it's all community so that's just going
4:49:57
reaching out to DA's maybe there's a slack Channel I believe that they have a form so they have like a form where you
4:50:04
can ask questions and then they have these layers like bronze silver and gold I could not determine what these are
4:50:11
like what is offered in them and the odd thing is is that you know there's a silver and gold but it's offered both at
4:50:17
business and Enterprise so I don't know if like you can upgrade to from silver to gold so it's optional or you always
4:50:23
get silver and gold could not get clarification I tried asking the sales team no one would tell me so I think you
4:50:28
have to really be deep in that sales funnel to find out in terms of pricing it's zero to up to five users so the
4:50:36
thing is and this is really confusing about terraform cloud and they really shouldn't have called it teams up here
4:50:42
but you can start using terraform Cloud for free up to five users as a team okay
4:50:48
so just negate the fact that it's not called teams what they're saying is that teams is really about getting a
4:50:56
base workspace Remote Manager which is actually our RBA like our ABC controls
4:51:03
uh role-based access controls so that's the whole point of using teams so if you need that and that's when you're at five
4:51:09
that's going to use it but you can use it in the free tier as a team and you it absolutely should once you get to the
4:51:16
teams plan it's going to be twenty dollars a month and then if you need teams and governance it's actually like seven dollars a month so again it's kind
4:51:23
of like a bit misleading how they've labeled this out but if you go and open up teams Cloud you can see what the
4:51:29
actual packages are for uh business that self-hosted your contact and sales so I have no idea what
4:51:36
the cost is there so there you go [Music]
4:51:42
all right we're taking a look here at workspaces so workspaces allow you to manage multiple environments or alternate State files such as
Workspaces
4:51:48
development reproduction and there are two variants of the workspace we have CLI workspaces a way of managing
4:51:54
alternate State files locally or via remote back-ends and then we have terraform Cloud workspaces that act like
4:52:01
completely separate working directories I'm going to tell you these two are confusing because they don't exactly
4:52:06
work the same way but they have the same name and originally workspaces were called environments and so you know when
4:52:12
you're using terraform Cloud it makes a lot of sense to call them environments and the CLI workspace it's just a little bit different so you know I'm not sure
4:52:19
if I'm going to do a great job explaining the difference of these things you really have to go through the motion of it to really get the hang of
4:52:24
it but I'll do the best I can here okay so think of workspaces as being similar to having different branches in a git
4:52:30
repo workspaces are technically the equivalent to renaming your state file okay so in terraform 0.9 they used to be
4:52:38
workspaces used to be called environments but people got confused which I have no video why but you know
4:52:44
that's what it is now so by default you already have a single workspace in your local backend called default and the
4:52:51
default workspace can never be deleted so even if you don't think you're using workspaces you absolutely are even the
4:52:57
first time you use terraform at least in the CLI workspace okay [Music]
4:53:05
let's get a little bit into the internals this isn't really that much detail but depending if you are on a
4:53:11
local or remote back end changes how the state file is stored so if you're on a local state or a remote State it's going
4:53:17
to be different so uh terraform stores the the workspace States in a folder called
4:53:23
terraform.tfstate.d on the road State the workspace file are stored directly in the configured backend in practice
4:53:31
individuals or very small teams will have been have known to commit these files to the repos but using a remote
4:53:37
backend instead is recommended when there are multiple collaborators so I guess there's not really much to say here but just understand that when you
4:53:45
have a local state file it's going to be in that terraform TF State D and then when it's remote State you don't have to worry about it okay
4:53:51
[Music] let's talk about interpolation with
4:53:58
current workspaces so you can reference the current workspace name via the terraform.workspace named value so we
4:54:05
saw that in the lineup way earlier in the course so the idea here is that if you wanted to
4:54:11
um see if the default like let's say you want to say am I in the default workspace then return five as opposed to
4:54:17
one because maybe you're very comfortable spinning up more in the default than whether it was something
4:54:23
else and just another example maybe you want to use it to apply the name of the
4:54:29
workspace as a tag so here that would actually give this virtual machine in AWS the name web hyphen whatever it is
4:54:35
production or development so there you go foreign
4:54:42
let's talk about multiple workspaces so a terraform configuration has a back end that defines how operations are executed
4:54:49
and where persistent data is stored so like the terraform state so multiple workspaces are currently supported by
4:54:55
the following backends Azure RM console cos GCS so that's Google Cloud Storage
4:55:02
kubernetes local Manta postgres remote S3 they're not going to ask you this on
4:55:08
the exam which ones are supported but you know for your own purposes if you want to use multiple workspaces with a a
4:55:15
standard back end you probably want to know which ones certain back ends support multiple name workspaces
4:55:20
allowing multiple states to be associated with a single configuration that the configuration still has only
4:55:27
one back end but multiple distinct instances of the configuration to be deployed without configuring a new back
4:55:32
end or changing authentication credentials why would you want to use multiple workspaces for something like a
4:55:38
standard um a standard back end well the idea here
4:55:43
is that you know if let's say you're using terraform cloud and you've reached your limit of five users and it just
4:55:49
gets too expensive to go to the sex user where you have to pay for all of them uh you know then the thing is is that you
4:55:55
know this is an option for you it's just kind of like another option out there until you are ready to pay for terraform Cloud at the next tier up so that's the
4:56:02
reason why I'm mentioning it here for you okay [Music]
4:56:09
all right let's quickly walk through the terraform Cloud workspace and the easiest ways to just show you a screenshots so you create a workspace on
4:56:16
terraform Cloud so first you'll create an organization mine's called exam Pro and within that you'll create multiple
4:56:21
workspaces from there you'll click into your workspace and you'll see uh like previous run States variable settings
4:56:27
we'll click into runs from runs what we'll get is a list of what happened previously we can click into one of
4:56:34
those and we can see our plan and our apply we can leave a comment on each run
4:56:40
that has happened if we if we just want to expand the plan and apply here for plan we will see all the details of what
4:56:47
it would change and then apply is it actually setting up that infrastructure and whether it was successful or not
4:56:53
notice you can also download Sentinel unlock files we'll come and talk about that later when we get to our Central
4:56:59
section we can also see a history of previously held States so these are snapshots of that infrastructure
4:57:07
and so you can click into there and exactly see what it looks like this is useful if you want to go and download it
4:57:12
if you were to need it so here's a diff of what changed since the last state
4:57:17
okay and of course you can download that stuff so you know hopefully that gives you an idea of what you can do with terraform cloud workspaces
4:57:24
foreign [Music] let's talk about terraform Cloud run
4:57:31
triggers so terraform Cloud provides a way to connect your workspaces to one or more workspaces via run triggers within
4:57:38
your organization known as source workspaces so run triggers allows runs
4:57:44
to queue automatically in your workspace on successful apply of runs in any of
4:57:50
your source workspaces and you can connect each workspace to up to 20 source workspaces so run triggers are
4:57:56
designed for workspaces that rely on information or infrastructure produced by other workspaces if a terraform
4:58:02
configuration uses data sources to read values that might be changed by another workspace run triggers lets you
4:58:08
explicitly specify the external dependencies so the idea is just allow you to say okay I have one workspace I
4:58:15
I've triggered that I wanted now to do that so this is really great if you have a bunch of uh of environments or or
4:58:22
Stacks that are reliant on each other and you want it to kind of have a chain reaction the reason I'm mentioning run
4:58:28
triggers is a I think it's a cool feature and B Because triggers is something that is also uh something else
4:58:36
when we're looking at provisioners and I just wanted to just clarify that there's run triggers from terraform cloud and
4:58:42
then there's triggers that are for um well I said provisioners I really mean null resources they have triggers
4:58:48
in that okay so it's not going to show up an example it's just a good to know feature I just want to make sure there's
4:58:53
no confusion with the other triggers [Music]
4:58:59
let's take a look at some of the terraform workspace CLI commands that we have available to us the first starting with terraform workspace list so list
4:59:06
all the existing workspaces and the current workspace is indicated by an asterisk so that is our current
4:59:12
workspace there terraform workspace show show the current workspace so right now we're working in development terraform
4:59:18
workspace select switch to a Target workspace so here we could say select default and now we're in the default
4:59:24
terraform workspace new so create and switch to a new workspace and then we have terraform workspace delete so
4:59:30
delete a Target workspace now understand that this is affecting your
4:59:35
local ones for the CLI commands Okay but um yeah so this would actually show up
4:59:41
in the exam they might ask you like you know which is Select and what does list do and things like that so make sure you
4:59:48
know these commands Okay [Music]
4:59:54
all right so I just wanted to contrast against the local or CLI driven workflows via the terraform Cloud
5:00:00
workflows because there's this great uh table chart that's from the documentation that I want to show you so
5:00:06
to our firm cloud workspaces and local working directories serve the same purposes but they store their data
5:00:12
differently so just looking here we'll go down to components here so for terraform configuration it's going to be
5:00:18
on disk for local for terraform cloud in linked Version Control repositories or periodically uploaded via the API or CLI
5:00:26
we have variable values so this is where we use tfrs and when we're in terraform
5:00:31
Cloud it's in the actual workspace the terraform Cloud workspace and so that means that we are setting environment
5:00:36
variables to propagate that into our code or inject those variables into our code on execution for State it's on disk
5:00:43
or in a remote back end and in the workspace for terraform Cloud it's actually in the workspace credentials
5:00:50
and secrets are in Shell environments or our internet prompts and workspace they're stored ascent the variables these are environment variables again so
5:00:56
there you go [Music]
5:01:02
hey this is Andrew Brown from exam Pro and we are on to our terraform Cloud uh follow alongs now we already did terraform Cloud uh Version Control
5:01:08
System earlier than I thought we were going to do so I'm going to remove from the list and what we'll do is focus on permissions and maybe the API tokens and
5:01:15
things like that so what I want you to do and I've got some old tabs open here I'm going to make my way over to uh
5:01:21
terraform.io and I'm going to go log into terraform Cloud here and I don't think I've ever done this
5:01:28
but I can upgrade to the trial account because the thing is is that when we are in our account here and we're trying to
5:01:33
look at permissions and we're not using Force unlocking anymore I might just keep that around for a little bit but if
5:01:39
we were to go to our user settings here we go to organizations
5:01:46
um that might not be a very good example I guess I wanted like the organization settings here
5:01:53
which would be maybe here yep up here and so you know
5:01:59
when we go to our teams and our users our users everyone's being added as an owner we don't have like granular
5:02:04
permissions and that's because we'd have to upgrade and so I figured this would be a good opportunity for me to just
5:02:10
kind of upgrade to show you those uh more detailed uh role-based Access Control permissions just so you know
5:02:16
where they are so I'm gonna go the upgrade now and notice that we're on the free plan and also take note because
5:02:21
later on the course I talk about pricing or we've already already acrossed it but notice that we have a team plan and a
5:02:27
team and governance plan this one's at 20 and this one's at seventy dollars so you know this is not something that's
5:02:33
reflected at least not right now on the terraform website and so it just looks like there's a team in governance plans
5:02:39
for twenty dollars in this middle one's missing the key difference here is this one has Sentinel policies code but you
5:02:44
can see on the free plan we are able to do team-based stuff let's go switch over to the trial plan
5:02:50
I'm going to see if I can do this without entering a credit card in so here it says you're currently on trial
5:02:55
planned I didn't have to enter anything in that's really great and so that means now I have all these Team Management options so if I go over to team
5:03:02
management um I can actually go ahead and create some teams uh so I'll just say like Developers
5:03:11
okay and so now I have all these options so we can say this person if someone's in
5:03:17
this team they're allowed to manage policies they're able to do that a visible team can be seen by every
5:03:23
member or you can keep them secret we can generate team API tokens which I
5:03:28
guess we could just like cover this as we do it but notice we can go here and that generates out that token that we can use I'm going to go ahead and delete
5:03:34
that token um so nothing super exciting there you know it's not like that complicated
5:03:41
if we want to set things on the workplace now if we go back to workplace
5:03:47
or workspaces here and now we have Team access and notice I can go to add team
5:03:53
permissions here and we can say select this team for their permissions and so these are these
5:03:59
uh pre-built ones in um so we have read plan rights so these are
5:04:05
those three predefined ones that we talked about previously and then we have down here like assign permissions for
5:04:10
the admin of a workspace we are able to set customized permissions so if we toggle this
5:04:17
um we should be able to do it I mean this looks like it's the same thing no I guess it's more granular so here I guess
5:04:22
we have our granular permissions that we can set so for runs we can do read plan or reply
5:04:27
Locker unlock a workspace send a locks things like that
5:04:34
it's not super complicated if you want to drain out API tokens for
5:04:39
uh well there's the organizational one there's the teams one and then there's the user one so
5:04:45
if we go to the organization we can see that we can generate out one
5:04:52
here so I can say create an API token so there it is just go ahead and delete that and if we go back to our teams
5:05:02
we did this earlier but we can generate one here and then if you want to generate one for
5:05:08
your user it's probably under user settings yeah so we generate tokens there as well okay
5:05:16
so I mean again there's not a lot to talk about here but um yeah so I guess
5:05:21
that really covers permissions and API tokens okay okay so that finished deploying there and so we can see our
5:05:27
resources have been created but one thing that we didn't set was the prefix I'm actually interested to see that that
5:05:33
worked properly but what I could do is say prefix
5:05:39
and then do an underscore here and I don't know how that would affect it
5:05:48
and this actually happened over in this repository here I'm actually using a hyphen so I'm going to just change that
5:05:53
to that
5:06:04
might have to do a terraform edit there migrate the state
5:06:14
so that was a complete mistake on my part but I guess my thought was that I thought I had to have
5:06:20
um this is still on Main and I guess we'd never really set up a production Branch but yeah so now when we have the prefix in it's actually going to prompt
5:06:26
us for the other one so the currently selected workspaces are default does not exist and so Dev is showing up and
5:06:32
notice that we can't deploy to main so I think the thing is is that if we wanted a production one we would just create
5:06:37
that workspace and then it would reflect here so the way you make uh multiple workspaces here would actually have to
5:06:44
make them all so we'd have to make a VCS terraform prod and I'm very certain that it would just show up here and then you
5:06:49
would select the number that you'd want though what's interesting is the fact that we are in the dev branch and we
5:06:55
have to say oh I want to deploy the dev one so that's kind of a little bit of a
5:07:00
caveat there but I guess there's not really any way around it but I mean that's pretty much you know explores
5:07:05
what we need for multiple workspaces with terraform cloud and we did the remote ones and we're all good so there
5:07:12
we go I guess the last thing here we should probably do is just clean up so if we go to terraform Dev here uh we're
5:07:18
going to go down to destruction and we'll run a destroy plan here
5:07:26
okay and once this is all done you know you can go ahead and just delete these
5:07:33
repositories and notice this one is it has a private lock on it so oh because it's actually
5:07:39
running right now so it's being locked so yep there we go so that's it [Music]
5:07:48
hey this is Andrew Brown from exam Pro and we are taking a look at Sentinel which is an embedded policies code
Sentinel and Terraform
5:07:53
framework integrated within the terraform platform so what is policies code when you write code to automate
5:08:00
regulatory or governance policies and features of Sentinels include uh it that
5:08:05
it's embedded so enable policy enforcement in the data path to actively reject violating Behavior instead of
5:08:12
passively detecting so it's very active or proactive fine-grained condition
5:08:17
based policies so make policy decisions based on the condition of other values multiple enforcement levels so advisory
5:08:24
soft and hard mandatory levels allow policy writers to warn on or inject
5:08:29
reject Behavior we have external information so Source external information to make holistic policy
5:08:35
decisions we have multi-cloud compatible compatible so ensure infrastructure changes are within business and
5:08:42
Regulatory policy across multiple providers and Sentinel is a paid service part of the team and governance upgrade
5:08:47
package so Syrian team in governance it's available for that business and Enterprise okay
5:08:54
[Music] let us expand a bit on the concept of
5:09:00
policies code and relating to Sentinel so Sentinel is built around the idea and provides all the benefits of policy of
5:09:06
code let's talk about the benefits we get with this so sandboxing the ability to create guardrails to avoid dangerous
5:09:12
actions or remove the need of manual verification codification the policies are well documented exactly represent
5:09:17
what is enforced Version Control easy to modify or iterate on policies with a chain of history of changes over time
5:09:24
testing so syntax and behavior can easily be validated with Sentinel ensuring policies are configured as
5:09:30
expected automation so policies existing as code allows you to allows you to
5:09:35
direct integrate policies in various systems to Auto remediate and notify we're talking about senatal and policies
5:09:42
code we have language so all Sentinel policies are written using the sender
5:09:47
language this is designed to be non-programmer and programmer friendly and embeddable and safe for development
5:09:52
Central provides a CLI for development and testing and for testing Central provides a test framework designed
5:09:58
specifically for for automation so hopefully that gives you an idea of the benefits of policy code and in
5:10:03
particular with Sentinel [Music]
5:10:08
all right let's take a look at the Sentinel language and also just a broad uh range of of use cases that we could
5:10:16
use these for so you can start thinking about how to start applying Sentinel the great thing is that there are a bunch of
5:10:21
example policies provided by hashicorp so you can easily um you know start using them right away
5:10:26
but let's go through the big list to kind of give you an idea where you would use policies code so for AWS maybe you'd
5:10:32
want to restrict the owners of the AWS Ami to a data of the data source maybe you want to enforce mandatory tags on
5:10:38
taggable AWS resources restrict availability zones used by ec2 instances disallow a
5:10:45
0.0.0.04.0 basically anywhere address out to the internet restrict instance types of ec2 so maybe you only want
5:10:52
people using T2 micros require S3 buckets to be private encrypted by KMS since that is a big
5:10:57
um a big problem for people on AWS where their buckets get leaked require vpcs to
5:11:04
have DNS host names enabled we're looking at gcp enforced mandatory labels on VMS disallow allow anywhere cider and
5:11:11
force limits on gke clusters because those can get really expensive restrict machine types of VMS just like AWS for
5:11:17
VMware required storage DRS on datastore clusters restrict size and type of
5:11:22
virtual disks restrict CPU count memory of VMS restrict size of VM disks record
5:11:28
NFS 4.1 and cure Burrows I never can say that properly on NAS data stores for
5:11:34
Azure enforced mandatory tags of VMS restrict Publishers of VMS restrict VM images restrict the size of azure VMS
5:11:41
enforce limits on AKs clusters restricts cider blocks of security groups for
5:11:46
cloud agnostic allowed only say we can only use these allowed providers say or
5:11:53
explicitly say what providers are not allowed limit proposed monthly costs prevent providers in non-root modules
5:12:00
require all modules have version constraints require all resources be created in modules and private module
5:12:06
registry use most recent versions of modules in a private module registry that's more so like about the tooling
5:12:13
around modules now let's take a look at an example and this is one for restricting uh available
5:12:19
zones on ec2 instances so like what data centers you're allowed to use and so we first import our language functions
5:12:25
that's going to allow us to use particular uh feature functions in this we're going to specify our azs we're
5:12:32
going to get all the virtual machines we're going to filter that and restrict the AZ for those VMS we're going to
5:12:39
Define that rule to make it enforceable so there you go thank you
5:12:45
[Music] all right let's take a look here with Sentinel with terraform so Central can be integrated with terraform via
5:12:51
terraform Cloud as part of your IEC provision Pipeline and where it's going to sit is between plan and apply okay
5:12:59
so the way you do it is you're going to have to create a policy set and apply these to the terraform workspace so it's
5:13:04
not that complicated to get it hooked up so yeah that's all there is to it okay
5:13:09
[Music] hey this is Andrew Brown from exam Pro
5:13:15
and we're going to learn a bit about Sentinel with terraform I'm not going to say I'm amazing at it but we are going to stumble our way through and see what
5:13:21
we can accomplish we know we can download Sentinel box and there's also the ability to set policy sets and I do
5:13:27
know that there are a bunch of pre-made Sentinel policies so we go send no policies here terraform
5:13:35
uh and we go examples uh there we are probably here
5:13:40
there are a bunch of ones that we can go in here so I'm thinking that there's something that we can do here
5:13:46
um but we'll have to figure our way through here because I actually haven't ran any um policies myself so we have
5:13:51
these two environments I'm not using Dev anymore I'm done with this I'm going to go ahead and destroy that and we're going to go down to terraform destroy
5:13:58
I'm pretty sure I don't have any running infrastructure actually I'm going to double check by going to the overview everything has been destroyed and so
5:14:05
I'll go back over here and we're going to destroy this I'm going to type in VCS terraform Dev
5:14:14
great if we go into this workplace or workspace nothing is provisioned right now so I want to get everything running
5:14:22
again because last time we ran a destroy so I think that if we want to get this
5:14:28
working it should be pretty easy I'm going to go back to our workflows file here
5:14:35
and we're just going to revert some changes so I'm going to go back and change this to name
5:14:42
and I'm just going to go whoops we're going to go into our 120 directory here and we're going to check out Main and
5:14:48
that actually might just revert those changes there I don't think anything really changed much other than this part here
5:14:54
and so what I'm going to do is just go Um make a minor change it doesn't matter
5:15:00
what it is maybe a space get add all whoops
5:15:06
git commit hyphen m changes get push
5:15:14
I'll have to do a good pull here get push
5:15:21
sorry get push and so what I want to see here is a trigger for the Run
5:15:30
there we go and I'll see you here in a bit when it's provisioned okay all right so after a short little weight there it looks like our branches Ran So I think
5:15:37
our resources are provisioned it's cool we actually have cost estimation I didn't have to do anything to turn that
5:15:43
on we already have it notice that it's giving us an hourly of Zero 12 cents the monthly is going to be eight dollars in
5:15:50
you know 35 cents there if there was more resources there we would obviously get that I assume that it would show up
5:15:55
here in the top right corner so we're not really interested in the provision infrastructure but more so
5:16:02
looking at these Sentinel locks so I'm going to go ahead and download them there and that's going to download as a
5:16:09
um a zip or an archive of some sorts and so what I can do here
5:16:15
is just unzip it so I'm just going to make a new folder here and we'll just call these um
5:16:23
Sentinel marks okay I'm just going to open up the zip
5:16:29
and so here's all the stuff in here so we have a variety of different files I think some of them might be redundant
5:16:34
I'm not sure what we have to do with them but I'm just going to go ahead and grab these and drag them into the folder here
5:16:41
okay and actually what I'm going to do is um I'm going to just make a new section
5:16:47
in my folder here whoops just give me a second here
5:16:54
we'll just open up the Explorer to anything yeah we have a folder right here
5:17:04
because what I want to do is just drop those files in so we can just see them in vs code the contents of them
5:17:15
there we go and so now I'm just going to go down to here and we'll take a look so we have
5:17:20
Sentinel HCL all right and so that's just defining a
5:17:26
bunch of mocks we have this Central File here
5:17:35
so I was hoping when we open this it would be able to figure out what to do with this and I have no idea so you know what what I'm going to do is I'm just
5:17:41
going to do a little bit of reading and I'm going to come back to you after I finish reading this okay all right so spending a little bit of time uh
5:17:48
watching some stuff so I was just going through the Deep dive of Sentinel here uh and just going through the documentation and as far as I understand
5:17:54
it looks like that you write policies and then you can also write tests for your policies to assert that your
5:17:59
policies are doing what you expect them to do and I guess those uh Sentinel locks are written in a form of HCL but
5:18:07
it is a little bit confusing because you get this folder with a bunch of stuff in it and it can be either written as Json or like this htl like format but as far
5:18:16
as I can tell it's just saying what it's done is it's generated out these the current state of exactly what your
5:18:22
infrastructure is and I think that it's going to check to see is it exactly what you expect it to be so I don't know if
5:18:29
MOX is that very useful and might be a little bit too much for this particular course so I'm just going to say okay
5:18:35
let's just kind of ignore locks because they're just a little bit too too
5:18:40
difficult and out of scope here let's follow focus on trying to get a policy implemented so I'm going to go back over
5:18:47
here and what I'm going to do is I know that if I go to settings
5:18:53
I mean I've seen it before I just can't remember if it's under a workspace no it's I think it's at the organization
5:18:59
level so we're gonna go to the settings here and there we have our policies so we here we can create new policies so
5:19:05
managing individual policy terraforms deprecated policy sets now supports VCS integration with direct API uploads this
5:19:12
provides a streamlined policy management experience policies which includes okay so this is the old way of doing it and so we'll go here and create a new policy
5:19:18
set so connect a new policy set um okay so I guess what we have to do oh
5:19:25
boy this is a lot different than I thought it was going to be so I thought it was just like we're going to go here and create it and then dump our code in
5:19:31
which apparently that's what it is but it seems like we need to associate with the policy set so just give me a moment
5:19:36
because I do want to show you the the most up-to-date way to do this I'll be back in a second all right all right so
5:19:41
doing a little bit of reading here it looks like what we have to do is create ourselves a sendile.hcl file and this is
5:19:46
going to say what policies we want to enforce so I assume this is basically the policy set as a file and here we
5:19:52
specify the policies that we care about um I actually just want to go back to the files we were looking at earlier
5:19:58
because we saw this HCL file so I guess this would technically be a policy set is that what we call that here but
5:20:05
notice it says mock so these aren't policies per se these are just grouping mocks but in any case I think we'll have
5:20:13
to create this file so what I'm going to try to do and I don't know this is going to work but we'll just stumble our way through
5:20:18
here because it's the best way to learn is we're going to create ourselves our own Sentinel file here so we're going to
5:20:23
say um Sentinel dot HCL
5:20:28
and we're going to Define ourselves a policy this is going to be the one that we're going to use but I'm just going to grab
5:20:34
it here notice there are different enforcement levels so um I don't really care we put in I just want to see that we can successfully get
5:20:40
anything working here and I'm going to go back to the examples
5:20:45
if we can go find that there so Sentinel policy examples and let's just go take
5:20:51
one of those and see what we can do with it okay so if we scroll on down
5:20:58
um this allows zero zero zero cider Block in the security group that seems like something that would be pretty relevant
5:21:04
restrict instance type of ec2 instance that could be something as well that we could do so you know I just have to decide what
5:21:12
it is we want to do here restrict owners so there's a few that are good here let's take this take a look at this one because I feel like this might be very
5:21:17
simple so yeah this is perfect okay so what we'll do is we'll take uh this policy
5:21:22
here so I wonder if I could just go download this file here it's probably like a download button
5:21:29
well I can't find it so we'll just or maybe it's up here no okay we'll just create this by hand
5:21:35
here so I'm going to go copy and it looks like we can just drop it in here so I'm just going to new
5:21:41
file here and put that there and we will just go to Raw
5:21:50
and we will go ahead and drop that on in there so I wish I had like sandal highlighting
5:21:56
I don't know if there is such one for vs code if there is it'd be really nice so we would type in Sentinel
5:22:05
um uh yes we do this one has more downloads so we'll go
5:22:11
with that one no rating as of yet looks like it works so let's go give them a five star
5:22:19
I think that's only fair because uh no one's done that yet
5:22:28
might be a bit too hard to uh I've never written a review before but we'll go here and say works as expected
5:22:34
thank you for this uh extension
5:22:41
okay so what I'm going to do is go back over to here and so here we have some kinds now we're running a T2 micro I
5:22:49
believe so this policy should cause it to fail and that's exactly what we want but I'm just going to go look up and
5:22:56
down to see if it's all correct looks good to me so I think we'll have to change over here is the name so I'm just going to clear this out and we'll say
5:23:03
restrict ec2 instance type
5:23:08
we'll save that hard mandatory sounds really good to me um probably have to spell it right for
5:23:14
it to work r-e-s yeah strict okay great and so what I'll do is just copy this up
5:23:20
here
5:23:27
okay and so we have our signal HCL file and it's referencing a local file now the question is you know can we use the
5:23:35
same repository I assume we would be able to uh for our policy set but it almost seems like it might encourage you
5:23:40
to have your policies separate from your repository that you're testing and that might be really good because let's say you have multiple workspaces or
5:23:47
environments and they all require the same policy set you wouldn't want to have them in your code base like that but for the purposes of this we're just
5:23:54
going to keep it simple I'm going to go ahead and open up terminal here and we're going to commit these uh these
5:24:00
changes to our Repository and this will end up triggering a deploy even though we don't necessarily want
5:24:06
that to happen but there's no way around that so get well I suppose we could just
5:24:12
cancel it out but or not have the auto apply but I don't feel like changing that so we'll do get status here we'll
5:24:17
go get add all git commit hyphen M uh simple policy here
5:24:26
get push okay and so that's being pushed to our
5:24:32
repository that's going to trigger a deploy and we don't care I I assume that it won't pick up the policy because we
5:24:37
have to kick the policy set so um apparently use the API to upload your
5:24:42
policy set which is kind of cool I suppose we could have done that but um well too late we probably should use VCS
5:24:50
anyway you know what I mean so we'll go to GitHub here and we will find our terraform repository which is here
5:24:57
um you know policy well we should probably name this right so we policy to enforce uh instance type
5:25:09
I don't know if we need a description I guess we'll find it in a second here I guess we could have also put the policy in a um a subdirectory there that might
5:25:17
have been okay to do it's going to default to the main branch which is fine policies enforced On All
5:25:22
workspaces or policies and force on selected workspaces and we only have one but that's what we'll do down here so
5:25:28
we'll say update the name is invalid oh uh it has to be like
5:25:34
a proper name so restrict ec2
5:25:40
now again this is a policy set so you could just say like um you know basic server policy
5:25:47
set that'd probably be better and then you probably want to list to say what it does it restricts
5:25:52
um ec2 instances instance type okay and we'll go down here and create
5:25:58
that policy set and that looks like we're in good shape so we applied it um now will it actually
5:26:06
happen on this run because it's already running I believe we're going to this workplace workspace I like to say workplace it's
5:26:12
workspace and uh we go over here this is already planned and finished so what I want to do is just trigger another uh
5:26:20
um deploy here so there's nothing changed so
5:26:25
I'm not sure what we do here um I guess what we could do and actually this is something that I'm I don't know but like how would you trigger a replace
5:26:33
on here because if we were doing let's go to plan and see what happens I wonder if we could do that in the plan here
5:26:40
reasons for trigger do refresh only plan because one thing I was thinking about is like imagine I
5:26:46
wanted to replace an element you can do that hyphen replace but I don't know how you do that through VCS but anyway what
5:26:52
I'm going to do is just go change anything in our code um so it could just be a space it
5:26:57
doesn't really matter get add plus git commit
5:27:03
trigger uh change and we just want to observe
5:27:09
the um the policy working okay
5:27:18
so I'm just going to open this up here I'm not sure if it's going to show up in the plan section or the apply section so
5:27:24
we'll just wait here to watch see the plan generate out
5:27:43
and so the plan finished um we don't see any Sentinel uh Central being applied there
5:27:49
apply will not run let's expand that there this looks fine
5:27:58
I guess technically we didn't change anything so that probably is not very helpful so what I'm going to do is go
5:28:05
and change a variable because maybe that's that's what's going to help here so we have a micro here which is fine
5:28:10
we're just going to change this over to Nano
5:28:15
that makes sense why I didn't do it so we'll go back over to runs and I'm going to trigger I'm going to start a plan so
5:28:22
uh changed ec2 instance type
5:28:28
we'll say Start Plan
5:28:52
okay so we have one change which is fine
5:28:57
we just okay so that part pass is going to go to cost estimation
5:29:03
that passed it's going to apply it because remember we have um Auto approve on the server so it's not even going to
5:29:09
ask us to confirm it and so I want to see if that policy is in place
5:29:27
well it's running I'm just going to go review our policy here just to make sure it's not like the
5:29:32
opposite saying like you cannot have these so include now a loud easy to do instance type so it's small medium or
5:29:38
large so it really should quit out on this one here
5:29:45
but it seems like it's working like it's not uh it's not picking up the policy but I'll see you hear it back in a bit okay all right so I didn't see the
5:29:53
policy trigger there so I'm going to go back to policy sets and notice here it says zero workspaces which is unusual because I definitely selected one but
5:29:59
maybe I didn't click through or hit uh add so I'm going to go down here and click this one again and maybe I didn't
5:30:05
hit this button here okay and now I'll probably have to hit update um policy set before we do I just
5:30:11
want to read about this these parameters are past the central runtime on performing policy checks so I guess I'd be like a way where you'd have a generic
5:30:17
policy and then you could kind of put parameters in so that's kind of cool so I'm going to go back here and double check to make sure that we have a
5:30:23
workspace set and so what we'll do is just change the variable again
5:30:29
um so we will go to our variables here and I'm going to go change this back to
5:30:34
a micro and so I think this time we are going to have better success okay so we'll hit save we'll go back up to runs
5:30:42
we'll go and start a new plan uh change instance type
5:30:47
again here and we will save that plan and so that
5:30:54
plan is now running I will see you back here in a bit uh when we see that Sentinel policy I don't know when it
5:30:59
triggers so I'll see you back here in a bit all right welcome back so after our cross estimation it did a policy check and you can see that it failed um and
5:31:05
here the error says import TF plans function is not available so I'm not sure why that's happening so I think
5:31:12
that um I mean our set failed but not for the reason we wanted to so I'm going to go investigate this I'll be back in a moment okay all right so uh what I've
5:31:19
done here is I've gone and looked up uh like how to create a policy set and hashicorp learn has this example project
5:31:25
here and if we go into its GitHub project and I go here you're going to
5:31:31
notice that it it's like this apparently does basically the same thing restrict AWS instance type and apparently tag as
5:31:37
well but it doesn't have the TF functions the TF plan functions here so
5:31:44
um maybe we don't need that function in there and maybe the uh the example is just out of date at this time so import
5:31:50
common functions for Sentinel okay but this one doesn't have it it
5:31:55
does it does have it for mocks right um so maybe we just need to kind of like
5:32:02
walk through this really quickly and see how we can fix this so the policy uses the Sentinel TF2 plan import to require
5:32:08
that all ec2 instances have instance types planned under the loud list
5:32:13
but I don't see that import there okay and it is in here
5:32:19
so I guess what we'll do is just grab this one okay and I'm going to go ahead and just
5:32:25
delete this one out here um again this isn't working I don't know if this would work with that one so I'm
5:32:32
going to take it out this is pretty clear what this does so we'll just have that allowed types it's
5:32:37
interesting like here it's underscore and then here it's like a title case there's some inconsistencies there so
5:32:43
they have a lot of types as well um and I'm just seeing if there's like find
5:32:49
resources in here so allow types rule to enforce the name
5:32:57
tag so I don't care about that rule to restrict the instance type so
5:33:03
I'm going to go ahead and grab this one here and let's just take a look at the differences here
5:33:10
okay so instant type allowed rule all ec2 instances as that instance
5:33:16
change after instance type a lot type so this is way way different
5:33:21
um so I mean I fully don't understand this but I do know that this one
5:33:28
it will probably work so I'm going to go down here we have count violations I'm not really
5:33:34
worried about that and
5:33:40
the rule is different like if I was really serious about this I'm sure I could you know figure out the
5:33:47
logic here but again this is just for the purposes of us learning so we don't have to go too crazy here now this says instance type allowed and mandatory
5:33:53
instance tags we're not dealing with tags here so I'm just going to say this
5:34:04
okay and so I think this will produce what we want so allows those types
5:34:11
I don't know if it had this in here
5:34:17
get all instant types from the module I think we didn't put this in here so this might be kind of the equivalent
5:34:26
ec2 instances filter TF plan resource changes
5:34:33
okay contains a create or an update
5:34:41
okay [Music] um I mean this isn't bad we technically
5:34:47
have a name set so you know what I'm just going to grab this whole thing because then we're just going to have a much easier time we don't have to worry
5:34:53
about it but it was nice to walk through that file very quickly because the name tag is set in our project a because we
5:34:59
can see we can see that's the server name so what we'll do is we'll just go ahead and add this to our repository
5:35:06
here and the great thing is that since it's the vs code or it's in the same Version Control System I would think
5:35:12
that it would update in time so what we'll do is just do get add all git
5:35:17
commit hyphen m fix the policy
5:35:22
git push
5:35:27
okay and we'll go back over here
5:35:34
and we will see if the policy check happens and when it
5:35:39
does happen it's actually airing out because we're not using the right instance size right that's what we
5:35:45
want to see a little bit of trial error it's not a big deal I also read like over here that
5:35:52
the Sentinel file for HCL only contains module and policies but then we saw a sentinel file or htl file that clearly
5:35:58
had mocks in it so I mean maybe maybe it just only used locally maybe it's not intended for um
5:36:05
production um so we'll go down here TF plan so it
5:36:10
didn't pick it up okay so what I'm going to do is go back to my policy set and maybe it's just like the order of how
5:36:16
this happened so see this says it was updated uh last five minutes ago
5:36:21
updated it a minute ago so this could just be like a race case where um you know this ran before the other
5:36:28
one so I'm going to try to execute this again start a new plan uh trigger plan
5:36:37
and we'll see if that works now because again this said literally updated a minute ago so maybe it didn't pick it up
5:36:50
so you can see why it would also be good to have your policy set in a separate repo because if you're deploying this you don't want to keep triggering your
5:36:57
deploys so I think probably that's what you know we should have done I mean it's a lot extra work but you know this way you
5:37:03
kind of understand why SO waiting on that plan run I really don't care about cost estimation I mean
5:37:09
you could make a policy to check based on that I I'm assuming we just turned that off if we wanted to
5:37:16
and we'll go over to cost estimation here yeah we can just disable it
5:37:21
but the thing here is that it set our policy passed so we'll go here so the result means
5:37:28
that all Central policies passed so restrict the instance type so description
5:37:34
main rule that requires other rules to be true ruleton Force name tag is on all
5:37:41
instances that's true rule to restrict the instance type so maybe we don't understand uh maybe
5:37:46
this works in the opposite way oh the t2 micros here okay so I just want to see it fail so what we'll
5:37:53
do is go back up to our variables here and we'll go to our instance type
5:38:00
and we'll just change this to Nano and we'll save that
5:38:05
we'll go back over here to our runs oh this is still running the old one
5:38:11
here that's fine we can just queue up another one here so we can just say start a new plan uh new instance type
5:38:23
okay and if we go back over to here the last one wouldn't have done anything
5:38:28
because the infrastructure would have been the same so
5:38:36
the previous one we just did here right it would just been like oh no it's still trying to apply it so I guess there is a
5:38:41
change maybe we changed the instance type last time I don't know so anyway I'll see you back here when
5:38:48
this is completely done okay all right great so we got an error if we go into our instance type here
5:38:53
right and we look at it we can see that it failed because uh it wasn't the right uh type so
5:39:00
um I mean that's pretty interesting so the other thing I would say that we could do is also kind of check out mocks
5:39:06
now because I kind of feel like I have a better grasp on it now that we have a test running so just thinking straight about it a mock really is a
5:39:12
representation of the state of infrastructure at the time of so if we go back to our runs and we go to a
5:39:17
successful run like the trigger plan here and this one was successful we could go to the plans here and then download these mock files so we do have
5:39:25
the ones from prior and I think those are totally fine and valid to use so what if what we do is go back to our
5:39:31
project over here and we have um the mock files over here but really
5:39:38
where they need to be is within the workflow directory because looking at the documentation here what it's saying is that you get all
5:39:45
these things and this basically represents the state of those mock files and then you need to make a test folder and then a test data folder and then
5:39:52
there's gonna be something based on the name of the uh the mock file so what we'll do is we'll go
5:39:58
up to this folder here and we'll say new folder test and then we'll make another
5:40:03
new folder here test data those folders are files
5:40:10
I think those are files so I'll delete that it's just out of habit to click the
5:40:15
um the file there so we'll say new folder so we'll say test and then we'll say another new folder
5:40:21
there test data okay and so we have our sendle file here
5:40:28
so we need to have I think a similarly named one here so if we go back over here
5:40:35
um this is Foo whatever so I think we need to have a folder in here because it's all based on convention and I just
5:40:40
it's pretty not that hard to figure I don't have to read the docs to know that we'll just put that in here take out the word Sentinel
5:40:47
and then I would assume that we need a file in here what's it called like this pass and fail so I'm going to just do a
5:40:52
pass file new pass.hcl
5:40:58
okay and then we have our test data so that was what we had down below here so
5:41:03
I need to go grab that information I'm just looking for a folder where
5:41:10
I might already have open here if I don't that's fine we'll just go ahead down below and just right click
5:41:16
and reveal and explore we'll go over here
5:41:22
and I need to move all these over so I just copy them over and we're going to go over to our terraform work
5:41:30
flow here and I'm going to go here and paste that data in I don't know if these contain any kind
5:41:37
of sensitive data because if they're based on the TF State file these might be something you don't want to share that might be a security vulnerability I
5:41:43
don't know but I definitely won't have these available when I put this repository up for free so we have those
5:41:49
files in the right place and we have all this stuff here so I I
5:41:56
think that um like you notice it's not there so I'm assuming that we need to open up this file and copy into our main
5:42:02
HCL file so we'll go down below here and then I think it's just a matter of copying all this stuff right
5:42:09
we'll say cut and then we will go to
5:42:16
um back up to here I suppose into our
5:42:22
file it's getting a little bit confusing with all this stuff eh okay so that's in the right place our
5:42:29
test data is there good here we are okay so what I'm going to do is just go down here and paste that in
5:42:37
okay and so we didn't write any kind of pass
5:42:42
data test so that's something we will need here I'm not sure what we'll get so we'll
5:42:48
just scroll down here so you can find the contents of a pass.hcl
5:42:58
it's not showing anything here so just give me a moment I'm going to see what we have to do for this this test okay all right so a little bit of Googling it
5:43:04
looks like uh this one's on the same tracker so since we probably copied the mock data from this one or somewhere
5:43:10
through here we could probably just go grab this so um this is pretty much what our pass
5:43:15
file will look like so we'll go ahead and grab this here I don't know if we really need a fail to
5:43:22
write a failing test I don't really care about that I just want to see anything pass here we'll paste that in here we do have to
5:43:27
be sure that we are accessing our data correctly so if we're in test it's going to go up one directory to the
5:43:35
terraform directory but wouldn't it have to then CD into
5:43:41
uh test so I don't think that Source path is correct
5:43:47
just going to double check that here they do have an example repositories let's take a look here what we have
5:43:55
um yeah it's kind of odd so I think that
5:44:01
if this is relevant it needs to go to test data because how else will it get there okay
5:44:09
so we'll do that so test rules main equals true
5:44:14
um okay so that's a pretty simple test and so I think the way we run tests is
5:44:19
there's like a sentinel test thing here I don't know if we have Sentinel installed I don't think so
5:44:27
so there's no Sentinel command so I guess that's something we're gonna have to install Sentinel
5:44:33
[Music] um CLI terraform okay
5:44:39
over here uh we're on technically Linux even
5:44:45
though we're on Windows we're on Linux so here it's just saying uh download it and then put it in the correct path
5:44:52
so install so we'll get the appropriate package here and we are technically on Linux
5:45:01
and I guess we are 64-bit
5:45:08
it's going to download here scroll up oh it is already downloading okay great and so I'm just going to go
5:45:14
to my downloads and I'm going to open it up here
5:45:19
so there it is and so I need to um get it into the user local bin here so
5:45:26
I'm just going to first get it in anywhere so because I'm just working here I'm just
5:45:31
going to go open this up so reveal in the Explorer okay
5:45:37
and this is not where I want it to be I'm just dropping it here for the time being
5:45:47
technically we could run it from there I don't think it'd be that big of a deal so I'm just going to go back to my vs
5:45:53
code here and I'm going to just type signal Sentinel
5:45:59
is there right yep it's there I'm not sure if it's executable but um
5:46:06
I'm just going to type in Sentinel here Sentinel test okay so it doesn't think it's command so
5:46:13
maybe I have to do like chamod U plus X that makes it executable on Linux
5:46:20
so note command not found well heck I'm right there maybe I have to put a period forward slash like that
5:46:25
okay there we go so I mean of course you don't want to leave it in here you and this would also end up in a repository
5:46:31
so this will go to like your user local bin probably so I'm going to say like move sendle to
5:46:38
user local bin and so now I should just be able to type Sentinel it should get picked up
5:46:45
it does great so here I can do test and down below it says open test no such
5:46:52
file or directory so it can't find the mock data notice that it's going into the test test data so that is no good
5:46:58
for us we did say to go up a directory so maybe if I go up back one more like
5:47:03
this would that work
5:47:09
no let's go put back in what they actually had there which I have a hard time believing that would be correct
5:47:16
so open mock okay so that's definitely not right okay and so
5:47:24
personally I just want this to work so I'm just going to cheat this is absolutely what you should not
5:47:30
do but you know like I don't be fiddle around with paths all day here and so I'm just going to give it an
5:47:35
absolute path and see if that fixes our problem okay and so just say test data
5:47:42
here
5:47:48
um so that should absolutely work I'm just
5:47:53
going to expand this here this is mock TF plan
5:47:59
oh but it says pass in the name okay so the problem isn't that it's the fact that the mock data isn't named it's
5:48:04
because the thing is you could download two different mocks right so you could have a state that is successful and failed and you'd probably want to rename
5:48:10
them to say passed or failed so we don't necessarily have that so I think my original thing was correct where we had
5:48:16
this test data and so here we just have to make sure we match the name so mock TF
5:48:22
uh V2 is fine here okay again I don't understand the difference between all these files I
5:48:29
definitely saw the documentation to explain them all so you know that might be something we want to read through here
5:48:34
um so this is looking a little bit better so mock TF plan hyphen version 2 Sentinel
5:48:40
so that is correct but the director it doesn't like the
5:48:45
direct it's going in that test again so again I can just go back up one more layer here
5:48:51
okay there we go and it's passing so
5:48:57
um yeah so that's all it takes to um do that again I think if we were to commit this to our code I don't think
5:49:02
that these run so we can go like so we can just go add it and see what happens so we'll say get add
5:49:08
git commit hyphen M validation
5:49:15
and again I don't know if this mock data should be allowed to be committed into the Repository
5:49:21
because we have a TF State file here right
5:49:31
okay I don't know but I'm going to just do a push here to see what happens but again I I really think that we're
5:49:38
probably not supposed to have it in there um so what we'll do
5:49:43
is go back to our terraform i o
5:49:52
sign in and we'll just see what happens here I
5:49:57
mean we don't expect the uh this to pass because it's still using the wrong instance type but I was just curious to
5:50:03
see if the mock would appear in any way here I don't think it does I think that's just something that you have to do uh beforehand and I think what you'd
5:50:09
have is you'd have a pull request and the pull request could be used to run those unit tests because that's basically what it is okay so yeah that's
5:50:16
exactly what I thought would happen but down below here it says the mock block is not supported so
5:50:24
I wonder what you would do so if you can't have mocks in the file what would you do locally because you
5:50:31
need to I guess the thing is is that the mock file the sentinel.hcl file would not be in this fold so you might have
5:50:39
the central HCL file in your main repository for mocking right and if you
5:50:44
committed it wouldn't run it because the policy set would actually be in another repository so I think that's how it's supposed to work so
5:50:50
yeah I think really we want to have policy sets in their own repository like completely away from there because we're
5:50:56
seeing we're running into a lot of problems but we pretty much accomplished what we wanted to do with Sentinel more than I thought we were going to do so
5:51:02
that's pretty great so there you go um in terms of this we probably want to tear this down uh we do need to do
5:51:08
something with vaults and stuff like that but I think that what we'll do is just tear this down and you know if we
5:51:14
need to bring it back up we'll do that so I'm going to go to destruction here Ed
5:51:22
we're gonna go ahead and just destroy the plan here
5:51:28
okay and we're all now in good shape
5:51:33
and so um yeah I'll see you in the next part okay but we're all done here for for Sentinel
5:51:39
all right uh actually I guess we're not gone here just yet because it looks like our destroy run failed uh because we
5:51:44
didn't pass here so um that is a bit of a problem so we'll have to go to the variables
5:51:51
I guess it's a good Edge case to know about but um we'll go back and change this to a micro even though it's going to just tear it down anyway you know
5:51:58
so we'll go and type in micro save variable and we'll go back to our runs
5:52:04
we'll start a new plan we're sorry we'll go to settings here destruction
5:52:10
cue the plan I'm just curious the community plan we'll redirect a new up output here
5:52:18
okay cool um so I'm just going to type in VCS terraform again here
5:52:28
okay and so this should work and I will come back and just confirm
5:52:35
this with you okay so I'll be back in a second all right so the real reason we can't uh get rid of this is because we have those darn mocks in there so
5:52:44
um what I'm going to do is go over to our signal file here um up to I mean we don't use this one so
5:52:50
I'm gonna go ahead and delete that it's not even something that's going to happen and
5:52:55
we need to update our
5:53:00
HCL file here okay and I'm assuming that this supports uh
5:53:08
this okay because this is not how we should be doing this
5:53:13
um and here we go get add git commit hyphen m
5:53:22
INE or change okay and this is going to trigger a run
5:53:28
here but I really wanted to destroy
5:53:36
so we'll just give it a moment there to start so we can kill it
5:53:42
um did I not push
5:53:50
oh maybe I didn't push and we'll go back here
5:53:56
there's that run I'm going to go in here I want to stop it uh cancel run
5:54:04
okay and so now what I'll do is go over to the here
5:54:09
destroy this we'll run that okay we'll destroy that
5:54:18
and I will again see if this is working and I'll see you back here in a moment okay all right so I just wanted to
5:54:24
confirm there that everything is uh destroyed so we're all in good shape okay so uh yeah so we're actually done
5:54:30
Sentinel now for real okay bye [Music]
5:54:37
all right let's take a look here at hashicor Packer so it's a developer tool to provision a build image that will be
Packer
5:54:43
stored in a repository using a build image before you deploy provides you with the following immutable
5:54:48
infrastructure your VMS and your Fleet are all one-to-one in configuration faster deploys for multiple servers
5:54:55
after each build earlier detection and intervention of package changes or deprecationable technology so let's take
5:55:02
a look at what that workflow would look like so you'd have your code you commit it to your CI CD Pipeline and within
5:55:07
that pipeline it would start up a build server running uh Packer and that would trigger a build image so you'd use a
5:55:14
something to provision it with so you could use ansible or a variety of different provisioners within Packer and
5:55:20
then Packer would then store it somewhere so maybe this would be Amazon machine image because you're deploying to AWS
5:55:26
and then what you do is reference that image in your terraform code and when you provision it would get deployed to
5:55:33
your CSP so this would be AWS in this case so packet configurations is a machine uh
5:55:40
Packer configuration configures the machine via oops
5:55:59
hey it's Andrew Brown from exam Pro and we are taking a look at hashicorp Packers so Packer is a developer tool to
5:56:04
provision a build image that will be stored in a repository so using a build image before you deploy it's going to
5:56:10
give you the following benefits immutable infrastructure your VMS and your Fleet are all one-to-one configuration faster deploys for
5:56:16
multiple servers after each build earlier detection intervention of package changes or deprecation volt
5:56:22
technology let's take a look at what that workflow would look like so first we'd have GitHub or or your git so
5:56:28
wherever you commit your changes and from there that would trigger a CI CD Pipeline with within that cicd pipeline
5:56:35
it would trigger a virtual machine so or a build server that's a running Packer and so that would trigger the build
5:56:41
image process from there Packer would use some kind of provisioner like ansible to provision the image and then
5:56:48
when it was done and and it was all good it would store it summer like in Amazon machine image once it is stored wherever
5:56:55
you want it to go then in terraform you would just reference it using like a data source and then from there you
5:57:00
could provision your resource okay so Packer configures a machine via a packer
5:57:06
template and yes I know the E is missing um so sorry about that but Packer
5:57:12
templates use the hashicorp configuration language HCL which we saw if you remember way earlier in the
5:57:18
course and that's what we're going to review next is what that Packer template file looks like okay [Music]
5:57:27
all right so Packer configures a machine or container via a packer template file
5:57:33
and Packer template uses the hashic configuration language HCL so that's why it looks very familiar to terraform and
5:57:39
a variety of other languages we've been looking at in this course and so what this file is doing is provisioning a
5:57:45
virtual machine on AWS so here you can see that it's a TT micro and the US West 2 region that it's probably going to be
5:57:51
installing Apache since it's named httpd and the way it's going to be created is via an EBS volumes let's talk about kind
5:57:59
of the components that we're looking at here so when you have a packer template file you have to specify a source and
5:58:04
this says where and what kind of image we are trying to build so the source is Amazon EBS so it's looking for an Ami
5:58:11
image or it's being backed by that EBS volume there okay in this case it's an EBS back to Ami the image will be stored
5:58:18
directly in AWS under the ec2 images and so we have the build step so the build allows us to provide configuration
5:58:25
scripts Packers supports a wide range your provisioners so we have shaft puppet ansible power Powershell bash
5:58:32
salt whatever you want basically has it and the post provisioners runs after the
5:58:37
image is built so they can be used to upload artifacts or re-package them all right and the place where this is going
5:58:44
to be stored is going to be on Amis okay so there you go [Music]
5:58:53
let's look at how we actually integrate terraform and Packer together in terms of a CI CD workflow we kind of saw this
5:58:59
in uh that overall graphic in the first uh Packer slide let's just kind of look at the code okay so to integrate Packer
5:59:06
there are two steps they're going to build the image so Packer is not a service but a development tool so you need to manually run Packer or automate
5:59:12
the building of images with a build server running Packer then the second part of that is referencing the image so
5:59:19
once an image is built you can reference reference the image as a data source so
5:59:24
if it's stored in Abus Ami we're going to just Source it from there and the way we select it is what we can do is say
5:59:31
okay get us the most recent one and use this regular expression and the owner
5:59:36
has to be us and and those kind of parameters to decide how to choose that image so that's all there is to it
5:59:43
you're just using data sources to reference them after they've already been built okay [Music]
5:59:51
hey this is Andrew Brown from exam Pro and we are taking a look at using Packer with terraform and mostly it's just
5:59:58
about just using Packer uh and so what I want to accomplish here is to generate
6:00:03
on an image and store that onto Amazon machine images and then load that into a terraform file or like reference it as a
6:00:09
data source so I've never done this before but it should be fun and we'll figure this out so what we're first
6:00:15
going to need to do is download Packer so notice in the top right corner we make your way to Packer however you want
6:00:20
to and we'll go ahead and download and this one is for Windows it's a binary but we are going to be using Linux we've
6:00:28
done this so many times these three two commands so I'm not going to do that again here but if you have yet to do so you can go and run that and so I'm going
6:00:35
to go ahead and install Packer and once Packer is installed I will come back here and we will get to it okay all
6:00:42
right so after a short little weight there Packer is installed and so what I want to do is go into my Packer folder
6:00:47
here and I'm just going to run Packer and see what we get
6:00:53
and so we have Packer build console fix format a knit so install missing plugins
6:00:59
uh it looks kind of similar to terraform build images from a template that sounds
6:01:05
kind of interesting so I think the first thing we're going to need to do is Define ourselves a template file so I
6:01:11
remember I researched one and and put one in my uh slides here so let's make our way over there and see if we can
6:01:18
kind of just like use our notes here as a reference so going down to this Packer file let's go ahead and just write one
6:01:24
here uh I don't say what the name of the Packer file is that would probably help
6:01:29
but I believe that they're just named as dot HCL files so what I'm going to do is go into this here and make a new file
6:01:38
and we're going to say um uh I guess apache.htl since we are
6:01:43
already very familiar with how to install Apache that seems like the easiest way to do it and again this is going to be very similar looking to
6:01:50
terraform because it's you know all based on HCL so we'll do a type
6:01:57
string and we are going to need some kind of default Ami so we can go grab the one
6:02:04
we've been using all along here um I think we specified it
6:02:09
we can just go back to count Count's always a good one to go to um so I just want to go and grab
6:02:18
where is it um count count count where are you you see anybody see it
6:02:29
I'm blanking today so I'm just going to grab it from AWS it's not a big deal
6:02:36
I'm just pulling up AWS here we're going to make our way over to ec2 and we're going to go ahead and launch
6:02:43
ourselves a new server actually I could probably grab it from the old one no I'll launch a new one just in case you don't see anything there that might not
6:02:49
be fair I'm going to go ahead and grab that Ami ID and I'll just move that off screen here
6:02:55
for a moment and we're going to place in that am ID because I assume we want one to override then we're going to say locals uh app name I think the example I
6:03:04
wrote here is is Apache because that is what Apache is is httpd not sure how they came up with that name but uh
6:03:10
that's how they call it so we need to provide ourselves a source so we're
6:03:15
going to do Amazon EBS httpdd
6:03:22
notice that like the source is not called Data it's just called Source if we go over to the documentation here
6:03:28
just what I want to show you here Docs
6:03:33
if it ever loads come on docs you can do it
6:03:40
so down below here or on the left hand side we have sources so I believe if we were to go over to here and go over to
6:03:47
Amazon Ami someone says Amazon MI
6:03:52
overview uh
6:03:58
builders ec2
6:04:03
EBS
6:04:12
I'm just trying to find the same kind of information that it has there a it's not really doing what I want but
6:04:18
anyway I know that this code is correct even though we can't seem to find this out probably just go type in Packer EBS
6:04:25
Amazon EBS I really like to always refer to the documentation when I can here so it does say it's a builder
6:04:33
Amazon abs source
6:04:41
down below here we go all right so yeah um I don't understand this uh this
6:04:47
Builder flag as of yet but uh we'll work our way through here and figure it out okay so I'm gonna go back and pull up my
6:04:54
vs code here and we're gonna put curlies here and so we need our Mi name here
6:05:02
so my server uh dollar sign local
6:05:08
app name instance type T2 micro
6:05:15
region this is going to be us East one Source Ami this is going to be the
6:05:23
variable we set up above amiid then we are going to do SSH username
6:05:28
that's going to be ec2 user that's the default that AWS always has
6:05:34
uc2 user we can do some tags here not really necessary but it's good to probably give
6:05:40
it a name right so we'll just say name Apache server
6:05:48
and actually we could probably just do local.app name maybe instead
6:05:54
and then we have our build step here so we're going to specify our sources and
6:05:59
we're going to do source.amazon ebs.htpd
6:06:08
and we're going to do provisioner Pro
6:06:13
visioner shell
6:06:19
and then we want to provide a script I think we can we can actually do it in line if we didn't want to do a script
6:06:25
there but we know our script works so maybe we should just stick to that so I'm just going to call this
6:06:31
userdata.sh because we already have that somewhere before so we'll do Post process we don't
6:06:37
need a post processor so we just want to run that script um I believe we have that in our terraform
6:06:43
workflow we go over there to our workflow wherever it is
6:06:50
might also be under modules if we go into our module here didn't we create one there called user
6:06:56
data oh that's a yaml file
6:07:02
uh okay um I mean that's not a big deal we could
6:07:07
probably just okay so we're not going to do it that way all right um
6:07:13
if we're not going to do it this way we probably can provide inline things we don't probably have to do script equals so what I'm going to do is go back to
6:07:21
the terraform documentation here or Packer documentation I should say
6:07:26
and what I want to do is look at provisioners we're going to go look at Shell
6:07:31
so it has this inline step and I assume that this is going to run in a sequential order so inline array of
6:07:36
strings okay so what we will do here is we will type in inline
6:07:48
and I've done this like a thousand times but I'm just going to go Google it Apache install AWS tutorial
6:07:56
there's probably like one on the AWS website for it
6:08:02
for like user data
6:08:07
and this is pretty much has some of it here I was just kind of looking for these commands like the Yum install and
6:08:15
the pseudosystem start so we're going to go ahead and grab that
6:08:21
and then we're going to go
6:08:28
and grab the next few lines here
6:08:36
because we want to start and enable what's the three things that we need to do
6:08:42
not complicated at all and so what I'm going to do is type in
6:08:49
Packer build and see what happens now I didn't specify Ava's credentials or anything like that I assume it would
6:08:54
pick up the defaults and we're going to go to the top here so it looks like we have to provide the template name so maybe we'll do Apache
6:09:02
HCL here
6:09:07
and it says error parsing Json invalid character V
6:09:12
for the beginning of the value oh so it has to be pkr.hcl okay
6:09:22
I'm really liking the user experience of the developer experience for these clis they're really good at telling us what's wrong with them
6:09:27
PKR HCL if there's like a default file I don't know what it should be called
6:09:33
uh so we got a bunch of Errors which is fine unsupported argument locals an argument locals is not expected here did
6:09:39
you mean to define a Local's Block it's because I put an equals in front of it supposed to just be this
6:09:46
not that we were really using locals for much here
6:09:54
and looks like it is provisioning found in Ami it's going to use that as the The Source One creating a temporary key pair
6:10:01
authorizing to Port 22 uh name Packer Builder so I don't know
6:10:08
if this uses I don't think it does but I don't know if it uses Amazon uh but
6:10:14
because there's like ec2 Builder image there might be a way to use it with um Packer directly but I'm not sure how to
6:10:20
do that it's going to go through here I'm just going to see to make sure it's not running a pipeline here is it image
6:10:26
Pipelines no okay that's good but what I will do is go over to my ec2 here
6:10:34
and what I want to go do okay so Packer Builders is running as a virtual machine so it's actually
6:10:40
um uh going to spin up a VM and then bake the Ami that way which seems a lot
6:10:47
better um we'll go over to our Mis and see when that happens there
6:10:55
um let's just unlock another those that red stuff doesn't look good seems like it didn't really matter
6:11:02
so the thing like AWS has an entire pipeline for ec2 image Builder but it does cost money to run where I kind of
6:11:09
feel like if all Packer is doing is spinning up a virtual machine temporarily to make that image that's
6:11:14
going to be a lot more cost effective I mean we could go look up what the cost is to use ec2 image Builder while we're
6:11:20
watching this Builder can't seem to type today
6:11:28
uh it's pricing I just want to know the pricing
6:11:37
happy free oh is it there's a no cost I could have swore there was a cost for this
6:11:44
no cost image Builders offered at no cost other than the cost of the underlying AWS resource I think the
6:11:49
thing is that it's that when you use um ec2 image Builder you have to use of
6:11:55
a particular size you know if you don't really use AWS
6:12:00
anymore in Azure gcp I can understand why this is not much of an interest but I'm pretty sure
6:12:06
if I go here
6:12:12
that the size that you get for the image what size of
6:12:18
each image does ec2 image Builder use because I remember it was like really really large un like unreasonably large
6:12:25
and that was the cost involved in it can't find it today it's not a big deal
6:12:30
but waiting for the Ami to become ready so if we go over to our Amis here and give us a refresh we can see that it is
6:12:37
spinning so it is provisioning that Ami while that is going on what we can do is
6:12:42
just start setting up the next part of this so um Within
6:12:48
our Packer here we can say new file and I'm going to say main.tf I'm going to go
6:12:53
as per usual and grab some default codes from our account example which is for right here
6:13:00
okay copy that we're going to go all the way down to the ground here and
6:13:06
going to go into the main TF here paste that on in and we probably want to keep the public
6:13:11
IP around we actually don't really care but I'm putting it in any way I'm going to take out the tags oh I want to leave the name in so I'll just say like server
6:13:17
packer okay server Apache packer
6:13:24
and uh this is the thing that we want to replace out this all looks fine so this
6:13:30
is what we need to figure out is our Ami here it's probably going to come in as a data source it has to come in as a data source and I'm pretty sure that's what I
6:13:37
wrote in our documentation here so yeah AWS Ami example things like that so
6:13:43
what we're going to do is Type in AWS am I
6:13:49
Packer image and we'll just Define that data source so AWS Ami
6:13:57
Packer image and we have executable users executable
6:14:03
users equals self I'm not saying I know what all these options do but like you just go to the
6:14:09
documentation you grab them you got something that works true name regex
6:14:14
okay and so we would do something like start with the little carrot character and what did we name this this starts
6:14:23
with uh my server hyphen probably would have helped if we named it with like something like
6:14:29
packer in the name but I think that's fine um
6:14:36
we might as well might might as well go the full name here and say httpd because that's technically
6:14:42
what it's going to be we might want to match for more values
6:14:49
here so I'm not sure I guess like we do that
6:14:55
because sometimes it's like three digits or whatever but I don't know what Packer is going to do if we keep pushing additional ones I'm not really familiar
6:15:01
with with that so we'll just say owner's equals self
6:15:06
and so now that should be all set up to go as that is running it finished so that's all good
6:15:13
we're going to say terraform init and here it says block definition must
6:15:20
have a block content Eliminator so we have a small problem here
6:15:28
it looks correct to me uh this is not right okay
6:15:38
we'll see if we can knit this
6:15:44
now whether our build image works properly I don't know
6:15:49
it'd be really good to write like some tests for it I imagine that there is some kind of way to do that
6:15:56
um I guess it'd be like the post-processor scripts maybe you'd want to do that where you'd want to use that as a means
6:16:03
for testing I'm not really sure obviously different provisioners might have that kind of
6:16:10
stuff built in so you know it might be just part of the provisioning tool you can use
6:16:16
so it initialized here we're going to do a terraform plan
6:16:21
because I'm hoping that it might complain about the data AWS Ami here if it does not exist properly and it did so
6:16:27
your Curry return no results please change your search criteria and try again so however I wrote this is probably not
6:16:34
correct so I will just take this out here try this
6:16:47
data a to the same at Packer no results so what I'll do is go over to
6:16:54
bc2 here and actually that's the only name that's here for the Ami so I guess I could just go here and grab the name
6:17:03
but maybe that's not the problem oh no that might be fine so we'll just do this
6:17:13
name reg X okay so let's go look up data AWS Ami
6:17:26
ex couple users most recent name regex owners maybe we can just do like a filter here
6:17:34
a regex to apply to an analyst returned by AWS this allows for more advanced filtering not supported by the AWS API
6:17:41
this filtering is done locally on the AWS what returns so I suppose that is good but like I
6:17:48
just need it to work so I'm going to try the filter instead
6:17:55
and I'm actually going to put literally the name in my server httpd
6:18:00
I'm going to take out the regex assuming that is the problem
6:18:09
owners itself executable users itself um please change the criteria
6:18:16
I don't know what executable users users actually does let's maybe look up what that is limit search to users with
6:18:21
explicit launch permissions on the image is that required no so let's just take
6:18:27
that out if more than one there isn't so let's
6:18:33
just take that out for the time being who's the owner of this we're the owner right we have to be
6:18:40
honors this IP address that must be us or sorry not IP but like our account number
6:18:47
so I mean that should be fine
6:19:00
incorrect attribute value type oh okay so that was fine so we'll do dot
6:19:05
ID but you know if you're doing this like
6:19:12
if you wanted a continuous pipeline you'd probably want to get the most recent and have a better regex
6:19:18
um and so I'll do a terraform apply Auto approve and see if this works
6:19:46
one thing I kind of Wonder is like with Packer how would you do like a versioning
6:19:56
because that's what I'm not certain about so like I'm just kind of like looking through here and seeing what they would do for that I would imagine
6:20:03
that uh you're probably supposed to like increment it and have it part of the name nothing's really speaking to me there
6:20:09
but you know like the idea is that you want to have things like zero zero zero zero one zero two zero
6:20:16
three but I imagine like there's some pragmatic way maybe there's like a built-in function or something that we
6:20:22
can do to do that or what you do is you just have a variable probably that's actually what you probably do is you'd
6:20:28
have like variable like version right string
6:20:37
and then you probably set it and it would come through that way like you you'd set it over here it says
6:20:44
our server has finished provisioning let's go C and take see if that actually worked we'll go up to ec2 instances here
6:20:52
that is running copy that paste that in
6:21:03
um the security group doesn't have any open ports right
6:21:10
so it probably did work it's just we didn't create a security group with us so there are no open ports for us to
6:21:16
check I'm not worried about this I don't care if it actually did work or not because we more or less followed all the
6:21:22
steps there but I believe the reason it's not working like there is just because we don't have a security group but I just don't want to fiddle with
6:21:28
that and put it into a state so that it does not match so anyway we're all done here so I'm going to do a terraform
6:21:35
apply Auto approve destroy
6:21:43
so there we go we accomplished that with Packer that pretty much wraps up all the main follow-ons for the course so
6:21:50
hopefully that was a lot of fun um yeah we'll just continue on here [Music]
6:21:59
all right so let's talk about terraforming console because you're going to hear console mentioned throughout the documentation and you
Consul
6:22:05
might think it's critical to the exam but it's not so I just want to make sure we understand its relation to terraform so console is a service networking
6:22:12
platform which provides service Discovery so central registry for services in the network it allows for
6:22:17
direct communication so no single point of failure via load balancers it has a service mesh so managing Network traffic
6:22:22
between Services a communication layer on top of your container application so think middleware it has application
6:22:28
configuration capabilities so console is useful when you have a micro service or
6:22:33
a service oriented architecture with hundreds of thousands of services so these are containerized apps or
6:22:39
workloads and so the way console integrates with terraform is in the following ways it is a remote back end
6:22:45
because console has a key value store and this is where you could store the
6:22:51
state of your terraform files then also there's a console provider because you can use terraform to set up some things
6:22:58
in console for you but there's not much else outside of that okay
6:23:03
[Music]
6:23:08
all right we're taking a look here at hashicor Vault so vault is a tool for securing accessing secrets from multiple
Vault
6:23:15
secret data stores vault is deployed to a server where a vault admin can directly manage secrets and we have
6:23:21
operators also known as developers can access Secrets via an API Vault provides a unified interface to any secret such
6:23:28
as AWS Secrets console key values Google Cloud KMS Azure service principles it
6:23:34
provides tights access control so just in time which is reducing surface
6:23:39
attacks based on a range of time and just enough privilege so reducing surface attack by providing at least
6:23:45
permissive permissions we can also record a detailed audit log so we have
6:23:50
tamper evidence so this is kind of the idea of our little hash Decor fault stack so you have your secrets engines
6:23:57
these are third-party services or sorry cloud services that actually store the secrets you have your Vault cluster
6:24:02
which act as the adapter to your resources and the resources which are going to access them so again vault is
6:24:08
deploy to Virtual machines in a cluster and vaults can be backed up via snapshot so if you do provision them and you're
6:24:15
worried about the state of those vaults you can definitely save those for later okay
6:24:20
[Music] let's take a look here at terraform and
6:24:26
Vault how they would work together so when a developer is working with terraform and they need to deploy a provider like AWS they will need AWS
6:24:33
credentials so AWS credentials are long-lived meaning a user generates a key in secret and they are usable until
6:24:39
they are deleted so the Abus credentials reside on the developers local machine and so the machine is at risk of being
6:24:45
compromised by malicious actors looking to steal this credentials so if we could provide credentials just in time expires
6:24:52
or credentials after a short amount of time so short-lived we could reduce the attack surface area of the local machine
6:24:59
and so this is where Vault comes in because Vault can be used to inject short-lived Secrets at the time of
6:25:04
terraform apply so imagine you are you are the developer and you run your
6:25:11
terraform apply at that point in time it's going to inject the secrets the way we do that is via data sources data
6:25:17
source is always the way we get data into our terraform configuration file but let's look at that in Greater detail
6:25:22
in the next slide here okay foreign [Music]
6:25:29
let's take a look at how this Vault injection via data source works so a vault server is provisioned a vault
6:25:34
engine is configured like AWS Secrets engine The Vault will create a machine user for AWS fault will generate a
6:25:41
short-lived AWS credential for that machine user thought we'll manage and apply database policy and then within
6:25:47
our terraform we can provide a data source to the Vault so that's what we're doing we're saying Vault Ibis access
6:25:53
credentials and we are getting the output from our terraform remote State admin outputs backend and then from
6:26:00
there we can reference them into AWS okay so when terraform applies run it will pull short-lived credentials to be
6:26:06
used used for the scope of the duration of the current run every time you run apply you will get a new short lived
6:26:13
credentials which is the whole point of the short-lived idea okay [Music]
6:26:21
hey this is Andrew Brown from exam Pro and we are taking a look at Vault um and so the idea here is that we want
6:26:28
to be able to inject secrets from vault in a secure manner for our local developer environments I really kind of
6:26:34
wish I included this screenshot or this graphic within my slides I just found it as as of now because it does really
6:26:41
represent all the types of secret engines and capabilities of Vault one thing in particular I wasn't aware of is that it has its own key value store so
6:26:48
that's what we're going to be using we're going to keep it really simple here um but the first thing we're going to have to do is go ahead and install Vault
6:26:55
so just down below I have a link here that I found and we'll go down below and
6:27:01
it's not shouldn't be too hard to install so uh we are on Linux today I mean I'm on a
6:27:08
Windows machine but I'm using Linux um as the windows subsystem there and so
6:27:13
this is where we're going to start and grab our stuff so making my way over to vs code whoops
6:27:19
um and I'm just trying to think should we use this for a new project probably so I'm
6:27:24
going to just CD out here and I'm going to make my way into
6:27:30
uh vault which apparently I don't have a folder for so I'm going to just go here
6:27:36
and we're going to uh if I reveal and explore
6:27:46
and we'll make a new one 200 volts
6:27:53
okay and so we'll start first install something then
6:27:59
we'll set up a project all right so um let's go through the installation process here okay so we'll go do a curl
6:28:07
which is our first step and that's just going to grab the gpg I
6:28:12
think we already have it because we did it for probably the the CLI 4 terraform there but we'll just do it
6:28:19
again there it doesn't hurt I'll add the repository again I think we already did this when we installed the CLI in the beginning of this course
6:28:27
but we'll let it go again there I remember this takes a little bit of time so we'll just wait here for a bit
6:28:36
all right so now we need to run the last command which is actually going to go ahead and install Vault here for us
6:28:41
we'll just go ahead and grab that line and I'm going to go ahead and paste that on in
6:28:47
I'm not sure if I grabbed that properly we'll try that one more time it uh I got my consoles on response so
6:28:54
there we go okay just happens when I um I stop and start recording it just for some reason times
6:28:59
out like that so I'll go ahead and hit enter there and that will go ahead and install our vaults and then after that
6:29:05
we're going to have to start getting it running um there is again a tutorial to inject secrets I'm not going to stick one to
6:29:10
one with it because it does come with a repository but I find that it is a little bit more work than we want to do
6:29:16
here we just want to kind of get a basic example working and I just want to make our lives a little bit easier so I'm
6:29:22
just going to modify it as we go here but uh yeah we'll just wait for that to
6:29:27
install I'll see you back here in a moment okay all right so after a short little weight here I believe that vault
6:29:33
is installed let's find out if it works so we'll type in Vault once I get the responsiveness back from
6:29:39
my console here just giving it a moment great nope nope there we go Vault and so
6:29:45
vault is there and so what we can do is start it up in a developer mode and I remember from here they actually had
6:29:51
some pretty good instructions on the starting of that so um like the way they do this project and
6:29:57
I have the repo here is that they um they provision Vault with a bunch of
6:30:03
different things so I think they're using like S3 here and that would probably be a really common use case for
6:30:09
this but I really want to simplify and I don't want to have to provision that terraform and cross-reference the stuff
6:30:15
so we're just going to simplify that so I'm just looking for the command to start fault because I saw a good one
6:30:21
here that was like vaults um ah here it is right there so Vault
6:30:27
server hyphen dab that starts in the developer mode Dev root token ID there's something about like ceiling or
6:30:32
unsealing stuff I don't know what that means but I assume that's a way of securing the Vault but we're going to go ahead ahead and just type that in so
6:30:38
we're going to go Vault server hyphen Dev hyphen Dev root token ID and
6:30:44
obviously you wouldn't want to do this for your production they call there's education I'm just going to stick with that to make our lives a bit easier and
6:30:49
so what that's going to do is start up a vault server it is running on this port here so I suppose we should export that
6:30:57
or or keep this because we'll probably have to reference it somehow notice we have this like unsealed key so the
6:31:03
unsealed key and root token are displayed Below in case you want to seal or re-authenticate
6:31:08
um developments should not be used in production so what I'm going to do is I'm just going to create a
6:31:14
uh uh a readme file in our vault here so
6:31:20
we'll just say new file read me because I just want to dump this stuff of course you know you should not share these with
6:31:25
anybody but I just don't want to forget these while we're working through this so I'm going to go ahead and copy that
6:31:32
and we will go ahead and save that and so
6:31:38
what I want to do now oops did we lose our terminal
6:31:44
did I close it okay I must have closed it so which one
6:31:49
were we working in second third one which is it fourth okay it's the third one so
6:31:56
don't be like me close out your old one so I'm just gonna close out these old ones so I'm less confused
6:32:02
there we go and so it says that it started on this address here so I'm gonna go copy that address
6:32:08
and we're going to open this up you can do everything via the CLI
6:32:14
uh I just want to copy that there but they have a nice UI which is nice
6:32:20
and so this is where we're going to put that token education and drop that down so there are some other options where
6:32:26
there's a lot of options for authenticating but token is obviously the easiest probably not the most secure because the way we wrote it and notice
6:32:32
that we have a couple things pre-installed so we have cubbyhole which is a per token private secret storage
6:32:38
and then we have key value secret storage again I don't know much about these because this isn't a um
6:32:45
this isn't a course on vault it's just kind of us showing a basic integration and more focus on the terraform side but
6:32:51
here is where we can create our secrets we can of course use the CLI to do that and I think they showed in the getting
6:32:57
started here and we don't have to do it this way I'd rather do it through your eye but you do
6:33:03
like vault key key V put and then you put the name of your secret so here's secret forward slash hello and then the
6:33:10
key and the value that's where the store I assume that this would go to the well this would specify we're using here so
6:33:16
what we'll do is we'll go over here and we'll create ourselves a new secret because we're going to want to store something here so we want the path for
6:33:22
the secret this is pretty common with um if you've ever used parameter store you have a
6:33:27
path I don't know if it starts with a forward slash may not end in a forward slash probably can begin with it so I'm going to say
6:33:33
AWS key because we'll do the key in the secret right so here
6:33:39
oh okay cool cool so we can do forward slash AWS and then down below I would just add another one
6:33:45
maybe I got to add each one at a time so we'll say key and I'll actually go grab our proper
6:33:51
ones um oh I should have stopped that I'm going to
6:33:56
start that up again okay and we'll add a plus there because everything lives in memory when you're
6:34:02
in the dev one so you really don't want to shut that down or you'll have to redo all this from scratch so what I'm going to do is just go back
6:34:09
here and drag this down a little bit more okay and I'm just gonna go see if I have
6:34:16
to re-log in because I might have messed this all up yes I do so we'll type in education so
6:34:21
we really don't want to stop running that server during the duration of this follow along okay and so we'll go back
6:34:28
into secret here create a secret forward slash AWS
6:34:33
uh what do you want is it Json no I don't think it matters if we can add two keys that's all that
6:34:39
matters to me and so what I'm going to do is cat out
6:34:45
credentials of course this is not the secure way of doing it so you know again don't show people these things and so I
6:34:50
want this and I probably should match the name I'm gonna like type in the whole darn thing
6:34:56
and we'll grab this oops I want to see that value is correct good
6:35:03
we're going to add another one here this is going to be our axis Secrets or axis
6:35:08
secret access key I really don't like how those have been named and we'll go ahead and grab on this
6:35:17
and um I mean we don't really need to really store the region here but why not
6:35:22
because we're doing all the rest to here we might as well just throw them all in here for fun
6:35:30
and uh here it says maximum number of versions I don't need anything beyond
6:35:35
one because we're not going to be updating these um require check and set so rights will
6:35:40
only be allowed if the keys current version matches the version specified in the cas parameter not sure what that
6:35:46
means maybe just like you're passing something along when you are doing something but uh I think this is all good
6:35:52
you know what I'm just going to leave that back to 10 just in case I've made a mistake and we have to go debug that I'm going to go hit save and so there are
6:35:58
secrets um and so what we want to do is be able to access them and so maybe this is our
6:36:05
opportunity to learn the CLI here a bit so I have it pulled up on the left hand side and so what I'm going to do is type
6:36:10
in vault key V get and we'll do AWS I don't know if we can start with the forward slash there I'm going to hit
6:36:17
enter and um the server gave an HTTP response to
6:36:22
an https client so I'm not sure
6:36:28
why that's a problem because like I mean I understand that it started up in HT http
6:36:34
but I mean I'm in development so you know what else am I going to really do here let's see if I can just scroll up here
6:36:41
and if there's anything else um hmm
6:36:48
and I could have swore that it installed a private key as we were doing this because I remember seeing that there
6:36:54
was like a private key
6:37:00
I could have swore there was one something but private key so I'm not sure what the problem is here I'll be back in a moment and I will
6:37:07
resolve it okay so the suggestion I'm getting is that we need to
6:37:12
um export a couple of environment variables so see here where it writes this so we
6:37:18
say you need to set the following so maybe we will go through and set those so I'll go grab that there but here's
6:37:25
the thing is like how do I run that because these are I think these are like
6:37:32
not the same so I mean I can't run it over here can I I don't think so
6:37:38
uh well I guess if we're doing key Vault value there maybe we can
6:37:45
um still no good what if we export The Vault token
6:37:51
I think we said it was education here um
6:37:59
let's do Vault status so yeah I'm not sure how we're going to
6:38:05
do it that way I mean it's not a really big deal because I don't think that we have to access it that way but notice
6:38:10
here like as I was reading here you know they're just saying down below oh we had
6:38:17
to set this and that so I'm not really sure
6:38:23
what I would do here so the output is like this run these commands and it should do it
6:38:28
again the error message can be similar to different problems so that or maybe I'm just specifying the key incorrectly
6:38:33
and that's why it doesn't like it so [Music] um let's just type in Vault and see what we
6:38:39
have here so Vault QV maybe if we do like a list can we get a list
6:38:45
list the secrets um AWS
6:38:51
AWS clear
6:38:57
I'm not sure what parameter it wants there uh let's go look it up so let's say like
6:39:04
tariff or was it vault key V list option
6:39:11
seems to want another parameter here I'm going to scroll on down so Secret
6:39:17
forward slash my app um folders are suffixed with the forward
6:39:24
slash the input must be a folder list of a file will not return
6:39:29
um do I have to put Secret in front of it Secret
6:39:38
AWS no so I don't know what the issue is there I just would have been nice to use
6:39:44
it via the CLI but the thing is is that again we don't need to use it that way we just need to
6:39:50
um you know set it and and get it but I thought it would be fun to kind of see a lie there so now that we have those set
6:39:57
the way we're going to extract out these values is by using a data source and so
6:40:03
what I want to do is just create a new local project and I think we'd like to always pull from our account repo here
6:40:09
so I'm going to go all the way up to here and I'm going to go grab the main and I'm just going to copy the contents
6:40:15
there we're going to go all the way down to the ground and we're going to make a new
6:40:21
main TF file here we're gonna go paste that on in
6:40:27
and uh we just want my server we don't need an output it's fine
6:40:33
this is all fine this is all fine but uh the one thing is we don't want to use our particular provider there so what
6:40:39
I'm going to do um is I'm going to just open up our
6:40:47
credentials file there and I'm just going to change this to
6:40:53
something else like other so that it doesn't load that profile there okay I just
6:40:59
take these out of here um I think we can leave that alone
6:41:05
and I think that's everything so what I want to do now we don't need that count we'll get rid of that count
6:41:12
we'll go check out the documentation or the code base here because it gives us a bit of an idea how
6:41:19
we need to implement this we'll go over the operator we'll go over to the main
6:41:26
and so they're setting some variables here like name region path things like that but again we want to grab it from The Source there actually
6:41:33
cross-referencing it like this other they provision the admin and grabbing it that way I don't want to do it that way I wanted to use just the data source
6:41:39
like this so I'm not sure how that's going to work so
6:41:46
let's go look that up
6:41:54
okay so here it says read it was credentials from an AWS secret back end and I'm not trying to do that I'm just
6:42:01
trying to read them from the key vaults okay so we probably want faults
6:42:09
generic secret would this be from Key vault
6:42:15
this resource is primarily intended to be used with the generic secret back end but it is also compatible with any Vault
6:42:20
endpoint that is provided but is that the key value one that's not
6:42:26
clear to me um so I think it is
6:42:33
so let's see if we can figure that out here so I'm just going to move that off screen here and we're going to add ourselves the
6:42:39
data source so I guess we're really not following the other tutorial at all because it we literally have to use a different
6:42:44
um key value there a so we'll say secrets and this is going
6:42:50
to be like AWS credentials Maybe
6:42:55
there's creds they don't have to worry about spelling mistakes and we need to specify a path notice it always starts
6:43:01
with like secret I don't know if we always have to start it with secret so I will just say AWS here
6:43:08
and there might be some additional options I'm just scrolling through to hear that so you have paths so this is
6:43:14
the fully the full logical path from which to request the data to read data from generic secret back in Mountain
6:43:19
Vault by default this should be prefix with secret forward slash so we do have to do that reading from other back ends
6:43:25
as data sources possible consult each back-end documentation to see which endpoint supports the get version
6:43:31
version of the secret to read we only have a single version so we don't have to specify that so technically that
6:43:38
should be correct so what we will want to do now in our provider is specify all those options
6:43:44
so again I'm just going back to the source code this is off screen but we need to set the region the access key
6:43:52
and the secret key here and so this is going to be data and it's
6:43:59
going to be Vault generic Secret
6:44:04
and I guess it would be AWS and then we're accessing those things
6:44:10
like region and so I'm going to go ahead and just copy that really quickly
6:44:20
and we will go over back to our vault here because the names are over here
6:44:25
so go grab that paste that in there we'll go grab that paste that in there
6:44:33
and I'm just going to double check to make sure if I've made any mistakes
6:44:39
this one it's showing it from the admin so it goes admin outputs but we're not outputting from anything we're just grabbing it from uh the Vault there so
6:44:46
maybe what we need to do is just kind of review how this generic fault works
6:44:52
so this does Data Vault generic and then it does data and then Square braces
6:45:00
so I wonder if we always have to do data so for example The Vault there is a a
6:45:05
key named auth token the value is a token that we need to keep Secret but yeah I don't understand is this a
6:45:11
Json object or just a way of referencing it because it doesn't specify that so we'll just give it a try
6:45:17
nothing hurts with trying right so we'll say data and this might again might not be the right way I don't know if it's single or
6:45:24
doubles there it's doubles so I just wonder if that was like the one case where it's doubles
6:45:34
okay and we will do this and so I think that that should
6:45:40
maybe work don't know what I'm wondering is if I if I live with a forward slash would it have
6:45:46
considered that and or is it now double but I don't think so because look here it looks like it's stripped it out
6:45:52
because it just says AWS here so we got a secret since just AWS almost looks like there's a space in the
6:45:57
front of it eh but it's not there so maybe there's not this is kind of like a little glitch so
6:46:04
um we need to go and CD into this directory here
6:46:09
and we just need to do a terraforming knit that's kind of interesting because like
6:46:15
we haven't set up the provider I guess it's not going to happen until we actually use the provider so maybe it's not an issue just yet
6:46:23
I'm curious to see if it pulls any kind of modules in for the vault generic Secret
6:46:29
so we'll just give it a moment there to initialize
6:46:38
okay so after there we can see that it did actually add vault in so it must be ready to take it from there
6:46:45
um I'm going to do a terraform plan here and you know I'm going to just change this to like my server with vaults
6:46:53
now remember it's not going to be able to pull from the um
6:46:58
from our local credentials because we're not setting a profile and we overroad the default just in case so here it's saying a resource a data
6:47:04
resource Vault generic secret AWS has not been declared in the root module um it hasn't I mean it looks like I did
6:47:12
no maybe I typed it wrong so we'll go here I don't think it matters but I'll
6:47:20
just put it above okay and I'm just going to double check to make sure nope it matches oh because
6:47:26
it's eight of his creds that's fair
6:47:47
um you didn't use the option o that's fine so my question will be will this correctly provision because we will not
6:47:52
know until we uh use this right here I suppose if we try to use a data source
6:47:59
for AWS that would probably also indicate whether it's working or not so maybe we should try doing that
6:48:04
we do like data AWS VPC and then we just do like ID equals here
6:48:12
because that would have to use the credentials right and so we'll just go well that's
6:48:18
actually it's not specifying any of the the VPC here so maybe maybe we won't do that because it's just too much work
6:48:25
um so what I'll do here is I'm going to do a terraform apply
6:48:31
Auto approve and Let's cross our fingers and hope this works
6:48:43
and while that is running what I'm going to do is just pull up my AWS environment here
6:48:56
and apparently I'm not logged in so that'll give me a bit of time here to kind of catch up here while this is provisioning there
6:49:19
and so it looks like it actually provisioned the server and if that's the case that means that our secrets are being pulled correctly right so if we go
6:49:26
over to ec2 here
6:49:32
and we go and check out this instance it is running so it worked
6:49:38
um if we just want to do a sanity check to make sure it absolutely is working we can just introduce a bug into this
6:49:43
so maybe we go here and we just say uh um I guess we'd have to make a new
6:49:50
version create a new version and what I'm going to do is purposely introduce some mistakes so we're just going to put like an at sign here on the end we're
6:49:56
going to save that and I'm going to make a minor change like Nano
6:50:01
and so what I'm expecting is for this to fail let's see if it fails on the plan I don't think it will
6:50:10
give it a fail in the apply and it does okay so the plan would tell us whether it didn't work or not so that clearly uh
6:50:17
clearly means it absolutely is pulling from it especially when we're doing the plan so
6:50:24
um I want to go back to our file there I just kind of lost the folder I'm just looking for it the I got
6:50:31
too many um too many Chrome windows open here there it is okay so we'll go back here
6:50:37
and we'll I wonder if we can just revert back to the previous version
6:50:44
um see I don't know if I would delete there I don't want to I don't want to jinx it so I'm just going to go here
6:50:50
and take out that at sign we're going to go ahead and save that and so that should be updated we're going to do terraform plan
6:51:04
great and so what I want to do is just tear this down so we'll say terraform apply Auto approve and Destroy okay and
6:51:13
while that is destroying I'm pretty pretty confident that's going to work I'm going to stop my Vault server oh wait
6:51:19
is that going to still work did I get the credentials in time oh no I I made a big boo-boo okay so
6:51:27
um I I Killed My Vault server before I was supposed to
6:51:34
that's really embarrassing um anyway that's not a big deal because I kind of wanted to stop the server anyway
6:51:40
but I want to go back into our it was credentials there and turn that back to defaults
6:51:46
and I wanted to go back up here and just flip that back so that we can get rid of the server right so I don't want to kind
6:51:52
of lose these for the tutorial so I'm just going to go here and just comment those out for a second
6:51:58
profile defaults oops
6:52:04
region Us East one and
6:52:10
um we'll do that again that's embarrassing
6:52:19
okay and I'm just going to preemptively I'm not going to save this file but I'm just going to do this for now
6:52:26
um it's still trying to connect oh boy
6:52:32
so just put these back in here
6:52:39
because it's set to the Vault can I do a terraform refresh probably not
6:52:46
no probably not what if I do a terraforming net because I did change like I was using Vault so maybe I just
6:52:51
have to do that to fix that problem and let's try destroy again
6:53:03
that was a big boo-boo on my part eh nope okay so let's go back over here
6:53:11
and start it up again and I'm pretty sure there's like a way to back up your vaults like there's probably some kind
6:53:17
of like snapshot or something um again I'm not that uh deep into it so I cannot tell you if that's the case
6:53:24
um so I guess we'll just go back here and remake our secrets
6:53:30
because it shouldn't have persisted right if it did I'd be so happy
6:53:35
nope okay AWS we'll leave 10 in there and then
6:53:41
we'll just have to copy all this stuff over again because of my bonehead mistake there so we have region
6:53:48
which is Us East one U.S east one here
6:53:56
and uh
6:54:03
go over here
6:54:09
well at least you know what to do if that happens to you okay I don't need the uh equal sign there
6:54:18
go ahead and add this one
6:54:36
okay and what we're going to do is go ahead and save that
6:54:41
and we'll just quit out of that we'll do a terraform plan
6:54:47
since we know that that will pick it up right
6:54:54
and uh we'll do terraform apply Auto approve destroy
6:55:00
Okay so again this only applies to development but uh yeah don't kill your Vault server
6:55:06
before you're done destroying okay so I'll see you back here in a moment all right so that infrastructure is
6:55:12
destroyed we can go back to here and then we can stop our server and for your benefit I'm just going to bring back
6:55:18
these in here so you don't have to worry about that and uh yeah we uh we accomplished Vault
6:55:24
for injections now you might say well how would you do this with terraform Cloud well the thing is is that terraform Cloud already uses
6:55:30
uh Vault Under the Hood when you store your environment variables there and the idea is that uh I suppose you don't need
6:55:36
to pull them in from all those sources but I think that was one of my my questions I had when I was talking to one of the DA's which was like okay it's
6:55:43
great that terraform cloud has um uh you know uses behind the scenes but what if I want that to live
6:55:49
somewhere else but maybe that's not really necessary um because I don't know but yeah that's
6:55:55
it so we're all done with vaults
6:56:00
hey this is Andrew Brown from exam Pro and we are taking a look at Atlantis which is an open source developer tool to automate terraform pull requests
Misc
6:56:07
which you can find at run atlantis.io so the idea is once this is installed on your GitHub and you merge a pull request
6:56:13
then it's going to go ahead and do a terraform apply so this would be a way for you to do
6:56:20
um get Ops or to automate your uh your infrastructure as code and the
6:56:25
interesting thing is that hashicorp actually maintains this project they didn't originally build it was built by
6:56:31
two people from another company and it wasn't that they did not want to use terraform Cloud which can do this but at
6:56:38
the time I think they had a hard time at the company getting procurement because it was a very large company and so they
6:56:44
had to build something so they built out this thing and anyway these two people end up
6:56:49
getting hired by hashicorp and hashicorp maintains this project which is really nice because it is an alternative for
6:56:54
terraform Cloud um but uh yeah that's all foreign
6:57:01
[Music] let's take a look at cdk for terraform and so to understand this we need to
6:57:06
First understand what is cdk so AWS Cloud development kit is an imperative infrastructure as code tool with sdks
6:57:13
for your favorite language so the idea is that you can use something like typescript python Java c-sharp go and
6:57:20
Ruby Ruby's definitely there that's the language I like to use AWS cdk is intended only for AWS Cloud resources
6:57:26
because cdk generates a cloud formation so CFN templates this is known as
6:57:31
synthesizing and uses that for IAC but cdk for terraform is a standalone
6:57:36
project by hashicorp that allows you to use cdk but instead of CFN templates it generates out it's going to generate
6:57:41
terraform templates and so basically anything terraform can do you can do it through cdk and that allows you to do
6:57:48
interesting things like use cdk to provision Azure resources so that is
6:57:53
very interesting uh and a great development that I think that they're doing [Music]
6:58:02
hey this is Andrew Brown from exam Pro and we are taking a look at grunt work which is a software company that builds
6:58:07
devops tools that extends or leverages terraform the reason we're talking about them is that they produce a couple of
6:58:13
very popular open source tools that work with terraform and you're going to see their name because um uh you know the co-founders there are
6:58:19
very active in the community uh Jim has wrote in a really good book on terraform so you know it's no surprise that uh
6:58:26
they are present but it's worth giving them a mention so you know who they are uh the first thing I want to mention is the infrastructure is the code Library
6:58:32
so these are a bunch of reusable battle tested production ready infrastructure code for AWS gcp Azure
6:58:38
um and so they have some free ones there and some paid ones there then there's teragram so a thin wrapper that provides
6:58:44
extra tools for keeping your configurations dry we have terror tests a testing framework for infrastructure
6:58:49
provisioned with terraform we have grunt work Landing zones for AWS this is a multi-count security on AWS we have
6:58:56
grunt work pipelines and then there's the grunt work reference architecture and so where we're going to focus our
6:59:02
attention in here is just on Terra Grunt and Terra tasks because those are things I think are essential to know if you are
6:59:09
using terraform because you know you'll run into those use cases where you might want to use them okay [Music]
6:59:18
all right let's take a look here at teragram so this is a thin wrapper for terraform that provides extra tools for
6:59:23
keeping your configuration dry working with multiple terraform modules managing remote State and this is accessible to
6:59:30
tariff Terra grunt.gruntwork.io so the idea here is the concept of don't repeat yourself so
6:59:36
it's a programming methodology to abstract repeated code into functions and modules or libraries and often in
6:59:42
isolate files to reduce code complexity efforts and errors so the way that works is that you'll see these HCL files which
6:59:48
are the Terra grunt code and they're actually named Terra grant.hcl and that's what's going to be used to
6:59:54
abstract away or dry up your terraform files so here is an example of Terror
7:00:01
run now Terra Grant does a lot of different things and you're going to find its use when you actually use
7:00:07
terraform and practice and you run into these limitations in terraform and you go and I wish there was a way around it
7:00:13
integrine like almost always solves that and so one example is being able to generate rate Dynamic providers and I
7:00:20
don't mean like Dynamic values here in the sense that there's that Dynamic value feature of terraform but I just
7:00:27
mean the fact that at the time of this it's very hard to inject or to write out
7:00:33
providers so they have this generate function that allows you to get around that another really interesting thing is that
7:00:39
Terra grunt supports better granular literary for modules by reducing lots of
7:00:44
boilerplate uh the way they do this is is that you are referencing your terraform files uh via the source here
7:00:50
okay so you're not including your modules within your code you're just referencing them and then you pass along
7:00:56
their inputs and this is going to be very important when we look at wanting to write unit tests for your
7:01:01
infrastructure because when you learn about how you test IAC you have to really break things down into smaller
7:01:07
parts and if you have a lot of friction there it's going to make your team not want to adopt that or it's going to make
7:01:13
that process really slow but again this is more like at scale or when you hit these kind of requirements okay
7:01:19
oh [Music] all right let's take a look here at
7:01:26
testing and terraform and so what we have here on the left hand side is our usual um pyramid that tells us the layers of
7:01:32
testing and so I kind of want to walk through the layers there and talk about a bit of the tools that are available to
7:01:38
the terraform community and you know the reason why we want to move up the pyramid here to get uh better tests and
7:01:44
then we'll take a look at Terra test so at the bottom we have static analysis and this is where you test your code without deploying and you've been doing
7:01:49
it all along when you do terraform validate terraform plan or you're using Sentinel you're doing static analysis
7:01:56
and that just means that we're testing you know like the composition or the the
7:02:01
shape of our code or like its outputs to what it says it should be doing okay but
7:02:06
you can't catch all your problems there and that's where you move on to unit testing and unit testing uh you know traditionally means like in programming
7:02:13
to test like a particular function its inputs and its outputs it's a little bit harder for infrastructure because
7:02:20
um you know you have to have it connected to other things so it the definite sessions a little bit warped
7:02:25
but the idea here and specifically with terraform is you're just testing a single module and that really says like
7:02:31
okay well you need to really Pare down that module to be of the small scope and
7:02:36
that's where you end up dividing your modules into very small units of work and so for tooling here we got Terra
7:02:42
Test Kitchen uh terraform and inspec um and so uh yeah that's where that
7:02:48
motivation came with um you know Terra Grande the last thing saying okay let's split them up into smaller stuff uh we
7:02:53
have integration testing this is pretty much just using multiple um uh modules together you know so you
7:03:01
say okay well I know that this Lambda function is working but do I know it works in conjunction with this sqsq or
7:03:06
something like that then you have end-to-end testing and this is where you're testing basically like business use cases so it's not just saying okay
7:03:13
from a technical perspective but from a business use case do or the customer use case do we meet the requirements here uh
7:03:20
and this uh is very hard because what you have to actually do is set up a persistent test Network environment but
7:03:25
once you have one you're going to be really good shape one example of a test
7:03:30
environment and it is paid but groundwork has their own called the grunt work reference architecture uh but
7:03:36
you know if you had to do it without that you'd have to just roll your own kind of environment so you know if you do want a good
7:03:43
breakdown of all these different kinds uh you know Jim from grunt work has a complete talk on automated testing for
7:03:48
infrastructure as a code I strongly recommend it because it really gives you a better scope than what I can cover here
7:03:54
um but let's just go take a quick look at Terra test so Terra test allows you to perform unit tests and integration tests on your infrastructure it tests
7:04:01
your infrastructure by temporarily deploying it validating the results then tearing down the test environment and so
7:04:06
here's an example of what a a test function would look like in Terror test it is written in golang I know golang
7:04:13
can be very hard to use but you don't need to know much about it if you you pretty much copy and paste it and just
7:04:19
kind of tweak the values to get the result you want so you know hopefully that helps to tell you how you would
7:04:24
test in terraform and you know that about Terra test okay

